\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Janela Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of a portable
  Windowing API, which can be used to create a single window in
  Windows, Linux, BSD, or a canvas in Web Assembly running in a web
  browser. You can set a fullscreen mode, change the resolution in the
  window, resize it, use OpenGL commands and get input from mouse and
  keyboard. All this can be achieved by the portable API defined in
  this work.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém a implementação de uma interface de uso de
  janelas. Ela pode ser usada para criar uma única janela no Windows,
  Linux, BSD, ou então um ``canvas'' rodando Web Assembly em um
  navegador de Internet. Você pode ativar um modo de tela cheia, mudar
  a resolução da janela, mudar o tamanho da janela, usar comandos
  OpenGL e obter entrada do mouse e teclado. Tudo isso pode ser obtido
  pela interface de aplicação portável definida neste trabalho.}

\secao{1. Introdução}

Um programa de computador gráfico precisa de um espaço no qual ele
pode desenhar na tela. Em alguns ambientes, como videogames, por
exemplo, cada programa em execução simplesmente tem controle de toda a
tela automaticamente sem que seja necessário reservá-lo ou pedi-lo
para um Sistema Operacional. Por outro lado, quando um programa
executa em um computador com algum ambiente gráfico moderno, é
necessário pedir para que uma região chamada ``janela'' seja
criada. Nela o programa passa a ter controle sobre o seu conteúdo e
pode desenhar na região.

Além de criar uma janela, é importante que tenhamos a capacidade de
entrar e sair do modo tela-cheia se estivermos em ambiente que permite
isso. E também modificar o tamanho em pixels da nossa janela. Fazer
isso em modo de tela-cheia muda a resolução da tela. Já fora da tela
cheia, o efeito é o de redimencionar a janela. Isso é importanto, pois
dependendo dos efeitos visuais usados, pode ser necessário diminuir a
quantidade de pixels desenhados por questões de performance.

\subsecao{1.1. Programação Literária e Notação}

Este artigo utiliza a técnica de ``Programação Literária'' para
desenvolver a API de gerador de números aleatórios. Esta técnica foi
apresentada em [Knuth, 1984] e tem por objetivo desenvolver
\italico{softwares} de tal forma que um programa de computador a ser compilado
é exatamente igual a um documento escrito para pessoas detalhando e
explicando o código. O presente documento não é algo independente do
código, mas sim consiste no próprio código-fonte do projeto.
Ferramentas automáticas são utilizadas para extrair o código deste
documento, colocá-lo na ordem correta e produzir o código que é
passado para o compilador.

Por exemplo, neste artigo serão definidos dois arquivos
diferentes: \monoespaco{window.c} e \monoespaco{window.h}, os quais
podem ser inseridos estaticamente em qualquer projeto, ou compilados
como uma biblioteca compartilhada. O conteúdo de \monoespaco{window.h}
é:

\iniciocodigo
@(src/window.h@>=
#ifndef WEAVER_WINDOW
#define WEAVER_WINDOW
#ifdef __cplusplus
extern "C" {
#endif
@<Define Macros@>
@<Declarações de Janela@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

As duas primeiras linhas assim como a última são macros que impedem
que garantem que as funções e variáveis declaradas ali serão inseridas
no máximo uma só vez em cada unidade de compilação. Também colocamos
macros para checar se estamos compilando o código como C ou C++. Se
estivermos em C++, avisamos o compilador que estamos definindo tudo
como código C e garantimos que não vamos modificar nada usando
sobrecarga de operadores. O código poderá assim ser armazenado de
maneira mais compacta.

As partes vermelhas no código acima mostram que código será inserido
ali no futuro.

Cada trecho de código tem um título, que no caso acima
é \monoespaco{src/window.h}. O título indica onde o código será
inserido. No caso acima, o código irá para um arquivo. Em trechos de
código futuros, haverá diversos títulos, inclusive um com exatamente o
nome das partes em vermelho do código acima. Se o título de um trecho
de código é igual um trecho em vermelho a ser inserido, é ali que tal
trecho de código deve ser posicionado no processo de compilação.

\subsecao{1.2. Funções de API a serem Definidas}

Neste artigo iremos definir as seguintes funções:

\iniciocodigo
@<Declarações de Janela@>=
void _Wcreate_window(void);
@
\fimcodigo

Esta é a função que irá criar uma nova janela. Por padrão, uma janela
em tela cheia. Se a macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}
estiver definida, ao invés disso, ele criará uma janela que não está
em modo de tela-cheia (se suportado pelo sistema).

Se a macro \monoespaco{W\_DEBUG\_WINDOW} estiver definida, esta função
também imprimirá na tela informação sobre o ambiente gráfico. Sua
resolução, por exemplo, ou possivelmente outras informações que possam
ser relevantes.

\secao{2. Criando e Gerenciando a Janela}

\subsecao{2.1. Criando uma Janela no X}

O Sistema de Janelas X, também conhecido como X11, é um sistema de
janelas presente em muitos Sistemas Operacionais, como Linux, BSD, e
até mesmo no MacOX X, onde ele está presente para garantir
compatibilidade com programas mais antigos desenvolvidos antes de seu
sistema de janelas atual. Iremos começar com a criação de janelas no
X11 por ser o sistema de janelas mais amplamente presente.

O X11 funciona em uma arquitetura de cliente-servidor. Quando criamos
um programa gráfico, criamos um cliente que se comunica com o servidor
X usando \italico{sockets}. Todas as operações como a criação de
janelas, redimencionar a janela e mais, são feitas com o cliente
pedindo para que elas sejam feitas para o servidor, que executa os
pedidos se possível.

Iremos usar o X11 sempre que não estivermos usando o Windows (que não
o fornece) e nem estivermos compilando Web Assembly (navegadores de
Internet também não o implementam). Antes de usar o X11, precisamos
inserir seu cabeçalho relevante:

\iniciocodigo
@<Cabeçalhos@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xlib.h>
#endif
@
\fimcodigo

No X11, como temos que nos comunicar com um servidor, criamos uma
janela fazendo os seguintes passos:

1. Abrimos uma conexão com o servidor. Se isso for bem-sucedido, o
servidor nos revela várias informações relevantes sobre a tela.

2. Obtemos da resposta dada pelo servidor qual é a tela padrão onde
devemos criar nossa janela (um computador pode ter muitos monitores e
telas diferentes).

3. Também checamos na resposta dada a resolução da tela.

4. Enviamos uma nova mensagem para o servidor pedindo que a janela
seja criada. Faremos isso na tela padrão. O tamanho da janela poderá
ser controlado pelas
macros \monoespaco{W\_WINDOW\_DEFAULT\_RESOLUTION_X}
e \monoespaco{W\_WINDOW\_DEFAULT\_RESOLUTION_Y} sendo que se elas
tiverem um valor não-positivo, interpretamos isso como uma instrução
para criar a janela com o maior valor possível que ainda caiba dentro
da tela.

Estes passos são implementados por meio das seguintes funções e
macros:

\iniciocodigo
@<X11: Criar Janela@>=
/* Passo 1: */
display = XOpenDisplay(NULL);
if(display == NULL){
  fprintf(stderr, "ERROR: Could not connect to a X Server.\n");
  exit(1);
}
/* Passo 2: */
screen = DefaultScreen(display);
/* Passo 3: */
screen_resolution_x = DisplayWidth(display, screen);
screen_resolution_y = DisplayHeight(display, screen);
/* Passo 4: */
window = XCreateSimpleWindow(display, // Conexão com o X11
                             DefaultRootWindow(display), // Janela-mãe
                             0, 0, // Posição da janela criada
                             (W_WINDOW_DEFAULT_RESOLUTION_X <= 0)?
                              (screen_resolution_x):
                              (W_WINDOW_DEFAULT_RESOLUTION_X), // Largura
                             (W_WINDOW_DEFAULT_RESOLUTION_Y <= 0)?
                               (screen_resolution_y):
                               (W_WINDOW_DEFAULT_RESOLUTION_Y), // Altura
                             0, 0, // Espessura e cor da borda
                             0); // Cor padrão da janela
@
\fimcodigo

Este código assume que temos as seguintes variáveis declaradas:

\iniciocodigo
@<Variáveis Locais@>=
static Display *display; // Conexão com servidor e info sobre tela
static Window window;    // Estrutura da janela criada
static int screen_resolution_x, screen_resolution_y; // Resolução da tela
@
\fimcodigo

Agora temos que levar em conta que as macros que determinam a
resolução padrão da janela podem não estar definidas. Se for o caso,
por padrão iremos definir elas com zero:

\iniciocodigo
@<Define Macros@>=
#if !defined(W_WINDOW_DEFAULT_RESOLUTION_X)
#define W_WINDOW_DEFAULT_RESOLUTION_X 0
#endif
#if !defined(W_WINDOW_DEFAULT_RESOLUTION_Y)
#define W_WINDOW_DEFAULT_RESOLUTION_Y 0
#endif
@
\fimcodigo

O código que temos até agora cria a janela. Mas não a desenha na
tela. Não desenhar ela na tela automaticamente permite que nós
ajustemos atributos da janela antes que ela seja finalmente exibida.

Uma das coisas que é relevante ajustar nessa estrutura é em que tipo
de eventos nosso programa quer prestar atenção quando estiver
executando. Exemplo de evento que não consideraremos interessante: o
usuário move a janela pela tela. Exemplo de evento interessante: o
usuário pressiona um botão enquanto nossa janela está ativa.

A lista de eventos que considerearemos importantes o bastante para que
nosso programa seja notificado é: janela é criada ou destruída,
usuário aperta ou solta botão de teclado, usuário aperta ou solta
botão do mouse e usuário move o mouse. Se não pedirmos para sermos
informados disso, nenhum evento será informado para nosso programa e
ele não saberá quando o usuário interage com ele por meio de mouse e
teclado.

\iniciocodigo
@<X11: Criar Janela@>+=
XSelectInput(display, window, StructureNotifyMask | KeyPressMask |
                              KeyReleaseMask | ButtonPressMask |
                              ButtonReleaseMask | PointerMotionMask);
@
\fimcodigo

Outra coisa importante é definir o nome da janela que será
criada. Geralmetne essa informação é apresentada de alguma forma pelo
gerenciador de janelas. Podemos deixar que o usuário escolha isso
ajustando a macro \monoespaco{W\_WINDOW\_NAME}:

\iniciocodigo
@<X11: Criar Janela@>+=
XStoreName(display, window, W_WINDOW_NAME);
@
\fimcodigo

Se essta macro não estiver definida, deixamos apenas uma string vazia:

@<Define Macros@>=
#if !defined(W_WINDOW_NAME)
#define W_WINDOW_NAME ""
#endif
@
\fimcodigo



\subsecao{X. Estrutura Final do Arquivo}

O arquivo com o código-fonte de todas as funções definidas neste
artigo terá a seguinte forma:

\iniciocodigo
@(src/window.c)@>=
#include "window.h"
@<Cabeçalhos@>
@<Variáveis Locais@>
@<Funções@>
@
\fimcodigo


\fim
