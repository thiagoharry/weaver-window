\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Janela Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of a portable
  Windowing API, which can be used to create a single window in
  Windows, Linux, BSD, or a canvas in Web Assembly running in a web
  browser. You can set a fullscreen mode, change the resolution in the
  window, resize it, use OpenGL commands and get input from mouse and
  keyboard. All this can be achieved by the portable API defined in
  this work.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém a implementação de uma interface de uso de
  janelas. Ela pode ser usada para criar uma única janela no Windows,
  Linux, BSD, ou então um ``canvas'' rodando Web Assembly em um
  navegador de Internet. Você pode ativar um modo de tela cheia, mudar
  a resolução da janela, mudar o tamanho da janela, usar comandos
  OpenGL e obter entrada do mouse e teclado. Tudo isso pode ser obtido
  pela interface de aplicação portável definida neste trabalho.}

\secao{1. Introdução}

Um programa de computador gráfico precisa de um espaço no qual ele
pode desenhar na tela. Em alguns ambientes, como videogames, por
exemplo, cada programa em execução simplesmente tem controle de toda a
tela automaticamente sem que seja necessário reservá-lo ou pedi-lo
para um Sistema Operacional. Por outro lado, quando um programa
executa em um computador com algum ambiente gráfico moderno, é
necessário pedir para que uma região chamada ``janela'' seja
criada. Nela o programa passa a ter controle sobre o seu conteúdo e
pode desenhar na região.

Além de criar uma janela, é importante que tenhamos a capacidade de
entrar e sair do modo tela-cheia se estivermos em ambiente que permite
isso. E também modificar o tamanho em pixels da nossa janela. Fazer
isso em modo de tela-cheia muda a resolução da tela. Já fora da tela
cheia, o efeito é o de redimencionar a janela. Isso é importanto, pois
dependendo dos efeitos visuais usados, pode ser necessário diminuir a
quantidade de pixels desenhados por questões de performance.

\subsecao{1.1. Programação Literária e Notação}

Este artigo utiliza a técnica de ``Programação Literária'' para
desenvolver a API de gerador de números aleatórios. Esta técnica foi
apresentada em [Knuth, 1984] e tem por objetivo desenvolver
\italico{softwares} de tal forma que um programa de computador a ser compilado
é exatamente igual a um documento escrito para pessoas detalhando e
explicando o código. O presente documento não é algo independente do
código, mas sim consiste no próprio código-fonte do projeto.
Ferramentas automáticas são utilizadas para extrair o código deste
documento, colocá-lo na ordem correta e produzir o código que é
passado para o compilador.

Por exemplo, neste artigo serão definidos dois arquivos
diferentes: \monoespaco{window.c} e \monoespaco{window.h}, os quais
podem ser inseridos estaticamente em qualquer projeto, ou compilados
como uma biblioteca compartilhada. O conteúdo de \monoespaco{window.h}
é:

\iniciocodigo
@(src/window.h@>=
#ifndef WEAVER_WINDOW
#define WEAVER_WINDOW
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
@<Cabeçalho OpenGL@>
@<Define Macros@>
@<Declarações de Janela@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

As duas primeiras linhas assim como a última são macros que impedem
que garantem que as funções e variáveis declaradas ali serão inseridas
no máximo uma só vez em cada unidade de compilação. Também colocamos
macros para checar se estamos compilando o código como C ou C++. Se
estivermos em C++, avisamos o compilador que estamos definindo tudo
como código C e garantimos que não vamos modificar nada usando
sobrecarga de operadores. O código poderá assim ser armazenado de
maneira mais compacta.

As partes vermelhas no código acima mostram que código será inserido
ali no futuro.

Cada trecho de código tem um título, que no caso acima
é \monoespaco{src/window.h}. O título indica onde o código será
inserido. No caso acima, o código irá para um arquivo. Em trechos de
código futuros, haverá diversos títulos, inclusive um com exatamente o
nome das partes em vermelho do código acima. Se o título de um trecho
de código é igual um trecho em vermelho a ser inserido, é ali que tal
trecho de código deve ser posicionado no processo de compilação.

Como um segundo exemplo de código, também declararemos aqui que quando
estamos em modo de depuração (ou seja, quando a
macro \monoespaco{W\_DEBUG\_WINDOW} está definida) iremos precisar das
declarações de funções de entrada e saída padrão, já que nosso código
se tornará mais verboso:

\iniciocodigo
@<Cabeçalhos@>=
#if defined(W_DEBUG_WINDOW)
#include <stdio.h>
#endif
@
\fimcodigo

Note que ainda não informamos onde exatamente o código denominado
``Cabeçalho'' será colocado. Faremos isso posteriormente.

\subsecao{1.2. Funções de API a serem Definidas}

Neste artigo iremos definir as seguintes funções:

\iniciocodigo
@<Declarações de Janela@>=
bool _Wcreate_window(void);
@
\fimcodigo

Esta é a função que irá criar uma nova janela. Por padrão, uma janela
em tela cheia. Se a macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}
estiver definida, ao invés disso, ele criará uma janela que não está
em modo de tela-cheia (se suportado pelo sistema).

Se a macro \monoespaco{W\_DEBUG\_WINDOW} estiver definida, esta função
também imprimirá na tela informação sobre o ambiente gráfico. Sua
resolução, por exemplo, ou possivelmente outras informações que possam
ser relevantes.

Em caso de erro, a função retornará falso.

\iniciocodigo
@<Declarações de Janela@>=
bool _Wdestroy_window(void);
@
\fimcodigo

Esta função vai fechar a janela aberta, liberando qualquer recurso que
tenha sido alocado pela função anterior ao criar janela. A função deve
ser invocada sempre após a janela já ter sido criada. Em caso de erro,
retorna falso.

\iniciocodigo
@<Declarações de Janela@>=
bool _Wrender_window(void);
@
\fimcodigo

Esta função irá efetivamente renderizar na tela todos os comandos
OpenGL pendentes desde a última renderização. Retornará falso em caso
de erro. Esta função provavelmente será chamada no fim de cada
iteração de um laço principal.


\secao{2. Criando e Gerenciando a Janela}

\subsecao{2.1. Criando uma Janela no X}

O Sistema de Janelas X, também conhecido como X11, é um sistema de
janelas presente em muitos Sistemas Operacionais, como Linux, BSD, e
até mesmo no MacOX X, onde ele está presente para garantir
compatibilidade com programas mais antigos desenvolvidos antes de seu
sistema de janelas atual. Iremos começar com a criação de janelas no
X11 por ser o sistema de janelas mais amplamente presente.

O X11 funciona em uma arquitetura de cliente-servidor. Quando criamos
um programa gráfico, criamos um cliente que se comunica com o servidor
X usando \italico{sockets}. Todas as operações como a criação de
janelas, redimencionar a janela e mais, são feitas com o cliente
pedindo para que elas sejam feitas para o servidor, que executa os
pedidos se possível.

Iremos usar o X11 sempre que não estivermos usando o Windows (que não
o fornece) e nem estivermos compilando Web Assembly (navegadores de
Internet também não o implementam). Antes de usar o X11, precisamos
inserir seu cabeçalho relevante:

\iniciocodigo
@<Cabeçalhos@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xlib.h>
#endif
@
\fimcodigo

No X11, como temos que nos comunicar com um servidor, criamos uma
janela fazendo os seguintes passos:

0. Avisamos a biblioteca X que pode ser que múltiplas threads tentem
se comunicar com ele. É raro haver motivos para se fazer isso, mas é
útil se preparar só para o caso de acontecer. Essa precisa ser a
primeira coisa a ser feita antes de usar outras funções da biblioteca.

1. Abrimos uma conexão com o servidor. Se isso for bem-sucedido, o
servidor nos revela várias informações relevantes sobre a tela.

2. Obtemos da resposta dada pelo servidor qual é a tela padrão onde
devemos criar nossa janela (um computador pode ter muitos monitores e
telas diferentes).

3. Também checamos na resposta dada a resolução da tela.

4. Enviamos uma nova mensagem para o servidor pedindo que a janela
seja criada. Em princípio criaremos uma janela com o máximo de tamanho
permitido dada a resolução da tela.

Estes passos são implementados por meio das seguintes funções e
macros:

\iniciocodigo
@<X11: Criar Janela@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
/* Passo 0: */
XInitThreads();
/* Passo 1: */
display = XOpenDisplay(NULL);
if(display == NULL){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to connect to X11 server.\n");
#endif
  return false; // Não conseguiu se conectar
}
/* Passo 2: */
screen = DefaultScreen(display);
/* Passo 3: */
screen_resolution_x = DisplayWidth(display, screen);
screen_resolution_y = DisplayHeight(display, screen);
/* Passo 4: */
window = XCreateSimpleWindow(display, // Conexão com o X11
                             DefaultRootWindow(display), // Janela-mãe
                             0, 0, // Posição da janela criada
                             screen_resolution_x, // Largura
                             screen_resolution_y, // Altura
                             0, 0, // Espessura e cor da borda
                             0); // Cor padrão da janela
#endif
@
\fimcodigo

Este código assume que temos as seguintes variáveis declaradas:

\iniciocodigo
@<Variáveis Locais@>=
static int screen_resolution_x, screen_resolution_y; // Resolução da tela
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static Display *display = NULL; //Conexão com servidor e info sobre tela
static int screen;       // Identificação da tela padrão
static Window window;    // Estrutura da janela criada
#endif
@
\fimcodigo

O código que temos até agora cria a janela. Mas não a desenha na
tela. Não desenhar ela na tela automaticamente permite que nós
ajustemos atributos da janela antes que ela seja finalmente exibida.

A primeira coisa que precisaremos ajustar é que queremos que a janela
seja em tela-cheia por padrão. Faremos isso pedindo para o gerenciador
de janelas não interferir na criação da janela, colocando bordas ou
tentando limitar seu tamanho que iremos ajustar. Mas faremos isso só
se realmente formos iniciar no modo tela-cheia:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if !defined(W_WINDOW_NO_FULLSCREEN)
{
  XSetWindowAttributes attributes;
  attributes.override_redirect = true;
  XChangeWindowAttributes(display, window, CWOverrideRedirect,
                          &attributes);
}
#endif
#endif
@
\fimcodigo

Mas e se estivermos fora do modo de tela cheia e o usuário definiu
macros que dizem que o tamanho padrão da janela deve ser diferente de
ocupar a tela inteira? Neste caso, precisaremos redimencionar a janela
antes de desenhá-la na tela pela primeira vez. As macros que
controlarão o tamanho da janela quando não estamos em tela cheia
são \monoespaco{W\_WINDOW\_RESOLUTION\_X}
e \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. Se elas valerem zero ou
menos, isso significa que o tamanho deve ser igual o da resolução da
tela. Caso contrário, seu valor representará o tamanho em pixels da
janela. Mas isso só se aplica quando não estamos em tela cheia:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if defined(W_WINDOW_NO_FULLSCREEN)
{
  int size_x, size_y;
#if W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#else
  size_x = screen_resolution_x;
#endif
#if W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#else
  size_y = screen_resolution_y;
#endif
  XResizeWindow(display, window, size_x, size_y);
}
#endif
#endif
@
\fimcodigo

Vamos também fixar o tamanho da janela para o atual para impedir que
ela de alguma forma seja redimencionada:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
{
  XSizeHints hints;
  hints.flags = PMinSize | PMaxSize;
#if defined(W_WINDOW_NO_FULLSCREEN) && W_WINDOW_RESOLUTION_X > 0
  hints.min_width = hints.max_width = W_WINDOW_RESOLUTION_X;
#else
  hints.min_width = hints.max_width = screen_resolution_x;
#endif
#if defined(W_WINDOW_NO_FULLSCREEN) && W_WINDOW_RESOLUTION_Y > 0
  hints.min_height = hints.max_height = W_WINDOW_RESOLUTION_Y;
#else
  hints.min_height = hints.max_height = screen_resolution_y;
#endif
  XSetWMNormalHints(display, window, &hints);
}
#endif
@
\fimcodigo

O recurso acima requer o seguinte cabeçalho:

\iniciocodigo
@<Headers@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xutil.h>
#endif
@
\fimcodigo

Outra coisa relevante a ajustar é em que tipo de eventos nosso
programa quer prestar atenção quando estiver executando. Exemplo de
evento que não consideraremos interessante: o usuário move a janela
pela tela. Exemplo de evento interessante: o usuário pressiona um
botão enquanto nossa janela está ativa.

A lista de eventos que considerearemos importantes o bastante para que
nosso programa seja notificado é: janela é criada ou destruída,
usuário aperta ou solta botão de teclado, usuário aperta ou solta
botão do mouse e usuário move o mouse. Se não pedirmos para sermos
informados disso, nenhum evento será informado para nosso programa e
ele não saberá quando o usuário interage com ele por meio de mouse e
teclado.

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XSelectInput(display, window, StructureNotifyMask | KeyPressMask |
                              KeyReleaseMask | ButtonPressMask |
                              ButtonReleaseMask | PointerMotionMask);
#endif
@
\fimcodigo

Outra coisa importante é definir o nome da janela que será
criada. Geralmetne essa informação é apresentada de alguma forma pelo
gerenciador de janelas. Podemos deixar que o usuário escolha isso
ajustando a macro \monoespaco{W\_WINDOW\_NAME}:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XStoreName(display, window, W_WINDOW_NAME);
#endif
@
\fimcodigo

Se essta macro não estiver definida, deixamos apenas uma string vazia:

@<Define Macros@>=
#if !defined(W_WINDOW_NAME)
#define W_WINDOW_NAME ""
#endif
@
\fimcodigo

Agora vamos configurar o OpenGL ES. Como isso é suficientemente
trabalhoso, colocamos os passos de como fazer isso na próxima sessão:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
@<X11: Configurar OpenGL ES@>
#endif
@
\fimcodigo

Uma vez que tenhamos ajustado as configurações de nossa janela,
podemos enfim começar a desenhar ela. Para isso enviamos uma
requisição para o servidor X e ficamos esperando em um laço até que
recebamos o evento de que a janela foi criada (já que pedimos para
sermos avisados deste evento passando a
flag \monoespaco{StructureNotifyMask} para a
função \monoespaco{XSelectInput} anteriormente). O código para isso é:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XMapWindow(display, window);
{
  XEvent e;
  do{
    XNextEvent(display, &e);
  } while(e.type != MapNotify);
}
#endif
@
\fimcodigo

\subsecao{2.2. Configurando OpenGL ES no X11}

No X11, a interface por meio da qual programamos usando OpenGL ES se
chama EGL e suas funções e macros são declaradas no seguinte
cabeçalho:

\iniciocodigo
@<Cabeçalho OpenGL@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include <EGL/eglext.h>
#endif
@
\fimcodigo

Agora precisamos criar uma estrutura que armazena as informações sobre
nossa interface gráfica para o OpenGL ES. Assim como com o servidor X,
isso é armazenado em uma estrutura chamada \monoespaco{display}. E
podemos obter ela à partir do \monoespaco{display} da biblioteca X:

\iniciocodigo
@<X11: Configurar OpenGL ES@>+=
egl_display = eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR, display,
                                    NULL);
if(egl_display == EGL_NO_DISPLAY){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL display.\n");
#endif
  return false;
}
eglInitialize(egl_display, NULL, NULL);
@
\fimcodigo

Essa variável é declarada aqui:

\iniciocodigo
@<Variáveis Locais@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLDisplay *egl_display;
#endif
@
\fimcodigo

Agora obtemos uma configuração possível para o contexto OpenGL ES a
ser criado. Primeiro especificamos uma série de exigências e em
seguida obtemos da biblioteca uma configuração possível:

\iniciocodigo
@<X11: Configurar OpenGL ES@>+=
{
  bool ret;
  int number_of_configs_returned;
  int requested_attributes[] = {
    // Devemos suportar desenhar em janelas e em texturas:
    EGL_SURFACE_TYPE,  EGL_WINDOW_BIT | EGL_PBUFFER_BIT,
    // Devemos suportar ao menos 1 bit para a cor vermelha:
    EGL_RED_SIZE, 1,
    // Devemos suportar ao menos 1 bit para a cor verde:
    EGL_GREEN_SIZE, 1,
    // Devemos suportar ao menos 1 bit para a cor azul:
    EGL_BLUE_SIZE, 1,
    // Devemos suportar ao menos 1 bit para o canal alfa:
    EGL_ALPHA_SIZE, 1,
    // Devemos suportar ao menos 1 bit para a profundidade:
    EGL_DEPTH_SIZE, 1,
    EGL_NONE
  };
  ret = eglChooseConfig(egl_display, requested_attributes,
                        &egl_config, 1, &number_of_configs_returned);
  if(ret == EGL_FALSE){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create valid EGL config.\n");
#endif
    return false;
  }
}
@
\fimcodigo

A estrutura que armazena a configuração que usaremos é declarada aqui:

\iniciocodigo
@<Variáveis Locais@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
EGLConfig egl_config;
#endif
@
\fimcodigo


Assim como o EGL precisa de sua própria estrutura de display, ele
também precisará de uma estrutura própria para armazenar informações
sobre a janela na qual iremos desenhar. Podemos inicializar a
estrutura EGL para a janela à partir da estrutura de janela do X:

\iniciocodigo
@<X11: Configurar OpenGL ES@>+=
egl_window = eglCreateWindowSurface(egl_display, egl_config, window,
                                    NULL);
if(egl_window == EGL_NO_SURFACE){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL window.\n");
#endif
  return false;
}
@
\fimcodigo

A janela EGL é declarada aqui:

\iniciocodigo
@<Variáveis Locais@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLSurface egl_window;
#endif
@
\fimcodigo


Agora criaremos o contexto OpenGL ES. Deixaremos que o usuário escolha
qual a versão do OpenGL por meio das
macros \monoespaco{W\_WINDOW\_OPENGL\_MAJOR\_VERSION} e
\monoespaco{W\_WINDOW\_OPENGL\_MINOR\_VERSION}. Usando tal informação, o código abaixo cria o contexto:

\iniciocodigo
@<X11: Configurar OpenGL ES@>+=
{
  int context_attribs[] = {
    EGL_CONTEXT_MAJOR_VERSION, W_WINDOW_OPENGL_MAJOR_VERSION,
    EGL_CONTEXT_MINOR_VERSION, W_WINDOW_OPENGL_MINOR_VERSION,
    EGL_NONE
  };
  egl_context = eglCreateContext(egl_display, egl_config,
                                 EGL_NO_CONTEXT, context_attribs);
  if(egl_context == EGL_NO_CONTEXT){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create EGL context.\n");
#endif
    return false;
  }
  eglMakeCurrent(egl_display, egl_window, egl_window, egl_context);
}
@
\fimcodigo

O contexto OpenGL é declarado aqui:

\iniciocodigo
@<Variáveis Locais@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLContext egl_context;
#endif
@
\fimcodigo

\subsecao{2.3. Criando uma ``Janela'' em Navegador Web}

Um dos ambientes mais diferentes nos quais nossa API pode executar
será navegadores de Internet após ter o código compilado para Web
Assembly. Neste caso, não há janelas verdadeiras, o espaço no qual
poderemos desenhar na tela e teremos controle será um ``canvas'' de
HTML. Isso faz com que não tenhamos que nos preocupar com a
possibilidade do usuário tentar redimencionar a janela, por
exemplo. Mas ainda deveremos permitir ajustes no tamanho do nosso
``canvas'' além de continuarmos precisando prestar atenção no tamanho
da tela.

Aqui iremos manipular a nossa área de desenho combinando duas coisas:
a biblioteca SDL, fornecida como interface para realizar ações
gráficas pelo ambiente Emscripten e também código Javascript que
poderemos executar para ajudar.

Primeiro vamos inserir o cabeçalho do Emscripten com os cabeçalhos SDL:

\iniciocodigo
@<Cabeçalho OpenGL@>+=
#if defined(__EMSCRIPTEN__)
#include <GLES2/gl2.h>
#include <SDL/SDL.h>
#include <emscripten.h>
#endif
@
\fimcodigo

Nosso primeiro desafio neste ambiente é descobrir a resolução da
tela. Para isso, usaremos o seguinte código javascript:

\iniciocodigo
@<Web Assembly: Criar Janela@>=
#if defined(__EMSCRIPTEN__)
screen_resolution_x = EM_ASM_INT({
  return window.screen.width * window.devicePixelRatio;
});
screen_resolution_y = EM_ASM_INT({
  return window.screen.height * window.devicePixelRatio;
});
#endif
@
\fimcodigo

A próxima coisa que temos a fazer é inicializar o sub-sistema de vídeo
da biblioteca SDL. Fazer isso é simplesmente chamar a função de
inicialização:

\iniciocodigo
@<Web Assembly: Criar Janela@>+=
#if defined(__EMSCRIPTEN__)
SDL_Init(SDL_INIT_VIDEO);
#endif
@
\fimcodigo

Agora vamos efetivamente criar a janela, o que na prática ajusta o
tamanho do canvas HTML onde iremos desenhar e o inicializa. O canvas
HTML deverá ter o tamanho da tela, exceto caso o usuário tenha
definido a macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN} e tenha
definido valores positivos para \monoespaco{W\_WINDOW\_RESOLUTION\_X}
e \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. Também iremos nos certificar
de que o canvas está realmente visível, pois ele pode ter sido oculto
(é o que fazemos com ele se executarmos a função de fechar janela).

\iniciocodigo
@<Web Assembly: Criar Janela@>+=
#if defined(__EMSCRIPTEN__)
{
  int size_x, size_y, fullscreen_flag = SDL_WINDOW_FULLSCREEN;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
#if defined(W_WINDOW_NO_FULLSCREEN)
  fullscreen_flag = 0;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUtION_X > 0
  size_x = W_WINDOW_RESOLUtION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUtION_Y > 0
  size_y = W_WINDOW_RESOLUtION_Y;
#endif
#endif
  // Ajusta versão do OpenGL
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION,
                     W_WINDOW_OPENGL_MAJOR_VERSION);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION,
                     W_WINDOW_OPENGL_MINOR_VERSION);
  // Garante que o canvas estará visível
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "initial";
  );
  window = SDL_SetVideoMode(size_x, size_y, 0,
                            SDL_OPENGL | fullscreen_flag);
  if(window == NULL)
    return false;
}
#endif
@
\fimcodigo

Nossa janela neste caso é considerada uma superfície SDL:

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(__EMSCRIPTEN__)
static SDL_Surface *window;
#endif
@
\fimcodigo

\subsecao{2.4. Criando uma Janela no Windows}

Como sempre, para programar algo para o Windows precisamos inserir o
cabeçalho abaixo:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32)
#include <Windows.h>
#endif
@
\fimcodigo

Agora para obtermos a resolução do monitor principal, usamos o código
abaixo:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
screen_resolution_x = GetSystemMetrics(SM_CXSCREEN);
screen_resolution_y = GetSystemMetrics(SM_CYSCREEN);
#endif
@
\fimcodigo

A próxima coisa a fazer é definir uma classe para a janela que iremos
criar. Primeiro vamos precisar dar um nome arbitrário para ela no
formato de uma string qualquer. Iremos chamá-la de ``WeaverWindow'':

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(_WIN32)
static const char *class_name = "WeaverWindow";
#endif
@
\fimcodigo

Agora precisamos para nossa classe uma função que irá tratar todos os
sinais e mensagens enviada para nossa janela. Mensagens são enviadas e
devem ser tratadas quando a janela é criada, destruída,
redimencionada, exposta na tela, etc. Na dúvida sempre podemos
repassar cada mensagem para a função
padrão \monoespaco{DefWindowProc}, mas algumas coisas nós mesmos
teremos que definir. O formato da função que tratará as mensagens
recebidas pela janela é:

\iniciocodigo
@<Funções da API@>+=
#if defined(_WIN32)
LRESULT CALLBACK WindowProc(HWND window, UINT msg, WPARAM param1, LPARAM param2){
  switch(msg){
    @<Windows: Trata Mensagens para Janela@>
    default:
      return DefWindowProc(window, msg, param1, param2);
  }
}
#endif
@
\fimcodigo

Mas em quais casos iremos tratar as mensagens ao invés de apenas
passá-las adiante para o \monoespaco{DefWindowProc}? Um dos casos é
quando a janela receber uma mensagem para ser fechada:

\iniciocodigo
@<Windows: Trata Mensagens para Janela@>=
case WM_DESTROY:
  PostQuitMessage(0);
  return 0;
  break;
@
\fimcodigo

Agora temos que criar uma classe para a janela que iremos criar. Ela
deve apenas ter um nome único que não conflite com nomes padrão usados
pelo sistema. Também temos que passar na criação da classe um
identificador do programa que executamos (que obtemos
com \monoespaco{GetModuleHandle} e a função que irá lidar com
mensagens e sinais recebidos pela janela (no
caso, o padrão \monoespaco{DefWindowProc}).

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
if(!already_created_a_class){
  ATOM ret;
  WNDCLASS window_class;
  memset(&window_class, 0, sizeof(WNDCLASS));
  window_class.lpfnWndProc = WindowProc;
  window_class.hInstance = GetModuleHandle(NULL);
  window_class.lpszClassName = class_name;
  window_class.hbrBackground = CreateSolidBrush(RGB(0, 0, 0)); // Janela preta
  ret = RegisterClass(&window_class);
  if(ret == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to register Window Class. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  already_created_a_class = true;
}
#endif
@
\fimcodigo

Por conveniência usamos a função \monoespaco{memset} para inicializar
a estrutura da classe da janela, já que a maior parte de seus
elementos pode ser mantida como zero, que é o padrão. Por isso,
inserimos o cabeçalho abaixo:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32)
#include <string.h>
#endif
@
\fimcodigo

O código acima presume que temos declarada a seguinte variável que
armazena se nossa classe já foi criada:

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(_WIN32)
static bool already_created_a_class = false;
#endif
@
\fimcodigo

Após termos a classe da janela, criamos a janela com o código
abaixo:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
{
  int size_x, size_y;
  DWORD fullscreen_flag = WS_POPUP;
  RECT size;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
  SystemParametersInfoA(SPI_GETWORKAREA, 0, &size, 0);
#if defined(W_WINDOW_NO_FULLSCREEN)
  size_x = size.left - size.right;
  size_y = size.bottom - size.top;
  fullscreen_flag = WS_OVERLAPPED;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#endif
#endif
  window = CreateWindowEx(0, class_name,
                          W_WINDOW_NAME,
                          fullscreen_flag | WS_VISIBLE,
                          size.left, size.top, size_x, size_y,
                          NULL, NULL,
                          GetModuleHandle(NULL),
                          NULL);
  if(window == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating window. SysCode: %d\n",
            GetLastError());
#endif
    return false;
  }
}
#endif
@
\fimcodigo

Iremos armazenar o identificador da janela criada na seguinte
variável:

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(_WIN32)
static HWND window;
#endif
@
\fimcodigo

Antes de exibir a janela na tela, vamos configurar o OpenGL para
funcionar nela:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
@<Windows: Configurar OpenGL@>
#endif
@
\fimcodigo

Agora pedimos para que o sistema passe a exibir a janela e esperamos
em um laço até o sistema avisar por meio de uma mensagem que a janela
foi criada:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
{
  MSG msg;
  ShowWindow(window, SW_NORMAL);
  do{
    GetMessage(&msg, NULL, 0, 0);
  } while(msg.message == WM_CREATE);
}
#endif
@
\fimcodigo

\subsecao{2.5. Configurando OpenGL no Windows}

Para usar o OpenGL no Windows, primeiro precisamos avisamos o
compilador das bibliotecas necessárias para não precisar declará-las
durante o processo de ligação do programa e em seguida inserimos o
cabeçalho padrão e o do OpenGL:

\iniciocodigo
@<Cabeçalho OpenGL@>+=
#if defined(_WIN32)
#pragma comment(lib, "Opengl32.lib")
#pragma comment(lib, "User32.lib")
#pragma comment(lib, "Gdi32.lib")
#include <windows.h>
#include <GL/gl.h>
#endif
@
\fimcodigo

Também precisaremos de uma estrutura com informações sobre o
dispositivo em que iremos desenhar. No nosso caso, uma janela:

\iniciocodigo
@<Windows: Configurar OpenGL@>=
device_context = GetDC(window);
@
\fimcodigo

Esta estrutura é declarada aqui junto com o contexto OpenGL a ser
inicializado:

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(_WIN32)
static HGLRC wgl_context;
static HDC device_context;
#endif
@
\fimcodigo


Além disso, configurar o OpenGL no Windows é uma tarefa um bocado
trabahosa. Pra começar, a função que cria contexto OpenGL definida por
padrão, a \monoespaco{wglCreateContext} pode criar um contexto muito
primitivo, sem suporte à funções mais recentes OpenGL e não há opção
para configurá-la com muitos dos parâmetros necessários para usar
recursos mais novos. Mas existe definida na prática uma outra função
que cria contexto: \monoespaco{wglCreateContextAttribsARB}, a qual
permite que façamos coisas básicas como pedir por uma versão
específica do OpenGL com suporte à funções mais modernas e a mais
parâmetros.

O problema é que a função \monoespaco{wglCreateContextAttribsARB} não
faz parte da API padrão e é considerada uma extensão. Então, para
podermos criar um contexto OpenGL adequado, precisamos carregar esta
função primeiro. Por outro lado, para usar a função que carrega
extensões, um contexto OpenGL já deve estar criado.

A forma de resolver isso é primeiro criar um contexto OpenGL básico e
primitivo suportado pela API, depois carregar a função de criação de
contexto moderno, criar o novo contexto, associar o contexto moderno à
uma janela e carregar como extensões as funções que precisamos. Mas o
problema é que não é possível carregar mais de um contexto OpenGL por
janela. Então, para fazer isso, precisamos usar uma janela descartável
e temporária na qual criaremos o contexto temporário e descartável:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
{
@<Windows: Criar uma Janela Temporária@>
@<Windows: Criar um Contexto Temporário@>
@<Windows: Carregar Funções OpenGL Iniciais@>
@<Windows: Remover Contexto e Janela Temporários@>
}
@
\fimcodigo

Primeiro vamos criar nossa janela descartável. Como só usaremos ela
para inicializar o OpenGL, não há necesidade de criar ela seguindo
todas as especificações de nossa janela verdadeira:

\iniciocodigo
@<Windows: Criar uma Janela Temporária@>=
HWND dummy_window;
{
  WNDCLASS dummy_window_class;
  memset(&dummy_window_class, 0, sizeof(WNDCLASS));
  dummy_window_class.lpfnWndProc = WindowProc;
  dummy_window_class.hInstance = GetModuleHandle(NULL);
  dummy_window_class.lpszClassName = "DummyWindow";
  // Esta função pode falhar se a classe já está registrada. Isso ocorre
  // quando a função que cria janelas é invocada mais de uma vez. Apenas
  // ignoramos os erros ao invocar a função abaixo:
  RegisterClass(&dummy_window_class);
  SetLastError(0);
  dummy_window = CreateWindowEx(0, dummy_window_class.lpszClassName, "Dummy",
                                0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, 0, 0,
                                dummy_window_class.hInstance, 0);
  if(dummy_window == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating window. SysCode: %d\n",
            GetLastError());
#endif
    return false;
  }
}
@
\fimcodigo

Agora vamos criar o contexto OpenGL temporário. Primeiro começamos
obtendo o contexto de dispositivo e configurando o formato de pixel
dele:

\iniciocodigo
@<Windows: Criar um Contexto Temporário@>=
HGLRC dummy_context;
HDC dummy_device_context = GetDC(dummy_window);
{
  PIXELFORMATDESCRIPTOR pixel_format;
  int chosen_pixel_format;
  memset(&pixel_format, 0, sizeof(WNDCLASS));
  pixel_format.nSize = sizeof(PIXELFORMATDESCRIPTOR); // Tamanho da estrutura
  pixel_format.nVersion = 1; // Número de versão
  pixel_format.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL |
                         PFD_DOUBLEBUFFER | PFD_DRAW_TO_BITMAP;
  pixel_format.iPixelType = PFD_TYPE_RGBA;
  pixel_format.cColorBits = 24; // 24 bits para profundidade de cor
  pixel_format.cDepthBits = 32; // 32 bits para buffer de profundidade
  pixel_format.iLayerType = PFD_MAIN_PLANE;
  chosen_pixel_format = ChoosePixelFormat(dummy_device_context, &pixel_format);
  if(chosen_pixel_format == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to choose a pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  if(! SetPixelFormat(dummy_device_context, chosen_pixel_format, &pixel_format)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to set a pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  // ...
@
\fimcodigo

Após termos configurado o formato de pixel que queremos, podemos obter
o contexto OpenGL temporário que queríamos:

\iniciocodigo
@<Windows: Criar um Contexto Temporário@>+=
  // ...
  dummy_context = wglCreateContext(dummy_device_context);
  if(dummy_context == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating dummy OpenGL context. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  if(! wglMakeCurrent(dummy_device_context, dummy_context)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed setting dummy OpenGL context. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
}
@
\fimcodigo

Agora temos que carregar as funções que queremos. Carregar uma função
existente, mas que não está declarada e acessível por ser considerada
uma extensão, é feito pela função definida abaixo que usa
\monoespaco{wglGetProcAddress} para obter um ponteiro para a função desejada:

\iniciocodigo
@<Funções Locais@>+=
#if defined(_WIN32)
static void *load_function(const char *name){
  void *ret = wglGetProcAddress(name);
  if(ret == NULL || ret == (void *) -1 || ret == (void *) 0x1 ||
     ret == (void *) 0x2 || ret == (void *) 0x3){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Function '%s' not supported.\n", name);
#endif
    return NULL;
  }
  return ret;
}
#endif
@
\fimcodigo

Note que como indicado pelo código acima, a
função \monoespaco{wglGetProcAddress} na prática pode indicar erro ou
falha de carregamento retornando 5 valores diferentes. Embora somente
o retorno de \monoespaco{NULL} seja realmente documentado como
correto.

As duas funções que precisamos carregar aqui é uma função com mais
recusos para escolher um formato de pixel (como o que escolhemos
antes, mas com suporte a mais parâmetros) e uma funcção para criar um
contexto OpenGL (como o que foi criado, mas também com mais recursos).

Para carregar novas funções, primeiro precisamos declarar ponteiros
com a posição de memória onde a nova função carregada será
armazenada. No caso das duas novas funções que queremos, declaramos o
ponteiro delas no cabeçalho \monoespaco{window.h} com o código abaixo:

\iniciocodigo
@<Declarações de Janela@>+=
#if defined(_WIN32)
extern BOOL (__stdcall *wglChoosePixelFormatARB)(HDC, const int *, const FLOAT *,
                                                 UINT, int *, UINT *);
extern HGLRC (*wglCreateContextAttribsARB)(HDC, HGLRC, const int *);
#endif
@
\fimcodigo

Também colocamos a declaração real no arquivo \monoespaco{window.c}:

\iniciocodigo
@<Variáveis Globais@>=
#if defined(_WIN32)
BOOL (__stdcall *wglChoosePixelFormatARB)(HDC, const int *, const FLOAT *, UINT,
                                          int *, UINT *);
HGLRC (*wglCreateContextAttribsARB)(HDC, HGLRC, const int *);
#endif
@
\fimcodigo

Uma vez que tenhamos a declaração dos ponteiros, podemos
inicializá-los carregando para eles as funções nas quais estamos
interessados:

\iniciocodigo
@<Windows: Carregar Funções OpenGL Iniciais@>+=
wglChoosePixelFormatARB = (BOOL (__stdcall *)(HDC, const int *, const FLOAT *,
                                              UINT, int *, UINT *))
                          load_function("wglChoosePixelFormatARB");
if(wglChoosePixelFormatARB == NULL) return false;
wglCreateContextAttribsARB = (HGLRC (*)(HDC, HGLRC, const int *))
                               load_function("wglCreateContextAttribsARB");
if(wglCreateContextAttribsARB == NULL) return false;
@
\fimcodigo

E finalmente, após termos carregado as duas funções acima, não temos
mais nenhuma necessidade da janela e do contexto temporários:

\iniciocodigo
@<Windows: Remover Contexto e Janela Temporários@>=
wglMakeCurrent(dummy_device_context, 0);
wglDeleteContext(dummy_context);
ReleaseDC(dummy_window, dummy_device_context);
DestroyWindow(dummy_window);
@
\fimcodigo

Agora estamos prontos para escolher o formato de pixel (a configuração
do OpenGL) da forma moderna com nossa nova função:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
{
  PIXELFORMATDESCRIPTOR pixel_format_descriptor;
  const int pixel_format_attributes[] = {
    WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
    WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
    WGL_DOUBLE_BUFFER_ARB, GL_TRUE,
    WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,
    WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
    WGL_COLOR_BITS_ARB, 32,
    WGL_DEPTH_BITS_ARB, 24,
    WGL_STENCIL_BITS_ARB, 8,
    0 };
  int pixel_format_index = 0;
  UINT number_of_formats = 0;
  if(!wglChoosePixelFormatARB(device_context, pixel_format_attributes, NULL, 1,
                              &pixel_format_index,
                              (UINT *) (&number_of_formats))){
#if defined(W_DEBUG_WINDOW)
     fprintf(stderr, "ERROR: 'wglChoosePixelFormatARB' failed.\n");
#endif
     return false;
  }
  if(number_of_formats == 0){
#if defined(W_DEBUG_WINDOW)
     fprintf(stderr,
             "ERROR: no pixel format returned by 'wglChoosePixelFormatARB'.\n");
#endif
     return false;
  }
  DescribePixelFormat(device_context, pixel_format_index,
                      sizeof(pixel_format_descriptor), &pixel_format_descriptor);
  if(!SetPixelFormat(device_context, pixel_format_index,
                     &pixel_format_descriptor)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'SetPixelFormat' failed.\n");
#endif
    return false;
  }
}
@
\fimcodigo

Agora vamos especificar que queremos criar um contexto OpenGL cuja
versão do OpenGL é definida pelas macros que usamos para escolher a
versão. E em seguida usamos nossa função de criação de contexto
moderno:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
{
  const int opengl_attributes[] = {
    WGL_CONTEXT_MAJOR_VERSION_ARB, W_WINDOW_OPENGL_MAJOR_VERSION,
    WGL_CONTEXT_MINOR_VERSION_ARB, W_WINDOW_OPENGL_MINOR_VERSION,
    WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,
    0 };
  wgl_context = wglCreateContextAttribsARB(device_context, 0, opengl_attributes);
  if(wgl_context == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'wglCreateContextAttribsARB' failed.\n");
#endif
    return false;
  }
  if(!wglMakeCurrent(device_context, wgl_context)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'wglMakeCurrent' failed.\n");
#endif
    return false;
  }
}
@
\fimcodigo

Durante a criação de nosso contexto OpenGL verdadeiro, fizemos uso de
uma série de macros que por padrão não estão definidas. Como o uso
delas é local, declaramos elas no cabeçalho do \monoespaco{window.c}:

\iniciocodigo
@<Cabeçalhos@>+=
#define WGL_TYPE_RGBA_ARB                      0x202B
#define WGL_PIXEL_TYPE_ARB                     0x2013
#define WGL_COLOR_BITS_ARB                     0x2014
#define WGL_DEPTH_BITS_ARB                     0x2022
#define WGL_STENCIL_BITS_ARB                   0x2023
#define WGL_ACCELERATION_ARB                   0x2003
#define WGL_DOUBLE_BUFFER_ARB                  0x2011
#define WGL_CONTEXT_FLAGS_ARB                  0x2094
#define WGL_DRAW_TO_WINDOW_ARB                 0x2001
#define WGL_SUPPORT_OPENGL_ARB                 0x2010
#define WGL_FULL_ACCELERATION_ARB              0x2027
#define WGL_CONTEXT_MAJOR_VERSION_ARB          0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB          0x2092
#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x0002
@
\fimcodigo

Mas queremos suportar com nossa API as funções presentes no OpenGL ES
2.0. E tais funções também não fazem parte da API padrão oferecida
pelo WGL no Windows. O que faremos então é carregar tais funções como
extensões. Por exemplo, começando com as funções relacionadas à
criação e gerenciamento de shaders, vamos declarar seus ponteiros:

\iniciocodigo
@<Declarações de Janela@>+=
#if defined(_WIN32)
extern GLuint (__stdcall *glCreateShader)(GLenum shaderType);
extern void (__stdcall *glShaderSource)(GLuint, GLsizei, const GLchar *const*,
                                        const GLint *);
extern void (__stdcall *glCompileShader)(GLuint);
extern void (__stdcall *glReleaseShaderCompiler)(void);
extern void (__stdcall *glDeleteShader)(GLuint);
#endif
@
\fimcodigo

Em seguida posicionamos os ponteiros como variáveis globais em nosso
arquivo \monoespaco{window.c}:

\iniciocodigo
@<Variáveis Globais@>=
#if defined(_WIN32)
GLuint (__stdcall *glCreateShader)(GLenum shaderType);
void (__stdcall *glShaderSource)(GLuint, GLsizei, const GLchar *const*,
                                 const GLint *);
void (__stdcall *glCompileShader)(GLuint);
void (__stdcall *glReleaseShaderCompiler)(void);
void (__stdcall *glDeleteShader)(GLuint);
#endif
@
\fimcodigo

Em seguida carregamos para cada um dos ponteiros a função
correspondente usando a função definida um pouco acima de nossa
declaração de ponteiros:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
glCreateShader = (GLuint (__stdcall *)(GLenum)) load_function("glCreateShader");
if(glCreateShader == NULL)
  return false;
glShaderSource = (void (__stdcall *)(GLuint, GLsizei, const GLchar *const*,
                                     const GLint *))
                 load_function("glShaderSource");
if(glShaderSource == NULL)
  return false;
glCompileShader = (void (__stdcall *)(GLuint)) load_function("glCompileShader");
if(glCompileShader == NULL)
  return false;
glReleaseShaderCompiler = (void (__stdcall *)(void))
                             load_function("glReleaseShaderCompiler");
if(glReleaseShaderCompiler == NULL)
  return false;
glDeleteShader = (void (__stdcall *)(GLuint)) load_function("glDeleteShader");
if(glDeleteShader == NULL)
  return false;
@
\fimcodigo

Quando usamos \monoespaco{glCreateShader}, precisamos passar uma
destas macros como argumento para escolher o tipo de shader criado:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_VERTEX_SHADER          0x8B31
#define GL_FRAGMENT_SHADER        0x8B30
#endif
@
\fimcodigo

O tipo \monoespaco{GLchar} também precisa ser criado no Windows:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
typedef char  GLchar;
#endif
@
\fimcodigo

Após compilar um shader, a ação típica desempenhada é checar se a
compilação fo bem-sucedida. Isso é feito usando funções que fazem
consultas com relação à shaders. Em particular, a
função \monoespaco{glGetShaderiv}. Declaramos abaixo o ponteiro das
funções relacionadas à consultas a shaders:

\iniciocodigo
@<Declarações de Janela@>+=
#if defined(_WIN32)
extern GLboolean (__stdcall *glIsShader)(GLuint);
extern void (__stdcall *glGetShaderiv)(GLuint, GLenum, GLint *);
extern void (__stdcall *glGetAttachedShaders)(GLuint, GLsizei, GLsizei *,
                                              GLuint *);
extern void (__stdcall *glGetShaderInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
extern void (__stdcall *glGetShaderSource)(GLuint, GLsizei, GLsizei *, GLchar *);
extern void (__stdcall *glGetShaderPrecisionFormat)(GLenum, GLenum, GLint *,
                                                    GLint *);
extern void (__stdcall *glGetVertexAttribfv)(GLuint, GLenum, GLfloat *);
extern void (__stdcall *glGetVertexAttribiv)(GLuint, GLenum, GLint *);
extern void (__stdcall *glGetVertexAttribPointerv)(GLuint, GLenum, void **);
extern void (__stdcall *glGetUniformfv)(GLuint, GLint, GLfloat *);
extern void (__stdcall *glGetUniformiv)(GLuint, GLint, GLint *);
#endif
@
\fimcodigo

E posicionamos os ponteiros aqui::

\iniciocodigo
@<Variáveis Globais@>+=
#if defined(_WIN32)
GLboolean (__stdcall *glIsShader)(GLuint);
void (__stdcall *glGetShaderiv)(GLuint, GLenum, GLint *);
void (__stdcall *glGetAttachedShaders)(GLuint, GLsizei, GLsizei *, GLuint *);
void (__stdcall *glGetShaderInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
void (__stdcall *glGetShaderSource)(GLuint, GLsizei, GLsizei *, GLchar *);
void (__stdcall *glGetShaderPrecisionFormat)(GLenum, GLenum, GLint *, GLint *);
void (__stdcall *glGetVertexAttribfv)(GLuint, GLenum, GLfloat *);
void (__stdcall *glGetVertexAttribiv)(GLuint, GLenum, GLint *);
void (__stdcall *glGetVertexAttribPointerv)(GLuint, GLenum, void **);
void (__stdcall *glGetUniformfv)(GLuint, GLint, GLfloat *);
void (__stdcall *glGetUniformiv)(GLuint, GLint, GLint *);
#endif
@
\fimcodigo

Carregamos cada uma das funções a seus respectivos ponteiros com o
código:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
glIsShader = (GLboolean (__stdcall *)(GLuint)) load_function("glIsShader");
if(glIsShader == NULL) return false;
glGetShaderiv = (void (__stdcall *)(GLuint, GLenum, GLint *))
                   load_function("glGetShaderiv");
if(glGetShaderiv == NULL) return false;
glGetAttachedShaders = (void (__stdcall *)(GLuint, GLsizei, GLsizei *, GLuint *))
                         load_function("glGetAttachedShaders");
if(glGetAttachedShaders == NULL) return false;
glGetShaderInfoLog = (void (__stdcall *)(GLuint, GLsizei, GLsizei *, GLchar *))
                         load_function("glGetShaderInfoLog");
if(glGetShaderInfoLog == NULL)  return false;
glGetShaderSource = (void (__stdcall *)(GLuint, GLsizei, GLsizei *, GLchar *))
                       load_function("glGetShaderSource");
if(glGetShaderSource == NULL) return false;
glGetShaderPrecisionFormat = (void (__stdcall *)(GLenum, GLenum, GLint *,
                                                 GLint *))
                                load_function("glGetShaderPrecisionFormat");
if(glGetShaderPrecisionFormat == NULL) return false;
glGetVertexAttribfv = (void (__stdcall *)(GLuint, GLenum, GLfloat *))
                         load_function("glGetVertexAttribfv");
if(glGetVertexAttribfv == NULL) return false;
glGetVertexAttribiv = (void (__stdcall *)(GLuint, GLenum, GLint *))
                        load_function("glGetVertexAttribiv");
if(glGetVertexAttribiv == NULL) return false;
glGetVertexAttribPointerv = (void (__stdcall *)(GLuint, GLenum, void **))
                               load_function("glGetVertexAttribPointerv");
if(glGetVertexAttribPointerv == NULL) return false;
glGetUniformfv = (void (__stdcall *)(GLuint, GLint, GLfloat *))
                     load_function("glGetUniformfv");
if(glGetUniformfv == NULL) return false;
glGetUniformiv = (void (__stdcall *)(GLuint, GLint, GLint *))
                     load_function("glGetUniformiv");
if(glGetUniformiv == NULL) return false;
@
\fimcodigo

Quando a função \monoespaco{glGetShaderiv} é usada, podemos selecionar
qual informação sobre o shader estamos consultando passando uma das
macros abaixo:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_SHADER_TYPE          0x8B4F
#define GL_DELETE_STATUS        0x8B80
#define GL_COMPILE_STATUS       0x8B81
#define GL_INFO_LOG_LENGTH      0x8B84
#define GL_SHADER_SOURCE_LENGTH 0x8B88
#endif
@
\fimcodigo

Quando a função \monoespaco{glGetShaderPrecisionFormat} é usada para
consultar a precisão de algum tipo, o tipo a ser consultado é definido
passando uma das seguintes macros:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_LOW_FLOAT    0x8DF0
#define GL_MEDIUM_FLOAT 0x8DF1
#define GL_HIGH_FLOAT   0x8DF2
#define GL_LOW_INT      0x8DF3
#define GL_MEDIUM_INT   0x8DF4
#define GL_HIGH_INT     0x8DF5
#endif
@
\fimcodigo

Quando a função \monoespaco{glGetVertexAttribfv}
ou \monoespaco{glGetVertexAttribiv} é usada para obter informações
sobre vértices, o tipo de informação desejada é informada passando
como argumento uma destas macros abaixo:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED        0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE           0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE         0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE           0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED     0x886A
#define GL_CURRENT_VERTEX_ATTRIB              0x8626
#endif
@
\fimcodigo

Já quando usamos a função \monoespaco{glGetVertexzAttribPointerv},
precisamos passar como um de seus argumentos a macro abaixo:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
#endif
@
\fimcodigo

Vamos definir também esta macro que serve para consultar qual
implementação do GLSL temos:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
#endif
@
\fimcodigo

Uma vez que criamos e compilamos shaders, geralmente é desejado criar
um programa, ligar os shaders a ele e passar a usá-lo. Para permitir
isso, vamos declarar o ponteiro para cada uma das funções responsáveis
por lidar com programas:

\iniciocodigo
@<Declarações de Janela@>+=
#if defined(_WIN32)
extern GLuint (__stdcall *glCreateProgram)(void);
extern void (__stdcall *glAttachShader)(GLuint, GLuint);
extern void (__stdcall *glDetachShader)(GLuint, GLuint);
extern void (__stdcall *glLinkProgram)(GLuint);
extern void (__stdcall *glUseProgram)(GLuint);
extern void (__stdcall *glDeleteProgram)(GLuint);
#endif
@
\fimcodigo

Após declarar, os ponteiros são efetivamente posicionados aqui:

\iniciocodigo
@<Variáveis Globais@>+=
#if defined(_WIN32)
GLuint (__stdcall *glCreateProgram)(void);
void (__stdcall *glAttachShader)(GLuint, GLuint);
void (__stdcall *glDetachShader)(GLuint, GLuint);
void (__stdcall *glLinkProgram)(GLuint);
void (__stdcall *glUseProgram)(GLuint);
void (__stdcall *glDeleteProgram)(GLuint);
#endif
@
\fimcodigo

E inicializamos os ponteiros com as funções adequadas:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
glCreateProgram = (GLuint (__stdcall *)(void)) load_function("glCreateProgram");
if(glCreateProgram == NULL) return false;
glAttachShader = (void (__stdcall *)(GLuint, GLuint))
                  load_function("glAttachShader");
if(glAttachShader == NULL) return false;
glDetachShader = (void (__stdcall *)(GLuint, GLuint))
                 load_function("glDetachShader");
if(glDetachShader == NULL) return false;
glLinkProgram = (void (__stdcall *)(GLuint)) load_function("glLinkProgram");
if(glLinkProgram == NULL) return false;
glUseProgram = (void (__stdcall *)(GLuint)) load_function("glUseProgram");
if(glUseProgram == NULL) return false;
glDeleteProgram = (void (__stdcall *)(GLuint)) load_function("glDeleteProgram");
if(glDeleteProgram == NULL) return false;
@
\fimcodigo

Terminada a geração de um programa GLSL, geralmente o usuário irá
checar se deu tudo certo na criação do programa. E para isso é
importante prepararmos as funções que fazem consultas a programas:

\iniciocodigo
@<Declarações de Janela@>+=
#if defined(_WIN32)
extern GLboolean (__stdcall *glIsProgram)(GLuint);
extern void (__stdcall *glGetProgramiv)(GLuint, GLenum, GLint *);
extern void (__stdcall *glGetProgramInfoLog)(GLuint, GLsizei, GLsizei *,
                                             GLchar *);
extern void (__stdcall *glValidadeProgram)(GLuint);
#endif
@
\fimcodigo

Posicionamos os ponteiros reais aqui:

\iniciocodigo
@<Variáveis Globais@>+=
#if defined(_WIN32)
GLboolean (__stdcall *glIsProgram)(GLuint);
void (__stdcall *glGetProgramiv)(GLuint, GLenum, GLint *);
void (__stdcall *glGetProgramInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
void (__stdcall *glValidadeProgram)(GLuint);
#endif
@
\fimcodigo

E os inicializamos com as funções reais:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
glIsProgram = (GLboolean (__stdcall *)(GLuint)) load_function("glIsProgram");
if(glIsProgram == NULL) return false;
glGetProgramiv = (void (__stdcall *)(GLuint, GLenum, GLint *))
                    load_function("glGetProgramiv");
if(glGetProgramiv == NULL) return false;
glGetProgramInfoLog = (void (__stdcall *)(GLuint, GLsizei, GLsizei *, GLchar *))
                          load_function("glGetProgramInfoLog");
if(glGetProgramInfoLog == NULL) return false;
glValidadeProgram = (void (__stdcall *)(GLuint))
                     load_function("glValidateProgram");
if(glValidadeProgram == NULL) return false;
@
\fimcodigo

Quando usamos \monoespaco{glGetProgramiv} para obter informação sobre
um programa, passamos como argumento uma destas macros a seguir para
selecionar qual informação queremos saber:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_DELETE_STATUS               0x8B80
#define GL_LINK_STATUS                 0x8B82
#define GL_VALIDATE_STATUS             0x8B83
#define GL_INFO_LOG_LENGTH             0x8B84
#define GL_ATTACHED_SHADERS            0x8B85
#define GL_ACTIVE_ATTRIBUTES           0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
#define GL_ACTIVE_UNIFORMS             0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH   0x8B87
#endif
@
\fimcodigo

Já para obter e escolher aributos de vértices dentro de um shader,
usaremos funções que serão ligadas aos seguintes ponteiros:

\iniciocodigo
@<Declarações de Janela@>+=
#if defined(_WIN32)
extern void (__stdcall *glGetActiveAttrib)(GLuint, GLuint, GLsizei, GLsizei *,
                                           GLint *, GLenum *, GLchar *);
extern GLint (__stdcall *glGetAttribLocation)(GLuint, const GLchar *);
extern void (__stdcall *glBindAttribLocation)(GLuint, GLuint, const GLchar *);
#endif
@
\fimcodigo

Que serão posicionados aqui:

\iniciocodigo
@<Variáveis Globais@>+=
#if defined(_WIN32)
void (__stdcall *glGetActiveAttrib)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                                    GLenum *, GLchar *);
GLint (__stdcall *glGetAttribLocation)(GLuint, const GLchar *);
void (__stdcall *glBindAttribLocation)(GLuint, GLuint, const GLchar *);
#endif
@
\fimcodigo

E eles são inicializados aqui:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
glGetActiveAttrib = (void (__stdcall *)(GLuint, GLuint, GLsizei, GLsizei *,
                                        GLint *, GLenum *, GLchar *))
                    load_function("glGetActiveAttrib");
if(glGetActiveAttrib == NULL) return false;
glGetAttribLocation = (GLint (__stdcall *)(GLuint, const GLchar *))
                           load_function("glGetAttribLocation");
if(glGetAttribLocation == NULL) return false;
glBindAttribLocation = (void (__stdcall *)(GLuint, GLuint, const GLchar *))
                              load_function("glBindAttribLocation");
if(glBindAttribLocation == NULL) return false;
@
\fimcodigo

O tipo de um atributo de vértice, que é retornado
por \monoespaco{glGetActiveAttrib} pode ser:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_FLOAT      0x1406
#define GL_FLOAT_VEC2 0x8B50
#define GL_FLOAT_VEC3 0x8B51
#define GL_FLOAT_VEC4 0x8B52
#define GL_FLOAT_MAT2 0x8B5A
#define GL_FLOAT_MAT3 0x8B5B
#define GL_FLOAT_MAT4 0x8B5C
#endif
@
\fimcodigo

E finalmente, as últimas funções relacionadas aos shaders são as
responsáveis por lidar com variáveis uniformes:

\iniciocodigo
@<Declarações de Janela@>+=
#if defined(_WIN32)
extern GLint (__stdcall *glGetUniformLocation)(GLuint, const GLchar *);
extern void (__stdcall *glGetActiveUniform)(GLuint, GLuint, GLsizei, GLsizei *,
                                            GLint *, GLenum *, GLchar *);
extern void (__stdcall *glUniform1f)(GLint, GLfloat);
extern void (__stdcall *glUniform2f)(GLint, GLfloat, GLfloat);
extern void (__stdcall *glUniform3f)(GLint, GLfloat, GLfloat, GLfloat);
extern void (__stdcall *glUniform4f)(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
extern void (__stdcall *glUniform1i)(GLint, GLint);
extern void (__stdcall *glUniform2i)(GLint, GLint, GLint);
extern void (__stdcall *glUniform3i)(GLint, GLint, GLint, GLint);
extern void (__stdcall *glUniform4i)(GLint, GLint, GLint, GLint, GLint);
extern void (__stdcall *glUniform1fv)(GLint, GLsizei, const GLfloat *);
extern void (__stdcall *glUniform2fv)(GLint, GLsizei, const GLfloat *);
extern void (__stdcall *glUniform3fv)(GLint, GLsizei, const GLfloat *);
extern void (__stdcall *glUniform4fv)(GLint, GLsizei, const GLfloat *);
extern void (__stdcall *glUniform1iv)(GLint, GLsizei, const GLint *);
extern void (__stdcall *glUniform2iv)(GLint, GLsizei, const GLint *);
extern void (__stdcall *glUniform3iv)(GLint, GLsizei, const GLint *);
extern void (__stdcall *glUniform4iv)(GLint, GLsizei, const GLint *);
extern void (__stdcall *glUniformMatrix2fv)(GLint, GLsizei, GLboolean,
                                            const GLfloat *);
extern void (__stdcall *glUniformMatrix3fv)(GLint, GLsizei, GLboolean,
                                            const GLfloat *);
extern void (__stdcall *glUniformMatrix4fv)(GLint, GLsizei, GLboolean,
                                            const GLfloat *);
#endif
@
\fimcodigo

Estes 21 ponteiros para funções são posicionados aqui:

\iniciocodigo
@<Variáveis Globais@>+=
#if defined(_WIN32)
GLint (__stdcall *glGetUniformLocation)(GLuint, const GLchar *);
void (__stdcall *glGetActiveUniform)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                                     GLenum *, GLchar *);
void (__stdcall *glUniform1f)(GLint, GLfloat);
void (__stdcall *glUniform2f)(GLint, GLfloat, GLfloat);
void (__stdcall *glUniform3f)(GLint, GLfloat, GLfloat, GLfloat);
void (__stdcall *glUniform4f)(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
void (__stdcall *glUniform1i)(GLint, GLint);
void (__stdcall *glUniform2i)(GLint, GLint, GLint);
void (__stdcall *glUniform3i)(GLint, GLint, GLint, GLint);
void (__stdcall *glUniform4i)(GLint, GLint, GLint, GLint, GLint);
void (__stdcall *glUniform1fv)(GLint, GLsizei, const GLfloat *);
void (__stdcall *glUniform2fv)(GLint, GLsizei, const GLfloat *);
void (__stdcall *glUniform3fv)(GLint, GLsizei, const GLfloat *);
void (__stdcall *glUniform4fv)(GLint, GLsizei, const GLfloat *);
void (__stdcall *glUniform1iv)(GLint, GLsizei, const GLint *);
void (__stdcall *glUniform2iv)(GLint, GLsizei, const GLint *);
void (__stdcall *glUniform3iv)(GLint, GLsizei, const GLint *);
void (__stdcall *glUniform4iv)(GLint, GLsizei, const GLint *);
void (__stdcall *glUniformMatrix2fv)(GLint, GLsizei, GLboolean, const GLfloat *);
void (__stdcall *glUniformMatrix3fv)(GLint, GLsizei, GLboolean, const GLfloat *);
void (__stdcall *glUniformMatrix4fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#endif
@
\fimcodigo

E agora temos que inicializar todos estes ponteiros com suas funções:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
glGetUniformLocation = (GLint (__stdcall *)(GLuint, const GLchar *))
                            load_function("glGetUniformLocation");
if(glGetUniformLocation == NULL) return false;
glGetActiveUniform = (void (__stdcall *)(GLuint, GLuint, GLsizei, GLsizei *,
                                         GLint *, GLenum *, GLchar *))
                     load_function("glGetActiveUniform");
if(glGetActiveUniform == NULL) return false;
glUniform1f = (void (__stdcall *)(GLint, GLfloat)) load_function("glUniform1f");
if(glUniform1f == NULL) return false;
glUniform2f = (void (__stdcall *)(GLint, GLfloat, GLfloat))
               load_function("glUniform2f");
if(glUniform2f == NULL) return false;
glUniform3f = (void (__stdcall *)(GLint, GLfloat, GLfloat, GLfloat))
                        load_function("glUniform3f");
if(glUniform3f == NULL) return false;
glUniform4f = (void (__stdcall *)(GLint, GLfloat, GLfloat, GLfloat, GLfloat))
                        load_function("glUniform4f");
if(glUniform4f == NULL) return false;
glUniform1i = (void (__stdcall *)(GLint, GLint)) load_function("glUniform1i");
if(glUniform1i == NULL) return false;
glUniform2i = (void (__stdcall *)(GLint, GLint, GLint)) load_function("glUniform2i");
if(glUniform2i == NULL) return false;
glUniform3i = (void (__stdcall *)(GLint, GLint, GLint, GLint))
               load_function("glUniform3i");
if(glUniform3i == NULL) return false;
glUniform4i = (void (__stdcall *)(GLint, GLint, GLint, GLint, GLint))
                 load_function("glUniform4i");
if(glUniform4i == NULL) return false;
glUniform1fv = (void (__stdcall *)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform1fv");
if(glUniform1fv == NULL) return false;
glUniform2fv = (void (__stdcall *)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform2fv");
if(glUniform2fv == NULL) return false;
glUniform3fv = (void (__stdcall *)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform3fv");
if(glUniform3fv == NULL) return false;
glUniform4fv = (void (__stdcall *)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform4fv");
if(glUniform4fv == NULL) return false;
glUniform1iv = (void (__stdcall *)(GLint, GLsizei, const GLint *))
                 load_function("glUniform1iv");
if(glUniform1iv == NULL) return false;
glUniform2iv = (void (__stdcall *)(GLint, GLsizei, const GLint *))
                 load_function("glUniform2iv");
if(glUniform2iv == NULL) return false;
glUniform3iv = (void (__stdcall *)(GLint, GLsizei, const GLint *))
                 load_function("glUniform3iv");
if(glUniform3iv == NULL) return false;
glUniform4iv = (void (__stdcall *)(GLint, GLsizei, const GLint *))
                 load_function("glUniform4iv");
if(glUniform4iv == NULL) return false;
glUniformMatrix2fv = (void (__stdcall *)(GLint, GLsizei, GLboolean,
                                         const GLfloat *))
                      load_function("glUniformMatrix2fv");
if(glUniformMatrix2fv == NULL) return false;
glUniformMatrix3fv = (void (__stdcall *)(GLint, GLsizei, GLboolean,
                                         const GLfloat *))
                      load_function("glUniformMatrix3fv");
if(glUniformMatrix3fv == NULL) return false;
glUniformMatrix4fv = (void (__stdcall *)(GLint, GLsizei, GLboolean,
                                         const GLfloat *))
                      load_function("glUniformMatrix4fv");
if(glUniformMatrix4fv == NULL) return false;
@
\fimcodigo

As variávei uniformes podem ter o mesmo tipo que atributos de vértice,
mas podem ter também alguns destes novos tipos:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_INT         0x1404
#define GL_INT_VEC2    0x8B53
#define GL_INT_VEC3    0x8B54
#define GL_INT_VEC4    0x8B55
#define GL_BOOL        0x8B56
#define GL_BOOL_VEC2   0x8B57
#define GL_BOOL_VEC3   0x8B58
#define GL_BOOL_VEC4   0x8B59
#define GL_SAMPLER_2D  0x8B5E
#define GL_SAMPER_CUBE 0x8B60
#endif
@
\fimcodigo

A última coisa que precisamos para renderizar imagens simples é enviar
vértices para a placa de vídeo. Uma das formas de fazer isso é enviar
ponteiro para os vértices na placa de vídeo ao invés de enviá-los
diretamente para acesso mais rápido. Essa opção pode ser feita com as
funções abaixo:

\iniciocodigo
@<Declarações de Janela@>+=
#if defined(_WIN32)
extern void (__stdcall *glVertexAttrib1f)(GLuint, GLfloat);
extern void (__stdcall *glVertexAttrib2f)(GLuint, GLfloat, GLfloat);
extern void (__stdcall *glVertexAttrib3f)(GLuint, GLfloat, GLfloat, GLfloat);
extern void (__stdcall *glVertexAttrib4f)(GLuint, GLfloat, GLfloat, GLfloat,
                                          GLfloat);
extern void (__stdcall *glVertexAttrib1fv)(GLuint, GLfloat *);
extern void (__stdcall *glVertexAttrib2fv)(GLuint, GLfloat *);
extern void (__stdcall *glVertexAttrib3fv)(GLuint, GLfloat *);
extern void (__stdcall *glVertexAttrib4fv)(GLuint, GLfloat *);
extern void (__stdcall *glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean,
                                               GLsizei, const void *);
extern void (__stdcall *glEnableVertexAttribArray)(GLuint);
extern void (__stdcall *glDisableVertexAttribArray)(GLuint);
#endif
@
\fimcodigo

Posicionamos os ponteiros como variáveis globais:

\iniciocodigo
@<Variáveis Globais@>+=
#if defined(_WIN32)
void (__stdcall *glVertexAttrib1f)(GLuint, GLfloat);
void (__stdcall *glVertexAttrib2f)(GLuint, GLfloat, GLfloat);
void (__stdcall *glVertexAttrib3f)(GLuint, GLfloat, GLfloat, GLfloat);
void (__stdcall *glVertexAttrib4f)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
void (__stdcall *glVertexAttrib1fv)(GLuint, GLfloat *);
void (__stdcall *glVertexAttrib2fv)(GLuint, GLfloat *);
void (__stdcall *glVertexAttrib3fv)(GLuint, GLfloat *);
void (__stdcall *glVertexAttrib4fv)(GLuint, GLfloat *);
void (__stdcall *glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean,
                                        GLsizei, const void *);
void (__stdcall *glEnableVertexAttribArray)(GLuint);
void (__stdcall *glDisableVertexAttribArray)(GLuint);
#endif
@
\fimcodigo

E as inicializamos:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
glVertexAttrib1f = (void (__stdcall *)(GLuint, GLfloat))
                     load_function("glVertexAttrib1f");
if(glVertexAttrib1f == NULL) return false;
glVertexAttrib2f = (void (__stdcall *)(GLuint, GLfloat, GLfloat))
                      load_function("glVertexAttrib2f");
if(glVertexAttrib2f == NULL) return false;
glVertexAttrib3f = (void (__stdcall *)(GLuint, GLfloat, GLfloat, GLfloat))
                      load_function("glVertexAttrib3f");
if(glVertexAttrib3f == NULL) return false;
glVertexAttrib4f = (void (__stdcall *)(GLuint, GLfloat, GLfloat, GLfloat,
                                       GLfloat))
                      load_function("glVertexAttrib4f");
if(glVertexAttrib4f == NULL) return false;
glVertexAttrib1fv = (void (__stdcall *)(GLuint, GLfloat *))
                       load_function("glVertexAttrib1fv");
if(glVertexAttrib1fv == NULL) return false;
glVertexAttrib2fv = (void (__stdcall *)(GLuint, GLfloat *))
                       load_function("glVertexAttrib2fv");
if(glVertexAttrib2fv == NULL) return false;
glVertexAttrib3fv = (void (__stdcall *)(GLuint, GLfloat *))
                       load_function("glVertexAttrib3fv");
if(glVertexAttrib3fv == NULL) return false;
glVertexAttrib4fv = (void (__stdcall *)(GLuint, GLfloat *))
                       load_function("glVertexAttrib4fv");
if(glVertexAttrib4fv == NULL) return false;
glVertexAttribPointer = (void (__stdcall *)(GLuint, GLint, GLenum, GLboolean,
                         GLsizei, const void *))
                              load_function("glVertexAttribPointer");
if(glVertexAttribPointer == NULL) return false;
glEnableVertexAttribArray = (void (__stdcall *)(GLuint))
                              load_function("glEnableVertexAttribArray");
if(glEnableVertexAttribArray == NULL) return false;
glDisableVertexAttribArray = (void (__stdcall *)(GLuint))
                               load_function("glDisableVertexAttribArray");
if(glDisableVertexAttribArray == NULL) return false;
@
\fimcodigo

Os atributos de vétices podem ter tipos específicos. Além de tipos que
já foram definidos (\monoespaco{GL\_FLOAT}), é necessário definir
também:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define GL_FIXED          0x140C
#endif
@
\fimcodigo


\subsecao{2.6. Função de Criação de Janelas}

Nossa função de geração de nova janela então executará o código
adequado, dependendo do ambiente gráfico em que estamos. Mas antes de
fazer isso, faremos uma checagem para ver se já não temos uma janela
criada. Armazenaremos em uma variável se temos ou não uma janela já
criada.

\iniciocodigo
@<Funções da API@>=
bool _Wcreate_window(void){
  if(already_have_window == true)
    return false;
  @<X11: Criar Janela@>
  @<Web Assembly: Criar Janela@>
  @<Windows: Criar Janela@>
  already_have_window = true;
  return true;
}
@
\fimcodigo

A variável que armazena se a janela já está criada será declarada
aqui:

\iniciocodigo
@<Variáveis Locais@>+=
static bool already_have_window = false;
@
\fimcodigo

Há mais uma coisa que é preciso definir para a criação da janela e do
contexto OpenGL ligado à ela: qual versão do OpenGL iremos usar por
padrão, caso o usuário não tenha definido para um valor as macros que
usamos para tomar a decisão.

Caso estejamos rodando o X11, estamos usango o EGL para criar um
contexto OpenGL ES. Por padrão iremos pedir então para criar um
contexto OpenGL ES 3.0. Isso fará com que todas as funções e recursos
do OpenGL ES 2.0 fiquem definidos, além de mais algumas coisas novas
da versão 3.0.

Se estivermos rodando em navegador de Internet por meio de Web
Assembly, então estaremos usando WebGL. A versão equivalente ao Open
GL ES 3.0 é o WebGL 2. Enquanto o primeiro WebGL seria equivalente ao
OpenGLES 2.0. Neste caso queremos a versão 2.

Já no Windows, nós não temos garantia de que é possível criar um
contexto OpenGL ES, pois isso depende do hardware em que estamos
rodando. Sendo assim, pedimos a criação de um contexto OpenGL 4.1, já
que é a versão mais garantida de funcionar que contém em sua API as
funções mais modernas do OpenGL Es.

Sendo assim, a nossa macro que define a versão OpenGL é:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32) && !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 4
#define W_WINDOW_OPENGL_MINOR_VERSION 1
#elif defined(__EMSCRIPTEN__) && !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 2
#define W_WINDOW_OPENGL_MINOR_VERSION 0
#elif !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 3
#define W_WINDOW_OPENGL_MINOR_VERSION 0
#endif
@
\fimcodigo

\subsecao{2.7. Fechando uma Janela no X}

Fechar uma janela no X11 significa invocar a função do X que pede ao
servidor para que a janela seja fechada. E além disso, fechar a
conexão com o servidor. Isso é feito chamando
respectivamente \monoespaco{XDestroyWindow}
e \monoespaco{XCloseDisplay}. Também fazemos uma checagem para ver se
realmente existe uma janela a serfechada e destruída.

\iniciocodigo
@<Funções da API@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                 EGL_NO_CONTEXT );
  eglDestroySurface(egl_display, egl_window);
  eglDestroyContext(egl_display, egl_context);
  eglTerminate(egl_display);
  XDestroyWindow(display, window);
  XCloseDisplay(display);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.8. Fechando uma Janela em Web Assembly}

Fechar uma janela quando executando dentro de um navegador de Internet
graças ao Web Assembly significa finalizar todas as estruturas SDL e
esconder o canvas onde estávamos desenhando. Fazemos isso com a
seguinte função:

\iniciocodigo
@<Funções da API@>+=
#if defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  SDL_FreeSurface(window);
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "none";
  );
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.9. Fechando uma Janela no Windows}

Fechar a janela no Windows significa chamar uma única função que irá
encerrá-la:

\iniciocodigo
@<Funções da API@>+=
#if defined(_WIN32)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  wglMakeCurrent(NULL, NULL);
  wglDeleteContext(wgl_context);
  DestroyWindow(window);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.10. Renderizando a Janela no X} 

No X, como pedimos para o EGL criar uma janela e por padrão ele cria
uma janela com buffer duplo, para renderizarmos os comandos OpenGL
após eles terem sido feitos, devemos fazer com que o buffer traseiro,
onde estávamos desenhando, se torne o buffer dianteiro que é exibido
na tela e vice-versa:

\iniciocodigo
@<Funções da API@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wrender_window(void){
  return eglSwapBuffers(egl_display, egl_window);
}
#endif
@
\fimcodigo

\subsecao{2.11. Renderizando a Janela no Emscripten} 

O Emscripten requer nenhum comando adicional para renderizar na
tela. Por isso, na nossa função de renderizar na tela apenas
chamamos \monoespaco{glFlush} para realizar quaisquer operações que
estejam pendentes no Open GL.

\iniciocodigo
@<Funções da API@>+=
#if defined(__EMSCRIPTEN__)
bool _Wrender_window(void){
  glFlush();
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.11. Renderizando a Janela no Windows}

No Windows, a função WGL responsável por trocar os buffers da janela e
assim tornar visíveis os desenhos feitos é
chamada \monoespaco{wglSwapLayerBuffers}:

\iniciocodigo
@<Funções da API@>+=
#if defined(_WIN32)
bool _Wrender_window(void){
  return wglSwapLayerBuffers(device_context, WGL_SWAP_MAIN_PLANE);
}
#endif
@
\fimcodigo

\secao{X. Estrutura Final do Arquivo}

O arquivo com o código-fonte de todas as funções definidas neste
artigo terá a seguinte forma:

\iniciocodigo
@(src/window.c@>=
#include "window.h"
@<Cabeçalhos@>
@<Funções Locais@>
@<Variáveis Globais@>
@<Variáveis Locais@>
@<Funções da API@>
@
\fimcodigo


\fim
