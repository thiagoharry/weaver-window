\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Janela Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of a portable
  Windowing API, which can be used to create a single window in
  Windows, Linux, BSD, or a canvas in Web Assembly running in a web
  browser. You can set a fullscreen mode, change the resolution in the
  window, resize it, use OpenGL commands and get input from mouse and
  keyboard. All this can be achieved by the portable API defined in
  this work.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém a implementação de uma interface de uso de
  janelas. Ela pode ser usada para criar uma única janela no Windows,
  Linux, BSD, ou então um ``canvas'' rodando Web Assembly em um
  navegador de Internet. Você pode ativar um modo de tela cheia, mudar
  a resolução da janela, mudar o tamanho da janela, usar comandos
  OpenGL e obter entrada do mouse e teclado. Tudo isso pode ser obtido
  pela interface de aplicação portável definida neste trabalho.}

\secao{1. Introdução}

Um programa de computador gráfico precisa de um espaço no qual ele
pode desenhar na tela. Em alguns ambientes, como videogames, por
exemplo, cada programa em execução simplesmente tem controle de toda a
tela automaticamente sem que seja necessário reservá-lo ou pedi-lo
para um Sistema Operacional. Por outro lado, quando um programa
executa em um computador com algum ambiente gráfico moderno, é
necessário pedir para que uma região chamada ``janela'' seja
criada. Nela o programa passa a ter controle sobre o seu conteúdo e
pode desenhar na região.

Além de criar uma janela, é importante que tenhamos a capacidade de
entrar e sair do modo tela-cheia se estivermos em ambiente que permite
isso. E também modificar o tamanho em pixels da nossa janela. Fazer
isso em modo de tela-cheia muda a resolução da tela. Já fora da tela
cheia, o efeito é o de redimencionar a janela. Isso é importanto, pois
dependendo dos efeitos visuais usados, pode ser necessário diminuir a
quantidade de pixels desenhados por questões de performance.

\subsecao{1.1. Programação Literária e Notação}

Este artigo utiliza a técnica de ``Programação Literária'' para
desenvolver a API de gerador de números aleatórios. Esta técnica foi
apresentada em [Knuth, 1984] e tem por objetivo desenvolver
\italico{softwares} de tal forma que um programa de computador a ser compilado
é exatamente igual a um documento escrito para pessoas detalhando e
explicando o código. O presente documento não é algo independente do
código, mas sim consiste no próprio código-fonte do projeto.
Ferramentas automáticas são utilizadas para extrair o código deste
documento, colocá-lo na ordem correta e produzir o código que é
passado para o compilador.

Por exemplo, neste artigo serão definidos dois arquivos
diferentes: \monoespaco{window.c} e \monoespaco{window.h}, os quais
podem ser inseridos estaticamente em qualquer projeto, ou compilados
como uma biblioteca compartilhada. O conteúdo de \monoespaco{window.h}
é:

\iniciocodigo
@(src/window.h@>=
#ifndef WEAVER_WINDOW
#define WEAVER_WINDOW
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
@<Define Macros@>
@<Declarações de Janela@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

As duas primeiras linhas assim como a última são macros que impedem
que garantem que as funções e variáveis declaradas ali serão inseridas
no máximo uma só vez em cada unidade de compilação. Também colocamos
macros para checar se estamos compilando o código como C ou C++. Se
estivermos em C++, avisamos o compilador que estamos definindo tudo
como código C e garantimos que não vamos modificar nada usando
sobrecarga de operadores. O código poderá assim ser armazenado de
maneira mais compacta.

As partes vermelhas no código acima mostram que código será inserido
ali no futuro.

Cada trecho de código tem um título, que no caso acima
é \monoespaco{src/window.h}. O título indica onde o código será
inserido. No caso acima, o código irá para um arquivo. Em trechos de
código futuros, haverá diversos títulos, inclusive um com exatamente o
nome das partes em vermelho do código acima. Se o título de um trecho
de código é igual um trecho em vermelho a ser inserido, é ali que tal
trecho de código deve ser posicionado no processo de compilação.

Como um segundo exemplo de código, também declararemos aqui que quando
estamos em modo de depuração (ou seja, quando a
macro \monoespaco{W\_DEBUG\_WINDOW} está definida) iremos precisar das
declarações de funções de entrada e saída padrão, já que nosso código
se tornará mais verboso:

\iniciocodigo
@<Cabeçalhos@>=
#if defined(W_DEBUG_WINDOW)
#include <stdio.h>
#endif
@
\fimcodigo

Note que ainda não informamos onde exatamente o código denominado
``Cabeçalho'' será colocado. Faremos isso posteriormente.

\subsecao{1.2. Funções de API a serem Definidas}

Neste artigo iremos definir as seguintes funções:

\iniciocodigo
@<Declarações de Janela@>=
bool _Wcreate_window(void);
@
\fimcodigo

Esta é a função que irá criar uma nova janela. Por padrão, uma janela
em tela cheia. Se a macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}
estiver definida, ao invés disso, ele criará uma janela que não está
em modo de tela-cheia (se suportado pelo sistema).

Se a macro \monoespaco{W\_DEBUG\_WINDOW} estiver definida, esta função
também imprimirá na tela informação sobre o ambiente gráfico. Sua
resolução, por exemplo, ou possivelmente outras informações que possam
ser relevantes.

Em caso de erro, a função retornará falso.

\iniciocodigo
@<Declarações de Janela@>=
bool _Wdestroy_window(void);
@
\fimcodigo

Esta função vai fechar a janela aberta, liberando qualquer recurso que
tenha sido alocado pela função anterior ao criar janela. A função deve
ser invocada sempre após a janela já ter sido criada. Em caso de erro,
retorna falso.


\secao{2. Criando e Gerenciando a Janela}

\subsecao{2.1. Criando uma Janela no X}

O Sistema de Janelas X, também conhecido como X11, é um sistema de
janelas presente em muitos Sistemas Operacionais, como Linux, BSD, e
até mesmo no MacOX X, onde ele está presente para garantir
compatibilidade com programas mais antigos desenvolvidos antes de seu
sistema de janelas atual. Iremos começar com a criação de janelas no
X11 por ser o sistema de janelas mais amplamente presente.

O X11 funciona em uma arquitetura de cliente-servidor. Quando criamos
um programa gráfico, criamos um cliente que se comunica com o servidor
X usando \italico{sockets}. Todas as operações como a criação de
janelas, redimencionar a janela e mais, são feitas com o cliente
pedindo para que elas sejam feitas para o servidor, que executa os
pedidos se possível.

Iremos usar o X11 sempre que não estivermos usando o Windows (que não
o fornece) e nem estivermos compilando Web Assembly (navegadores de
Internet também não o implementam). Antes de usar o X11, precisamos
inserir seu cabeçalho relevante:

\iniciocodigo
@<Cabeçalhos@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xlib.h>
#endif
@
\fimcodigo

No X11, como temos que nos comunicar com um servidor, criamos uma
janela fazendo os seguintes passos:

0. Avisamos a biblioteca X que pode ser que múltiplas threads tentem
se comunicar com ele. É raro haver motivos para se fazer isso, mas é
útil se preparar só para o caso de acontecer. Essa precisa ser a
primeira coisa a ser feita antes de usar outras funções da biblioteca.

1. Abrimos uma conexão com o servidor. Se isso for bem-sucedido, o
servidor nos revela várias informações relevantes sobre a tela.

2. Obtemos da resposta dada pelo servidor qual é a tela padrão onde
devemos criar nossa janela (um computador pode ter muitos monitores e
telas diferentes).

3. Também checamos na resposta dada a resolução da tela.

4. Enviamos uma nova mensagem para o servidor pedindo que a janela
seja criada. Em princípio criaremos uma janela com o máximo de tamanho
permitido dada a resolução da tela.

Estes passos são implementados por meio das seguintes funções e
macros:

\iniciocodigo
@<X11: Criar Janela@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
/* Passo 0: */
XInitThreads();
/* Passo 1: */
display = XOpenDisplay(NULL);
if(display == NULL){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to connect to X11 server.\n");
#endif
  return false; // Não conseguiu se conectar
}
/* Passo 2: */
screen = DefaultScreen(display);
/* Passo 3: */
screen_resolution_x = DisplayWidth(display, screen);
screen_resolution_y = DisplayHeight(display, screen);
/* Passo 4: */
window = XCreateSimpleWindow(display, // Conexão com o X11
                             DefaultRootWindow(display), // Janela-mãe
                             0, 0, // Posição da janela criada
                             screen_resolution_x, // Largura
                             screen_resolution_y, // Altura
                             0, 0, // Espessura e cor da borda
                             0); // Cor padrão da janela
#endif
@
\fimcodigo

Este código assume que temos as seguintes variáveis declaradas:

\iniciocodigo
@<Variáveis Locais@>=
static int screen_resolution_x, screen_resolution_y; // Resolução da tela
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static Display *display = NULL; //Conexão com servidor e info sobre tela
static int screen;       // Identificação da tela padrão
static Window window;    // Estrutura da janela criada
#endif
@
\fimcodigo

O código que temos até agora cria a janela. Mas não a desenha na
tela. Não desenhar ela na tela automaticamente permite que nós
ajustemos atributos da janela antes que ela seja finalmente exibida.

A primeira coisa que precisaremos ajustar é que queremos que a janela
seja em tela-cheia por padrão. Há duas formas de fazer isso. A
primeira é pedir para que o servidor X ignore o gerenciador de janelas
e crie a nossa janela. Podemos pedir aí que ele a crie ocupando a tela
inteira. Isso sempre irá funcionar, mas como isso ignora o gerenciador
de janelas, decoração de janela como bordas e botões não irão
aparecer. Por causa disso, usaremos isso somente se o usuário definir
a macro \monoespaco{W\_WINDOW\_FORCE\_FULLSCREEN}. Neste caso o
programa nunca sairá de tela cheia e isso não será um problema:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if defined(W_WINDOW_FORCE_FULLSCREEN)
{
  XSetWindowAttributes attributes;
  attributes.override_redirect = true;
  XChangeWindowAttributes(display, window, CWOverrideRedirect,
                          &attributes);
}
#endif
#endif
@
\fimcodigo

Mas caso o usuário não tenha criado esta macro, iremos obter o efeito
pedindo para o gerenciador de janelas. Alguns gerenciadores de janela
mais antigos ou simples podem não entender o pedido ou ignorá-lo. Mas
isso deve funcionar nos principais gerenciadores de janela usados. Mas
só entraremos de fato no modo tela-cheia se o usuário não ajustou a
macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}, que significa que por
padrão devemos criar a janela sem ser em tela cheia:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if !defined(W_WINDOW_NO_FULLSCREEN)
{
  Atom atoms[2] = { XInternAtom(display, "_NET_WM_STATE_FULLSCREEN",
                                False), None };
  XChangeProperty(display, window, XInternAtom(display, "_NET_WM_STATE",
                                               False),
                  XA_ATOM, 32, PropModeReplace, (unsigned char *) atoms, 1);
}
#endif
#endif
@
\fimcodigo

Mas o código acima requer que usemos a extensão definida no seguinte
cabeçalho:

\iniciocodigo
@<Cabeçalhos@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xatom.h>
#endif
@
\fimcodigo

Mas e se estivermos em modo fora de tela cheia e o usuário definiu
macros que dizem que o tamanho padrão da janela deve ser diferente de
ocupar a tela inteira? Neste caso, precisaremos redimencionar a janela
antes de desenhá-la na tela pela primeira vez. As macros que
controlarão o tamanho da janela quando não estamos em tela cheia
são \monoespaco{W\_WINDOW\_RESOLUTION\_X}
e \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. Se elas valerem zero ou
menos, isso significa que o tamanho deve ser igual o da resolução da
tela. Caso contrário, seu valor representará o tamanho em pixels da
janela. Mas isso só se aplica quando não estamos em tela cheia:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if defined(W_WINDOW_NO_FULLSCREEN) && !defined(W_WINDOW_FORCE_FULLSCREEN)
{
  int size_x, size_y;
#if W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#else
  size_x = screen_resolution_x;
#endif
#if W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#else
  size_y = screen_resolution_y;
#endif
  XResizeWindow(display, window, size_x, size_y);
}
#endif
#endif
@
\fimcodigo

Também tentaremos avisar o gerenciador de janelas que ele não deve
permitir o redimencionamento da janela. Este deve ocorrer somente por
meio do uso de funções de redimencionamento que definiremos em breve:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
{
  XSizeHints hints;
  hints.flags = PMinSize | PMaxSize;
#if defined(W_WINDOW_NO_FULLSCREEN) && \
    !defined(W_WINDOW_FORCE_FULLSCREEN) && W_WINDOW_RESOLUTION_X > 0
  hints.min_width = hints.max_width = W_WINDOW_RESOLUTION_X;
#else
  hints.min_width = hints.max_width = screen_resolution_x;
#endif
#if defined(W_WINDOW_NO_FULLSCREEN) && \
    !defined(W_WINDOW_FORCE_FULLSCREEN) && W_WINDOW_RESOLUTION_Y > 0
  hints.min_height = hints.max_height = W_WINDOW_RESOLUTION_Y;
#else
  hints.min_height = hints.max_height = screen_resolution_y;
#endif
  XSetWMNormalHints(display, window, &hints);
}
#endif
@
\fimcodigo

Mas o recurso acima precisa de código definido no cabeçalho abaixo:

\iniciocodigo
@<Cabeçalhos@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xutil.h>
#endif
@
\fimcodigo

Outra coisa relevante a ajustar é em que tipo de eventos nosso
programa quer prestar atenção quando estiver executando. Exemplo de
evento que não consideraremos interessante: o usuário move a janela
pela tela. Exemplo de evento interessante: o usuário pressiona um
botão enquanto nossa janela está ativa.

A lista de eventos que considerearemos importantes o bastante para que
nosso programa seja notificado é: janela é criada ou destruída,
usuário aperta ou solta botão de teclado, usuário aperta ou solta
botão do mouse e usuário move o mouse. Se não pedirmos para sermos
informados disso, nenhum evento será informado para nosso programa e
ele não saberá quando o usuário interage com ele por meio de mouse e
teclado.

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XSelectInput(display, window, StructureNotifyMask | KeyPressMask |
                              KeyReleaseMask | ButtonPressMask |
                              ButtonReleaseMask | PointerMotionMask);
#endif
@
\fimcodigo

Outra coisa importante é definir o nome da janela que será
criada. Geralmetne essa informação é apresentada de alguma forma pelo
gerenciador de janelas. Podemos deixar que o usuário escolha isso
ajustando a macro \monoespaco{W\_WINDOW\_NAME}:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XStoreName(display, window, W_WINDOW_NAME);
#endif
@
\fimcodigo

Se essta macro não estiver definida, deixamos apenas uma string vazia:

@<Define Macros@>=
#if !defined(W_WINDOW_NAME)
#define W_WINDOW_NAME ""
#endif
@
\fimcodigo

Agora vamos configurar o OpenGL ES. Como isso é suficientemente
trabalhoso, colocamos os passos de como fazer isso na próxima sessão:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
@<X11: Configurar OpenGL ES@>
#endif
@
\fimcodigo

Uma vez que tenhamos ajustado as configurações de nossa janela,
podemos enfim começar a desenhar ela. Para isso enviamos uma
requisição para o servidor X e ficamos esperando em um laço até que
recebamos o evento de que a janela foi criada (já que pedimos para
sermos avisados deste evento passando a
flag \monoespaco{StructureNotifyMask} para a
função \monoespaco{XSelectInput} anteriormente). O código para isso é:

\iniciocodigo
@<X11: Criar Janela@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XMapWindow(display, window);
{
  XEvent e;
  do{
    XNextEvent(display, &e);
  } while(e.type != MapNotify);
}
#endif
@
\fimcodigo

\subsecao{2.2. Configurando OpenGL ES no X11}

No X11, a interface por meio da qual programamos usando OpenGL ES se
chama EGL e suas funções e macros são declaradas no seguinte
cabeçalho:

\iniciocodigo
@<Cabeçalhos@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include <EGL/eglext.h>
#endif
@
\fimcodigo

Agora precisamos criar uma estrutura que armazena as informações sobre
nossa interface gráfica para o OpenGL ES. Assim como com o servidor X,
isso é armazenado em uma estrutura chamada \monoespaco{display}. E
podemos obter ela à partir do \monoespaco{display} da biblioteca X:

\iniciocodigo
@<X11: Configurar OpenGL ES@>+=
egl_display = eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR, display,
                                    NULL);
if(egl_display == EGL_NO_DISPLAY){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL display.\n");
#endif
  return false;
}
eglInitialize(egl_display, NULL, NULL);
@
\fimcodigo

Essa variável é declarada aqui:

\iniciocodigo
@<Variáveis Locais@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLDisplay *egl_display;
#endif
@
\fimcodigo

Agora obtemos uma configuração possível para o contexto OpenGL ES a
ser criado. Primeiro especificamos uma série de exigências e em
seguida obtemos da biblioteca uma configuração possível:

\iniciocodigo
@<X11: Configurar OpenGL ES@>+=
{
  bool ret;
  int number_of_configs_returned;
  int requested_attributes[] = {
    // Devemos suportar desenhar em janelas e em texturas:
    EGL_SURFACE_TYPE,  EGL_WINDOW_BIT | EGL_PBUFFER_BIT,
    // Devemos suportar ao menos 1 bit para a cor vermelha:
    EGL_RED_SIZE, 1,
    // Devemos suportar ao menos 1 bit para a cor verde:
    EGL_GREEN_SIZE, 1,
    // Devemos suportar ao menos 1 bit para a cor azul:
    EGL_BLUE_SIZE, 1,
    // Devemos suportar ao menos 1 bit para o canal alfa:
    EGL_ALPHA_SIZE, 1,
    // Devemos suportar ao menos 1 bit para a profundidade:
    EGL_DEPTH_SIZE, 1,
    EGL_NONE
  };
  ret = eglChooseConfig(egl_display, requested_attributes,
                        &egl_config, 1, &number_of_configs_returned);
  if(ret == EGL_FALSE){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create valid EGL config.\n");
#endif
    return false;
  }
}
@
\fimcodigo

A estrutura que armazena a configuração que usaremos é declarada aqui:

\iniciocodigo
@<Variáveis Locais@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
EGLConfig egl_config;
#endif
@
\fimcodigo


Assim como o EGL precisa de sua própria estrutura de display, ele
também precisará de uma estrutura própria para armazenar informações
sobre a janela na qual iremos desenhar. Podemos inicializar a
estrutura EGL para a janela à partir da estrutura de janela do X:

\iniciocodigo
@<X11: Configurar OpenGL ES@>+=
egl_window = eglCreateWindowSurface(egl_display, egl_config, window,
                                    NULL);
if(egl_window == EGL_NO_SURFACE){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL window.\n");
#endif
  return false;
}
@
\fimcodigo

A janela EGL é declarada aqui:

\iniciocodigo
@<Variáveis Locais@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLSurface egl_window;
#endif
@
\fimcodigo


Agora criaremos o contexto OpenGL ES. Deixaremos que o usuário escolha
qual a versão do OpenGL por meio das
macros \monoespaco{W\_WINDOW\_OPENGL\_MAJOR\_VERSION} e
\monoespaco{W\_WINDOW\_OPENGL\_MINOR\_VERSION}. Usando tal informação, o código abaixo cria o contexto:

\iniciocodigo
@<X11: Configurar OpenGL ES@>+=
{
  int context_attribs[] = {
    EGL_CONTEXT_MAJOR_VERSION, W_WINDOW_OPENGL_MAJOR_VERSION,
    EGL_CONTEXT_MINOR_VERSION, W_WINDOW_OPENGL_MINOR_VERSION,
    EGL_NONE
  };
  egl_context = eglCreateContext(egl_display, egl_config,
                                 EGL_NO_CONTEXT, context_attribs);
  if(egl_context == EGL_NO_CONTEXT){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create EGL context.\n");
#endif
    return false;
  }
  eglMakeCurrent(egl_display, egl_window, egl_window, egl_context);
}
@
\fimcodigo

O contexto OpenGL é declarado aqui:

\iniciocodigo
@<Variáveis Locais@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLContext egl_context;
#endif
@
\fimcodigo

E se o usuário não definiu as macros que escolhem qual a versão do
OpenGL que iremos usar, por padrão será o 3.0:

\iniciocodigo
@<Define Macros@>=
#if !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 3
#endif
#if !defined(W_WINDOW_OPENGL_MINOR_VERSION)
#define W_WINDOW_OPENGL_MINOR_VERSION 0
#endif
@
\fimcodigo


\subsecao{2.3. Criando uma ``Janela'' em Navegador Web}

Um dos ambientes mais diferentes nos quais nossa API pode executar
será navegadores de Internet após ter o código compilado para Web
Assembly. Neste caso, não há janelas verdadeiras, o espaço no qual
poderemos desenhar na tela e teremos controle será um ``canvas'' de
HTML. Isso faz com que não tenhamos que nos preocupar com a
possibilidade do usuário tentar redimencionar a janela, por
exemplo. Mas ainda deveremos permitir ajustes no tamanho do nosso
``canvas'' além de continuarmos precisando prestar atenção no tamanho
da tela.

Aqui iremos manipular a nossa área de desenho combinando duas coisas:
a biblioteca SDL, fornecida como interface para realizar ações
gráficas pelo ambiente Emscripten e também código Javascript que
poderemos executar para ajudar.

Primeiro vamos inserir o cabeçalho do Emscripten com os cabeçalhos SDL:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(__EMSCRIPTEN__)
#include <GLES2/gl2.h>
#include <SDL/SDL.h>
#include <emscripten.h>
#endif
@
\fimcodigo

Nosso primeiro desafio neste ambiente é descobrir a resolução da
tela. Para isso, usaremos o seguinte código javascript:

\iniciocodigo
@<Web Assembly: Criar Janela@>=
#if defined(__EMSCRIPTEN__)
screen_resolution_x = EM_ASM_INT({
  return window.screen.width * window.devicePixelRatio;
});
screen_resolution_y = EM_ASM_INT({
  return window.screen.height * window.devicePixelRatio;
});
#endif
@
\fimcodigo

A próxima coisa que temos a fazer é inicializar o sub-sistema de vídeo
da biblioteca SDL. Fazer isso é simplesmente chamar a função de
inicialização:

\iniciocodigo
@<Web Assembly: Criar Janela@>+=
#if defined(__EMSCRIPTEN__)
SDL_Init(SDL_INIT_VIDEO);
#endif
@
\fimcodigo

Agora vamos efetivamente criar a janela, o que na prática ajusta o
tamanho do canvas HTML onde iremos desenhar e o inicializa. O canvas
HTML deverá ter o tamanho da tela, exceto caso o usuário tenha
definido a macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN} e tenha
definido valores positivos para \monoespaco{W\_WINDOW\_RESOLUTION\_X}
e \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. Também iremos nos certificar
de que o canvas está realmente visível, pois ele pode ter sido oculto
(é o que fazemos com ele se executarmos a função de fechar janela).

\iniciocodigo
@<Web Assembly: Criar Janela@>+=
#if defined(__EMSCRIPTEN__)
{
  int size_x, size_y, fullscreen_flag = 0;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
#if defined(W_WINDOW_NO_FULLSCREEN) && \
    !defined(W_WINDOW_FORCE_FULLSCREEN)
  fullscreen_flag = SDL_WINDOW_FULLSCREEN;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUtION_X > 0
  size_x = W_WINDOW_RESOLUtION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUtION_Y > 0
  size_y = W_WINDOW_RESOLUtION_Y;
#endif
#endif
  // Ajusta versão do OpenGL
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION,
                     W_WINDOW_OPENGL_MAJOR_VERSION);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION,
                     W_WINDOW_OPENGL_MINOR_VERSION);
  // Garante que o canvas estará visível
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "initial";
  );
  window = SDL_SetVideoMode(size_x, size_y, 0,
                            SDL_OPENGL | fullscreen_flag);
  if(window == NULL)
    return false;
}
#endif
@
\fimcodigo

Nossa janela neste caso é considerada uma superfície SDL:

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(__EMSCRIPTEN__)
static SDL_Surface *window;
#endif
@
\fimcodigo

\subsecao{2.4. Criando uma Janela no Windows}

Como sempre, para programar algo para o Windows precisamos inserir o
cabeçalho abaixo:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32)
#include <Windows.h>
#endif
@
\fimcodigo

Agora para obtermos a resolução do monitor principal, usamos o código
abaixo:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
screen_resolution_x = GetSystemMetrics(SM_CXSCREEN);
screen_resolution_y = GetSystemMetrics(SM_CYSCREEN);
#endif
@
\fimcodigo

A próxima coisa a fazer é definir uma classe para a janela que iremos
criar. Primeiro vamos precisar dar um nome arbitrário para ela no
formato de uma string qualquer. Iremos chamá-la de ``WeaverWindow'':

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(_WIN32)
static const char *class_name = "WeaverWindow";
#endif
@
\fimcodigo

Agora precisamos para nossa classe uma função que irá tratar todos os
sinais e mensagens enviada para nossa janela. Mensagens são enviadas e
devem ser tratadas quando a janela é criada, destruída,
redimencionada, exposta na tela, etc. Na dúvida sempre podemos
repassar cada mensagem para a função
padrão \monoespaco{DefWindowProc}, mas algumas coisas nós mesmos
teremos que definir. O formato da função que tratará as mensagens
recebidas pela janela é:

\iniciocodigo
@<Funções@>+=
#if defined(_WIN32)
LRESULT CALLBACK WindowProc(HWND window, UINT msg, WPARAM param1, LPARAM param2){
  switch(msg){
    @<Windows: Trata Mensagens para Janela@>
    default:
      return DefWindowProc(window, msg, param1, param2);
  }
}
#endif
@
\fimcodigo

Mas em quais casos iremos tratar as mensagens ao invés de apenas
passá-las adiante para o \monoespaco{DefWindowProc}? Um dos casos é
quando a janela receber uma mensagem para ser fechada:

\iniciocodigo
@<Windows: Trata Mensagens para Janela@>=
case WM_DESTROY:
  PostQuitMessage(0);
  return 0;
  break;
@
\fimcodigo

Agora temos que criar uma classe para a janela que iremos criar. Ela
deve apenas ter um nome único que não conflite com nomes padrão usados
pelo sistema. Também temos que passar na criação da classe um
identificador do programa que executamos (que obtemos
com \monoespaco{GetModuleHandle} e a função que irá lidar com
mensagens e sinais recebidos pela janela (no
caso, o padrão \monoespaco{DefWindowProc}).

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
if(!already_created_a_class){
  ATOM ret;
  WNDCLASS window_class;
  memset(&window_class, 0, sizeof(WNDCLASS));
  window_class.lpfnWndProc = WindowProc;
  window_class.hInstance = GetModuleHandle(NULL);
  window_class.lpszClassName = class_name;
  window_class.hbrBackground = CreateSolidBrush(RGB(0, 0, 0)); // Janela preta
  ret = RegisterClass(&window_class);
  if(ret == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to register Window Class. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  already_created_a_class = true;
}
#endif
@
\fimcodigo

Por conveniência usamos a função \monoespaco{memset} para inicializar
a estrutura da classe da janela, já que a maior parte de seus
elementos pode ser mantida como zero, que é o padrão. Por isso,
inserimos o cabeçalho abaixo:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32)
#include <string.h>
#endif
@
\fimcodigo

O código acima presume que temos declarada a seguinte variável que
armazena se nossa classe já foi criada:

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(_WIN32)
static bool already_created_a_class = false;
#endif
@
\fimcodigo

Após termos a classe da janela, criamos a janela com o código
abaixo:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
{
  int size_x, size_y;
  DWORD fullscreen_flag = WS_POPUP;
  RECT size;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
  SystemParametersInfoA(SPI_GETWORKAREA, 0, &size, 0);
#if !defined(W_WINDOW_FORCE_FULLSCREEN) && \
    defined(W_WINDOW_NO_FULLSCREEN)
  size_x = size.left - size.right;
  size_y = size.bottom - size.top;
  fullscreen_flag = WS_OVERLAPPED;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#endif
#endif
  window = CreateWindowEx(0, class_name,
                          W_WINDOW_NAME,
                          fullscreen_flag | WS_VISIBLE,
                          size.left, size.top, size_x, size_y,
                          NULL, NULL,
                          GetModuleHandle(NULL),
                          NULL);
  if(window == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating window. SysCode: %d\n",
            GetLastError());
#endif
    return false;
  }
}
#endif
@
\fimcodigo

Iremos armazenar o identificador da janela criada na seguinte
variável:

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(_WIN32)
static HWND window;
#endif
@
\fimcodigo

Antes de exibir a janela na tela, vamos configurar o OpenGL para
funcionar nela:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
@<Windows: Configurar OpenGL@>
#endif
@
\fimcodigo

Agora pedimos para que o sistema passe a exibir a janela e esperamos
em um laço até o sistema avisar por meio de uma mensagem que a janela
foi criada:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
{
  MSG msg;
  ShowWindow(window, SW_NORMAL);
  do{
    GetMessage(&msg, NULL, 0, 0);
  } while(msg.message == WM_CREATE);
}
#endif
@
\fimcodigo

\subsecao{2.5. Configurando OpenGL no Windows}

Para usar o OpenGL no Windows, primeiro precisamos inserir o
cabaçalho:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32)
#include <GL/gl.h>
#endif
@
\fimcodigo

Agora precisamos obter o formato de qual a melhor forma de representar
pixels no dispositivo em que estamos rodando. Usando a configuração
recomendada na documentação, podemos definir um formato de píxel com a
seguinte estrutura:

\iniciocodigo
@<Windows: Configurar OpenGL@>=
PIXELFORMATDESCRIPTOR pixel_format;
memset(&pixel_format, 0, sizeof(WNDCLASS));
pixel_format.nSize = sizeof(PIXELFORMATDESCRIPTOR); // Tamanho da estrutura
pixel_format.nVersion = 1; // Número de versão
pixel_format.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL |
                       PFD_DOUBLEBUFFER | PFD_DRAW_TO_BITMAP;
pixel_format.iPixelType = PFD_TYPE_RGBA;
pixel_format.cColorBits = 24; // 24 bits para profundidade de cor
pixel_format.cColorBits.cDepthBits = 32; // 32 bits para buffer de profundidade
pixel_format.iLayerType = PFD_MAIN_PLANE;
@
\fimcodigo

Quando configuramos o EGL, pudemos pedir só 1 bit para cada canal de
cor, sabendo que esse é apenas o valor mínimo, mas que o sistema
escolhe uma configuração acima do mínimo. Aqui as coisas são um pouco
diferentes. O que especificamos acima não é a configuração mínima, mas
uma configuração recomendada. É possível que após ajustarmos este como
o nosso formato de pixel, na prática cada bit de cor e para o buffer
de profundidade sejam menores do que o que está listado acima.

Para aplicar essa configuração de formato de pixel, nós precisamos
obter um contexto para um dispositivo onde iremos renderizar. No caso,
a janela que criamos. Obtemos um dispositivo com \monoespaco{GetDC} e
o configuramos com \monoespaco{ChoosePixelFormat} (que busca obter a
melhor configuração possível dada nossa especificação)
e \monoespaco{SetPixelFormat} (que aplica a configuração obtida).

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
HDC device_context = GetDC(window);
{
  int real_pixel_format;
  if(device_context == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to get device context. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  real_pixel_format = ChoosePixelFormat(device_context, &pixel_format);
  if(real_pixel_format == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to choose a pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  if(!SetPixelFormat(device_context, real_pixel_format, &pixel_format)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to set the pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
}
@
\fimcodigo

Terminada a configuração, criaremos o contexto OpenGL e tornaremos ele
atual:

\iniciocodigo
@<Windows: Configurar OpenGL@>+=
wgl_context = wglCreateContext(device_context);
if(wgl_context == NULL){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to set the pixel format. SysError: %d\n",
          GetLastError());
#endif
  return false;
}
if(!wglMakeCurrent(device_context, wgl_context)){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to set the pixel format. SysError: %d\n",
          GetLastError());
#endif
  return false;
}
@
\fimcodigo

Mas para isso precisamos ter declarada a variável de contexto WGL:

\iniciocodigo
@<Variáveis Locais@>+=
#if defined(_WIN32)
static HGLRC wgl_context;
#endif
@
\fimcodigo


\subsecao{2.6. Função de Criação de Janelas}

Nossa função de geração de nova janela então executará o código
adequado, dependendo do ambiente gráfico em que estamos. Mas antes de
fazer isso, faremos uma checagem para ver se já não temos uma janela
criada. Armazenaremos em uma variável se temos ou não uma janela já
criada.

\iniciocodigo
@<Funções@>=
bool _Wcreate_window(void){
  if(already_have_window == true)
    return false;
  @<X11: Criar Janela@>
  @<Web Assembly: Criar Janela@>
  @<Windows: Criar Janela@>
  already_have_window = true;
  return true;
}
@
\fimcodigo

A variável que armazena se a janela já está criada será declarada
aqui:

\iniciocodigo
@<Variáveis Locais@>+=
static bool already_have_window = false;
@
\fimcodigo

\subsecao{2.7. Fechando uma Janela no X}

Fechar uma janela no X11 significa invocar a função do X que pede ao
servidor para que a janela seja fechada. E além disso, fechar a
conexão com o servidor. Isso é feito chamando
respectivamente \monoespaco{XDestroyWindow}
e \monoespaco{XCloseDisplay}. Também fazemos uma checagem para ver se
realmente existe uma janela a serfechada e destruída.

\iniciocodigo
@<Funções@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                 EGL_NO_CONTEXT );
  eglDestroySurface(egl_display, egl_window);
  eglDestroyContext(egl_display, egl_context);
  eglTerminate(egl_display);
  XDestroyWindow(display, window);
  XCloseDisplay(display);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.8. Fechando uma Janela em Web Assembly}

Fechar uma janela quando executando dentro de um navegador de Internet
graças ao Web Assembly significa finalizar todas as estruturas SDL e
esconder o canvas onde estávamos desenhando. Fazemos isso com a
seguinte função:

\iniciocodigo
@<Funções@>+=
#if defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  SDL_FreeSurface(window);
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "none";
  );
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.9. Fechando uma Janela no Windows}

Fechar a janela no Windows significa chamar uma única função que irá
encerrá-la:

\iniciocodigo
@<Funções@>+=
#if defined(_WIN32)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  wglMakeCurrent(NULL, NULL);
  wglDeleteContext(wgl_context);
  DestroyWindow(window);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo


\secao{X. Estrutura Final do Arquivo}

O arquivo com o código-fonte de todas as funções definidas neste
artigo terá a seguinte forma:

\iniciocodigo
@(src/window.c@>=
#include "window.h"
@<Cabeçalhos@>
@<Variáveis Locais@>
@<Funções@>
@
\fimcodigo


\fim
