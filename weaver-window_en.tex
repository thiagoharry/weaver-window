\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Windowing Interface Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of a portable
  Windowing API, which can be used to create a single window in
  Windows, Linux, BSD, or a canvas in Web Assembly running in a web
  browser. You can set a fullscreen mode, change the resolution in the
  window, resize it, use OpenGL commands and get input from mouse and
  keyboard. All this can be achieved by the portable API defined in
  this work.}

\secao{1. Introduction}

A graphical computer program needs a space where it can draw in the
screen. In some environments, lke video-games, each program always
controll the entire screen automatically, without asking for it to
some operating system. But when a computer program runs in a computer
with some modern graphical environment, usually it is necessary to ask
for the creation of some region called ``window''. There the program
have control over the content and can draw freely.

Besides creating the window, it is also important to have control if
we are in full-screen or not if we are in an environment that allows
this. And also change the size of our window in pixels. If we are in
fullscreen mode, this means changing the resolution of the
screen. Otherwise, this means changing the window size. This is
important because depending on the used visual effects, we could need
to draw less pixels in the screen for performance reasons.

\subsecao{1.1. Literary Programming and Notation}

This article uses the technique of ``Literary Programming'' to develop
our random number generator API. This technique was presented at
[Knuth, 1984] and have as objective develop software in a way that a
computer program to be compiled is exactly equal a document written
for human beings detailing and explaining the code. This document is
not independent of the source code, it is the project source
code. Automated tools are used to extract the code from this document,
sort it in the right order and produce the code that is passed to a
compiler.

For example, in this article we will define two different
files: \monoespaco{window.c} and \monoespaco{window.h}. Both of them
can be inserted statically in any project or compiled as a shared
library. The content of \monoespaco{window.h} is:

\iniciocodigo
@(src/window.h@>=
#ifndef WEAVER_WINDOW
#define WEAVER_WINDOW
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define type 'bool'
@<Macro Definition@>
@<Window Declarations@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The two first lines and the last one are macros that ensure that the
function declaration and variables from this file will always be
included at most once in a compiling unit. We also put macros to check
if we are compiling this as C or C++. If we are in C++, we assure the
compiler that all our functions will be in C-style. We never will
modify them with operator overload, for example. This makes the code
became more compact.

The red parts in the above code shows that some code will be inserted
there in the future. In ``RNG Declarations'', for example, we will put
there function declarations.

Each piece of code have a title, that in the above example is
\monoespaco{src/window.h}. The title shows where the code will be placed.
In the case above, the code will directly to a file. In future pieces
of code, we will have different titles, including titles matching
exactly the names present in the red code above. If a piece of code
have as title a name matching the red part in some code, then that
code is positioned exactly in that red part when compiling the code.

As a second example of code, we also will declare here that when we
are in debug mode (when the macro \monoespaco{W\_DEBUG\_WINDOW} is
declared) we will need the declaration of input/output functions, as
our code will be more verbose:

\iniciocodigo
@<Headers@>=
#if defined(W_DEBUG_WINDOW)
#include <stdio.h>
#endif
@
\fimcodigo

Notice that we still did not define where this code section called
``Headers'' will be positioned. We can do this later.

\subsecao{1.2. API functions that will be defined}

In this article we will define the following functions:

\iniciocodigo
@<Window Declarations@>=
bool _Wcreate_window(void);
@
\fimcodigo

This function will create a new window. By default, it will create a
fullscreen window. If the macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}
is defined, instead it will create a non-fullscreen window.

If the macro \monoespaco{W\_DEBUG\_WINDOW} is defined, this function
also will print in the screen information about the graphical
environment. Its resolution for example. But possibly other
information that can be relevant.

In case of error, the function will return false.

\iniciocodigo
@<Window Declarations@>=
bool _Wdestroy_window(void);
@
\fimcodigo

This function closes the window, freeing any resource allocated during
the window creation by the previous function. This function must be
invoked only after a window was created. In case of error, it returns
false.

\iniciocodigo
@<Window Declarations@>+=
bool _Wrender_window(void);
@
\fimcodigo

This function will render in the screen all pending ommands since last
rendering. It will return false in case of error. This function
probably will be called in the end of each iteration in a main loop.


\secao{2. Creating and Managing the Window}

\subsecao{2.1. Creating a Window in X}

The X Window System, also known as X11, is a windowing system present
in many Operating System, as Linux, BSD and even in MacOX, where it
exists to ensure compatibility with older programs developed before
their current windowing system. We will begin our window creation with
X11 because is the most widely present windowing system.

X11 works in a client-server architecture. When we create a graphical
program, we create a client that communicates with X server using
sockets. All operations like window creation, resizing windows and
more are made when with the client asking for them sending requests to
the server, which executes the requests if possible.

We expect to use X11 when we are not compiling programs to Windows or
to Web Assembly, as both the Windows Operating System and web browsers
do not have a X11 server. If we will use X11, we need the following
header:

\iniciocodigo
@<Headers@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xlib.h>
#endif
@
\fimcodigo

In X11, as we need to communicate with a server, we create a window
following the steps below:

0. We ask the X libraryq to be prepared for simultaneous
communications caming from multiple threads. It is not common needing
to do this, but it is a good practice to be prepared if this
happens. This must be the first thing to do, before using other
library functions.

1. We open a connection with the server. If we succeed, we get as
response a list of relevant information about the screen.

2. We read from the response which is the default screen where we
should create our window (a computer could have many different
monitors and screens).

3. We also read the screen resolution.

4. We send a new message to the server asking to create a new
window. We will do it in the default screen, The window size will be
the greatest value allowed given the screen resolution.

The above steps are implemented using the functions and macros below:

\iniciocodigo
@<X11: Create Window@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
/* Step 0: */
XInitThreads();
/* Step 1: */
display = XOpenDisplay(NULL);
if(display == NULL){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to connect to X11 server.\n");
#endif
  return false; // Couldn't connect
}
/* Step 2: */
screen = DefaultScreen(display);
/* Step 3: */
screen_resolution_x = DisplayWidth(display, screen);
screen_resolution_y = DisplayHeight(display, screen);
/* Step 4: */
window = XCreateSimpleWindow(display, // X11 connection
                             DefaultRootWindow(display),// Parent window
                             0, 0, // Window position
                             screen_resolution_x, // Width
                             screen_resolution_y, // Height
                             0, 0, // Border width and color
                             0); // Default window color
#endif
@
\fimcodigo

This code assumes that we have the following declared variables:

\iniciocodigo
@<Local Variables@>=
static int screen_resolution_x, screen_resolution_y; //Screen resolution
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static Display *display = NULL; //Connection with server and screen info
static int screen;       // Deafult screen id
static Window window;    // Created window struct
#endif
@
\fimcodigo

The code defined above creates a window, but it does not mean that the
created window is drawn in the screen. Before drawing the window in
the screen we can adjust some of its properties.

The first thing that we need to adjust is that by default the window
should be created in fullscreen mode. We do this asking to the window
manager do not interefere with the window creating decorations or
limiting its size. But we do this only if the user did not disable
fullscreen setting a macro:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if !defined(W_WINDOW_NO_FULLSCREEN)
{
  XSetWindowAttributes attributes;
  attributes.override_redirect = true;
  XChangeWindowAttributes(display, window, CWOverrideRedirect,
                          &attributes);
}
#endif
#endif
@
\fimcodigo

But what if we are running outside the fullscreen mode and the user
has defined macros that configure the window size to a different size
than occupy the whole screen? In this case, we need to resize the
window before drawing it for the first time. The macros that control
the window size when we are not in fullscreen mode
are \monoespaco{W\_WINDOW\_RESOLUTION\_X}
and \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. If they are non-positive,
then this means that we should set their values as the greatest
possible given the screen resolution. Otherwise, their values
represent the size in pixels for the window. But this is true only
outside fullscreen mode:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if defined(W_WINDOW_NO_FULLSCREEN)
{
  int size_x, size_y;
#if W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#else
  size_x = screen_resolution_x;
#endif
#if W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#else
  size_y = screen_resolution_y;
#endif
  XResizeWindow(display, window, size_x, size_y);
}
#endif
#endif
@
\fimcodigo

We also will warn the window manager to not allow window resizing. The
window should be resized only using resizing functions that we will
soon define:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
{
  XSizeHints hints;
  hints.flags = PMinSize | PMaxSize;
#if defined(W_WINDOW_NO_FULLSCREEN) && W_WINDOW_RESOLUTION_X > 0
  hints.min_width = hints.max_width = W_WINDOW_RESOLUTION_X;
#else
  hints.min_width = hints.max_width = screen_resolution_x;
#endif
#if defined(W_WINDOW_NO_FULLSCREEN) && W_WINDOW_RESOLUTION_Y > 0
  hints.min_height = hints.max_height = W_WINDOW_RESOLUTION_Y;
#else
  hints.min_height = hints.max_height = screen_resolution_y;
#endif
  XSetWMNormalHints(display, window, &hints);
}
#endif
@
\fimcodigo

The above resource needs the following header:

\iniciocodigo
@<Headers@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xutil.h>
#endif
@
\fimcodigo

Another relevant information to adjust is what kind of events is
relevant to pass to the program when something happen to the
window. For example, we do not consider relevant if the user interacts
with another window making our window lose focus. But other events,
like the information that the user pressed a key is relevant and our
program should be informed.

The list of events that we consider relevant is: the window is created
or destroyed, the user presses or releases a mouse button, presses or
releases a key in keyboard and if the user moves the mouse pointer. If
we do not ask the server to send this information, our program would
not be able to know if the user interacts with it pressing keys.

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XSelectInput(display, window, StructureNotifyMask | KeyPressMask |
                              KeyReleaseMask | ButtonPressMask |
                              ButtonReleaseMask | PointerMotionMask);
#endif
@
\fimcodigo

Another important thing is choose the name for our window. Usually
this name is presented by the window manager. We let the user choose
the name setting the macro \monoespaco{W\_WINDOW\_NAME}:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XStoreName(display, window, W_WINDOW_NAME);
#endif
@
\fimcodigo

If this macro is not defined, we use an empty string:

@<Macro Definition@>+=
#if !defined(W_WINDOW_NAME)
#define W_WINDOW_NAME ""
#endif
@
\fimcodigo

Now we configure OpenGL ES. As this is sufficiently laborious, we
write the necessary steps in the next session:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
@<X11: Configure OpenGL ES@>
#endif
@
\fimcodigo

After adjusting all the configurations, we can draw the created
window. For this, we send a request to the server X and wait in a loop
until we are notified that the window was created (we asked to be
notified of this event when we passed
flag \monoespaco{StructureNotifyMask} to
function \monoespaco{XSelectInput} previously). The code for this is:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XMapWindow(display, window);
{
  XEvent e;
  do{
    XNextEvent(display, &e);
  } while(e.type != MapNotify);
}
#endif
@
\fimcodigo

\subsecao{2.2. Configuring OpenGL ES in X11}

In X11, the interface used to program in OpenGL ES is called EGL and
its functions and macros are declared in the following header:

\iniciocodigo
@<Headers@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include <EGL/eglext.h>
#endif
@
\fimcodigo

Now we need to create a structure needed by OpenGL ES to store
information about the graphical interface: a OpenGL display. Such
display can be obtained from the X display that we already created:

\iniciocodigo
@<X11: Configure OpenGL ES@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
egl_display = eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR, display,
                                    NULL);
if(egl_display == EGL_NO_DISPLAY){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL display.\n");
#endif
  return false;
}
eglInitialize(egl_display, NULL, NULL);
#endif
@
\fimcodigo

This variable is declared here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLDisplay *egl_display;
#endif
@
\fimcodigo

Now we need to obtain a configuration to the creation of a OpenGL
context. We specify some requirements and get a configuration using
the code below:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
{
  bool ret;
  int number_of_configs_returned;
  int requested_attributes[] = {
    // We should support drawing in the screen and textures
    EGL_SURFACE_TYPE,  EGL_WINDOW_BIT | EGL_PBUFFER_BIT,
    // And at least 1 bit to the red color:
    EGL_RED_SIZE, 1,
    // At least 1 bit to the green color:
    EGL_GREEN_SIZE, 1,
    // At least 1 bit to the blue color:
    EGL_BLUE_SIZE, 1,
    // At least 1 bit to the alpha channel:
    EGL_ALPHA_SIZE, 1,
    // At least 1 bit to the depth channel:
    EGL_DEPTH_SIZE, 1,
    EGL_NONE
  };
  ret = eglChooseConfig(egl_display, requested_attributes,
                        &egl_config, 1, &number_of_configs_returned);
  if(ret == EGL_FALSE){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create valid EGL config.\n");
#endif
    return false;
  }
}
@
\fimcodigo

The struct that stores which configuration we will use is declared
here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
EGLConfig egl_config;
#endif
@
\fimcodigo


Like how EGL needs its own display struct, it also needs its own
window struct to store information about the window where it will
draw. We can initialize such structure from the window struct used by
the X library:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
egl_window = eglCreateWindowSurface(egl_display, egl_config,
                                    window, NULL);
if(egl_window == EGL_NO_SURFACE){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL window.\n");
#endif
  return false;
}
@
\fimcodigo

The EGL window is decared here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLSurface egl_window;
#endif
@
\fimcodigo


Now we can create the OpenGL context. We let the user choose which
will be the major and minor OpenGL version using
macros \monoespaco{W\_WINDOW\_OPENGL\_MAJOR\_VERSION} and
\monoespaco{W\_WINDOW\_OPENGL\_MINOR\_VERSION}. With this information, we create the context:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
{
  int context_attribs[] = {
    EGL_CONTEXT_MAJOR_VERSION, W_WINDOW_OPENGL_MAJOR_VERSION,
    EGL_CONTEXT_MINOR_VERSION, W_WINDOW_OPENGL_MINOR_VERSION,
    EGL_NONE
  };
  egl_context = eglCreateContext(egl_display, egl_config,
                                 EGL_NO_CONTEXT, context_attribs);
  if(egl_context == EGL_NO_CONTEXT){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create EGL context.\n");
#endif
    return false;
  }
  eglMakeCurrent(egl_display, egl_window, egl_window, egl_context);
}
@
\fimcodigo

The variable that stores the handle to the OpenGL context is declared
here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLContext egl_context;
#endif
@
\fimcodigo

And if the user did not define the macros that sets the OpenGL
version, by default we choose version 3.0:

\iniciocodigo
@<Macro Definition@>=
#if !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 3
#endif
#if !defined(W_WINDOW_OPENGL_MINOR_VERSION)
#define W_WINDOW_OPENGL_MINOR_VERSION 0
#endif
@
\fimcodigo


\subsecao{2.3. Creating a ``Window'' in a Web Browser}

One of the most different environments where our API can be executed
are web browsers after the code is compiled to Web Assembly. In this
case, there are no true window, the space where we can draw in the
screen is a HTML canvas. We do not need to worry about the possibility
of the user resize the window, for example. But we still need to pay
attention to the size of the screen and should allow the resizing of
our canvas.

Here we can create and manipulare the drawing area combining two
things: the SDL library, presented as an interface to graphical
actions by Emscripten environment and Javascript code that we also can
execute.

First we include the Emscripten and SDL headers:

\iniciocodigo
@<Headers@>+=
#if defined(__EMSCRIPTEN__)
#include <GLES2/gl2.h>
#include <SDL/SDL.h>
#include <emscripten.h>
#endif
@
\fimcodigo


Our first challenge in this environment is discover screen
resolution. We can do this using the following Javascript code:

\iniciocodigo
@<Web Assembly: Create Window@>=
#if defined(__EMSCRIPTEN__)
screen_resolution_x = EM_ASM_INT({
  return window.screen.width * window.devicePixelRatio;
});
screen_resolution_y = EM_ASM_INT({
  return window.screen.height * window.devicePixelRatio;
});
#endif
@
\fimcodigo

Next we want to initialize the window SDL subsystem. This is done
calling the function below:

\iniciocodigo
@<Web Assembly: Create Window@>+=
#if defined(__EMSCRIPTEN__)
SDL_Init(SDL_INIT_VIDEO);
#endif
@
\fimcodigo

Now we will create the window, which in practice means adjust the
canvas size where we will draw and initialize it. The HTML canvas
should be the screen size, except if the user defined
macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN} and defined positive
values for \monoespaco{W\_WINDOW\_RESOLUTION\_X}
and \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. We also ensure that the
canvas is visible using Javascript, as it could be hidden (we do it
when we execute the function to close the window).

\iniciocodigo
@<Web Assembly: Create Window@>+=
#if defined(__EMSCRIPTEN__)
{
  int size_x, size_y, fullscreen_flag = SDL_WINDOW_FULLSCREEN;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
#if defined(W_WINDOW_NO_FULLSCREEN)
  fullscreen_flag = 0;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUtION_X > 0
  size_x = W_WINDOW_RESOLUtION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUtION_Y > 0
  size_y = W_WINDOW_RESOLUtION_Y;
#endif
#endif
  // Ajusta versão do OpenGL
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION,
                     W_WINDOW_OPENGL_MAJOR_VERSION);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION,
                     W_WINDOW_OPENGL_MINOR_VERSION);
  // Garante que o canvas estará visível
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "initial";
  );
  window = SDL_SetVideoMode(size_x, size_y, 0,
                            SDL_OPENGL | fullscreen_flag);
  if(window == NULL)
    return false;
}
#endif
@
\fimcodigo

The window in this case is considered a SDL surface:

\iniciocodigo
@<Local Variables@>+=
#if defined(__EMSCRIPTEN__)
static SDL_Surface *window;
#endif
@
\fimcodigo

\subsecao{2.4. Creating a Windows in (Microsoft) Windows}

As always, to program in Windows we need the following header:

\iniciocodigo
@<Headers@>+=
#if defined(_WIN32)
#include <Windows.h>
#endif
@
\fimcodigo

Now we obtain the resolution of the main monitor using:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
screen_resolution_x = GetSystemMetrics(SM_CXSCREEN);
screen_resolution_y = GetSystemMetrics(SM_CYSCREEN);
#endif
@
\fimcodigo

Next we need to define a class for our window. First we need to give
it an arbitrary name in a string format. We will call it
``WeaverWindow'':

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static const char *class_name = "WeaverWindow";
#endif
@
\fimcodigo

Now our class need a function to handle signals and messages sent to
the window. Such messages are sent when the window is created,
destroyed, resized, exposed, for example. We always can redirect the
messages to function \monoespaco{DefWindowProc} to deal with them
using default actions, but for some messages it is best to define
ourselves the correct action to be taken. The function format is:

\iniciocodigo
@<Functions@>+=
#if defined(_WIN32)
LRESULT CALLBACK WindowProc(HWND window, UINT msg, WPARAM param1, LPARAM param2){
  switch(msg){
    @<Windows: Deal with Window Messages@>
    default:
      return DefWindowProc(window, msg, param1, param2);
  }
}
#endif
@
\fimcodigo

But when will we deal with the received message instead of just
passing it to \monoespaco{DefWindowProc}? One of the cases is when the
window get a message warning that it is being closed:

\iniciocodigo
@<Windows: Deal with Window Messages@>=
case WM_DESTROY:
  PostQuitMessage(0);
  return 0;
  break;
@
\fimcodigo


XXX

Now we need to create a class for our window. The class should have an
unique non-conflicting name. We also pass an identifier with the
instance of our program (that we get
with \monoespaco{GetModuleHandle}) and the function to deal with
signals and messages for the window (in our case, the
default \monoespaco{DefWindowProc}).

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
if(!already_created_a_class){
  ATOM ret;
  WNDCLASS window_class;
  memset(&window_class, 0, sizeof(WNDCLASS));
  window_class.lpfnWndProc = WindowProc;
  window_class.hInstance = GetModuleHandle(NULL);
  window_class.lpszClassName = class_name;
  window_class.hbrBackground = CreateSolidBrush(RGB(0, 0, 0)); // Black window
  ret = RegisterClass(&window_class);
  if(ret == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to register Window Class. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  already_created_a_class = true;
}
#endif
@
\fimcodigo

For convenince, we used the function \monoespaco{memset} to initialize
the struct of our window class, as the majority of its elements can be
set to zero to keep the default value. Because of this, we insert the
following header:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32)
#include <string.h>
#endif
@
\fimcodigo

The code above assumes that we have declared a boolean variable that
stores if we already created a class:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static bool already_created_a_class = false;
#endif
@
\fimcodigo

After defining the window class, we can create the window with the
code below:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
{
  int size_x, size_y;
  DWORD fullscreen_flag = WS_POPUP;
  RECT size;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
  SystemParametersInfoA(SPI_GETWORKAREA, 0, &size, 0);
#if !defined(W_WINDOW_FORCE_FULLSCREEN) && \
    defined(W_WINDOW_NO_FULLSCREEN)
  size_x = size.left - size.right;
  size_y = size.bottom - size.top;
  fullscreen_flag = WS_OVERLAPPED;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#endif
#endif
  window = CreateWindowEx(0, class_name,
                          W_WINDOW_NAME,
                          fullscreen_flag | WS_VISIBLE,
                          size.left, size.top, size_x, size_y,
                          NULL, NULL,
                          GetModuleHandle(NULL),
                          NULL);
  if(window == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating window. SysCode: %d\n",
            GetLastError());
#endif
    return false;
  }
}
#endif
@
\fimcodigo

We will store the handle to the created window in this variable:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static HWND window;
#endif
@
\fimcodigo

Before showing the window on the screen we configure OpenGL on it:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
@<Windows: Configurar OpenGL@>
#endif
@
\fimcodigo

Now we ask the system to show the window to the user and then wait in
a loop until we get a message saying that the window was created:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
{
  MSG msg;
  ShowWindow(window, SW_NORMAL);
  do{
    GetMessage(&msg, NULL, 0, 0);
  } while(msg.message == WM_CREATE);
}
#endif
@
\fimcodigo

\subsecao{2.5. Configuring OpenGL on Windows}

To use OpenGL on Windows, first we need to include the header:

\iniciocodigo
@<Headers@>+=
#if defined(_WIN32)
#include <GL/gl.h>
#endif
@
\fimcodigo

Now we need to specify the format in which pixels will be represented
on the screen. Using the recommended configuration from the
documentation, we can set the pixel format with the following struct:

\iniciocodigo
@<Windows: Configure OpenGL@>=
PIXELFORMATDESCRIPTOR pixel_format;
memset(&pixel_format, 0, sizeof(WNDCLASS));
pixel_format.nSize = sizeof(PIXELFORMATDESCRIPTOR); // Size of the struct
pixel_format.nVersion = 1; // Version number
pixel_format.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL |
                       PFD_DOUBLEBUFFER | PFD_DRAW_TO_BITMAP;
pixel_format.iPixelType = PFD_TYPE_RGBA;
pixel_format.cColorBits = 24; // 24 bits to RGB colorss
pixel_format.cDepthBits = 32; // 32 bits to depth buffer
pixel_format.iLayerType = PFD_MAIN_PLANE;
@
\fimcodigo

When we configured EGL, we asked a single bit for each color and for
the depth channel because EGL considers this as the minimal
requirement, and in practice will return a configuration with more
bits than asked. But with WGL is different, these are not the minimal,
but the recommended requirements. In practice we could end with a
pixel format with fewer pixels than asked in the depth buffer or for
each color.

To apply this pixel configuration, first we need a device context to
the device where we will draw. In our case, a window. We get a device
context with \monoespaco{GetDC}. Next we try to get the best possible
pixel format that matches our requirements
with \monoespaco{ChoosePixelFormat} and set the configuration with
\monoespaco{SetPixelFormat}.

\iniciocodigo
@<Windows: Configure OpenGL@>+=
{
  HDC device_context = GetDC(window);
  int real_pixel_format;
  if(device_context == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to get device context. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  real_pixel_format = ChoosePixelFormat(device_context, &pixel_format);
  if(real_pixel_format == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to choose a pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  if(!SetPixelFormat(device_context, real_pixel_format, &pixel_format)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to set the pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
}
@
\fimcodigo

Finished the configuration, we create the OpenGL context and make it
current:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
wgl_context = wglCreateContext(device_context);
if(wgl_context == NULL){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to set the pixel format. SysError: %d\n",
          GetLastError());
#endif
  return false;
}
if(!wglMakeCurrent(device_context, wgl_context)){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to set the pixel format. SysError: %d\n",
          GetLastError());
#endif
  return false;
}
@
\fimcodigo

But for this we need to have declared the WGL context variable:

@<Local Variables@>+=
#if defined(_WIN32)
static HGLRC wgl_context;
#endif
@
\fimcodigo

\subsecao{2.6. Window Creation Function}

Our function that creates a new window will execute the adequate code,
depending on the graphical environment where termosit is being
executed. But before this we will add code to check if a window
already was created. This information will be stored in a boolean
variable:

\iniciocodigo
@<Functions@>=
bool _Wcreate_window(void){
  if(already_have_window == true)
    return false;
  @<X11: Create Window@>
  @<Web Assembly: Create Window@>
  @<Windows: Create Window@>
  already_have_window = true;
  return true;
}
@
\fimcodigo

The variable that stores if the window already was created will be
declared here:

\iniciocodigo
@<Local Variables@>+=
static bool already_have_window = false;
@
\fimcodigo


\subsecao{2.7. Closing a Window in X}

Closing a window in X11 means calling the function that asks the
server to close the window and also closing the connection with the
server. This is done calling respectively \monoespaco{XDestroyWindow}
and \monoespaco{XCloseDisplay}. We also check if we really have an
existing window before trying to close and destroy it.

\iniciocodigo
@<Functions@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                 EGL_NO_CONTEXT );
  eglDestroySurface(egl_display, egl_window);
  eglDestroyContext(egl_display, egl_context);
  eglTerminate(egl_display);
  XDestroyWindow(display, window);
  XCloseDisplay(display);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.8. Closing a Window in Web Assembly}

Closing a window when running in a web browser means finalize the SDL
structures and hide the canvas where we were drawing. We do this with
the following function:

\iniciocodigo
@<Functions@>+=
#if defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  SDL_FreeSurface(window);
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "none";
  );
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.9. Closing a Window on Windows}

Closing a window in Windows means calling a simple function to destroy
the window:

\iniciocodigo
@<Functions@>+=
#if defined(_WIN32)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  wglMakeCurrent(NULL, NULL);
  wglDeleteContext(wgl_context);
  DestroyWindow(window);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.10. Rendering window in X} 

In X, when we asked EGL to create a window, by default it creates a
double buffered window. Rendering in the screen means in this case to
swap the window buffers. The back buffer where we were drawing became
the front buffer, what is shown in the screen, and vice-versa. This is
achieved with the following code:

\iniciocodigo
@<Functions@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wrender_window(void){
  return eglSwapBuffers(egl_display, egl_window);
}
#endif
@
\fimcodigo

\subsecao{2.10. Rendering window in Emscripten}

It is not necessary to perform any additional operation to render the
previous Open GL commands if we are using Web Assembly compiled by
Emscripten. So we only use \monoespaco{glFlush} to wait for any
pending command to execute before resuming our code.

\iniciocodigo
@<Functions@>+=
#if defined(__EMSCRIPTEN__)
bool _Wrender_window(void){
  glFlush();
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.10. Rendering window in (Microsoft) Windows}

In Windows, the WGL function responsible for swapping buffers in the
window making our drawings visible is
called \monoespaco{wglSwapLayerBuffers}:

\iniciocodigo
@<Functions@>+=
#if defined(_WIN32)
bool _Wrender_window(void){
  return wglSwapLayerBuffers(device_context, WGL_SWAP_MAIN_PLANE);
}
#endif
@
\fimcodigo



\subsecao{X. Final File Sctructure}

The file with all the necessary source code for the functions defined
in this article will have the following organization:

\iniciocodigo
@(src/window.c@>=
#include "window.h"
@<Headers@>
@<Local Variables@>
@<Functions@>
@
\fimcodigo


\fim
