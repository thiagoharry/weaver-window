\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Windowing Interface Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of a portable
  Windowing API, which can be used to create a single window in
  Windows, Linux, BSD, or a canvas in Web Assembly running in a web
  browser. You can set a fullscreen mode, change the resolution in the
  window, resize it, use OpenGL commands and get input from mouse and
  keyboard. All this can be achieved by the portable API defined in
  this work.}

\secao{1. Introduction}

A graphical computer program needs a space where it can draw in the
screen. In some environments, lke video-games, each program always
controll the entire screen automatically, without asking for it to
some operating system. But when a computer program runs in a computer
with some modern graphical environment, usually it is necessary to ask
for the creation of some region called ``window''. There the program
have control over the content and can draw freely.

Besides creating the window, it is also important to have control if
we are in full-screen or not if we are in an environment that allows
this. And also change the size of our window in pixels. If we are in
fullscreen mode, this means changing the resolution of the
screen. Otherwise, this means changing the window size. This is
important because depending on the used visual effects, we could need
to draw less pixels in the screen for performance reasons.

\subsecao{1.1. Literary Programming and Notation}

This article uses the technique of ``Literary Programming'' to develop
our random number generator API. This technique was presented at
[Knuth, 1984] and have as objective develop software in a way that a
computer program to be compiled is exactly equal a document written
for human beings detailing and explaining the code. This document is
not independent of the source code, it is the project source
code. Automated tools are used to extract the code from this document,
sort it in the right order and produce the code that is passed to a
compiler.

For example, in this article we will define two different
files: \monoespaco{window.c} and \monoespaco{window.h}. Both of them
can be inserted statically in any project or compiled as a shared
library. The content of \monoespaco{window.h} is:

\iniciocodigo
@(src/window.h@>=
#ifndef WEAVER_WINDOW
#define WEAVER_WINDOW
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define type 'bool'
@<Macro Definition@>
@<Window Declarations@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The two first lines and the last one are macros that ensure that the
function declaration and variables from this file will always be
included at most once in a compiling unit. We also put macros to check
if we are compiling this as C or C++. If we are in C++, we assure the
compiler that all our functions will be in C-style. We never will
modify them with operator overload, for example. This makes the code
became more compact.

The red parts in the above code shows that some code will be inserted
there in the future. In ``RNG Declarations'', for example, we will put
there function declarations.

Each piece of code have a title, that in the above example is
\monoespaco{src/window.h}. The title shows where the code will be placed.
In the case above, the code will directly to a file. In future pieces
of code, we will have different titles, including titles matching
exactly the names present in the red code above. If a piece of code
have as title a name matching the red part in some code, then that
code is positioned exactly in that red part when compiling the code.

\subsecao{1.2. API functions that will be defined}

In this article we will define the following functions:

\iniciocodigo
@<Window Declarations@>=
bool _Wcreate_window(void);
@
\fimcodigo

This function will create a new window. By default, it will create a
fullscreen window. If the macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}
is defined, instead it will create a non-fullscreen window.

If the macro \monoespaco{W\_DEBUG\_WINDOW} is defined, this function
also will print in the screen information about the graphical
environment. Its resolution for example. But possibly other
information that can be relevant.

In case of error, the function will return false.

\iniciocodigo
@<Window Declarations@>=
bool _Wdestroy_window(void);
@
\fimcodigo

This function closes the window, freeing any resource allocated during
the window creation by the previous function. This function must be
invoked only after a window was created. In case of error, it returns
false.

\secao{2. Creating and Managing the Window}

\subsecao{2.1. Creating a Window in X}

The X Window System, also known as X11, is a windowing system present
in many Operating System, as Linux, BSD and even in MacOX, where it
exists to ensure compatibility with older programs developed before
their current windowing system. We will begin our window creation with
X11 because is the most widely present windowing system.

X11 works in a client-server architecture. When we create a graphical
program, we create a client that communicates with X server using
sockets. All operations like window creation, resizing windows and
more are made when with the client asking for them sending requests to
the server, which executes the requests if possible.

We expect to use X11 when we are not compiling programs to Windows or
to Web Assembly, as both the Windows Operating System and web browsers
do not have a X11 server. If we will use X11, we need the following
header:

\iniciocodigo
@<Headers@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xlib.h>
#endif
@
\fimcodigo

In X11, as we need to communicate with a server, we create a window
following the steps below:

0. We ask the X libraryq to be prepared for simultaneous
communications caming from multiple threads. It is not common needing
to do this, but it is a good practice to be prepared if this
happens. This must be the first thing to do, before using other
library functions.

1. We open a connection with the server. If we succeed, we get as
response a list of relevant information about the screen.

2. We read from the response which is the default screen where we
should create our window (a computer could have many different
monitors and screens).

3. We also read the screen resolution.

4. We send a new message to the server asking to create a new
window. We will do it in the default screen, The window size will be
the greatest value allowed given the screen resolution.

The above steps are implemented using the functions and macros below:

\iniciocodigo
@<X11: Create Window@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
/* Step 0: */
XInitThreads();
/* Step 1: */
display = XOpenDisplay(NULL);
if(display == NULL)
  return false; // Couldn't connect
/* Step 2: */
screen = DefaultScreen(display);
/* Step 3: */
screen_resolution_x = DisplayWidth(display, screen);
screen_resolution_y = DisplayHeight(display, screen);
/* Step 4: */
window = XCreateSimpleWindow(display, // X11 connection
                             DefaultRootWindow(display),// Parent window
                             0, 0, // Window position
                             screen_resolution_x, // Width
                             screen_resolution_y, // Height
                             0, 0, // Border width and color
                             0); // Default window color
#endif
@
\fimcodigo

This code assumes that we have the following declared variables:

\iniciocodigo
@<Local Variables@>=
static int screen_resolution_x, screen_resolution_y; //Screen resolution
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static Display *display = NULL; //Connection with server and screen info
static int screen;       // Deafult screen id
static Window window;    // Created window struct
#endif
@
\fimcodigo

The code defined above creates a window, but it does not mean that the
created window is drawn in the screen. Before drawing the window in
the screen we can adjust some of its properties.

The first thing that we need to adjust is that by default the window
should be created in fullscreen mode. There are two ways to do it. The
first is ask the X server to ignore the window manager and create the
window directly. We ask the window to occupy all the screen. This
always will work, but as we are ignoring the window manager, the
window decorators like borders and buttons will not appear. Because of
this we only do this if the user defines the
macro \monoespaco{W\_WINDOW\_FORCE\_FULLSCREEN}. In this case we will
never leave the fullscreen window and this will not be a problem:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if defined(W_WINDOW_FORCE_FULLSCREEN)
{
  XSetWindowAttributes attributes;
  attributes.override_redirect = true;
  XChangeWindowAttributes(display, window, CWOverrideRedirect, &attributes);
}
#endif
#endif
@
\fimcodigo

But if the user did not define this macro, we will obtain the full
screen effect askinf for the window manager. Some older or
simplerwindow managers will not understand this request or can ignore
it. But this should work in the most used window managers. But we only
enter in fullscreen mode if the user did not set the
macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}, which means that by default we should not create a fullscreen window:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if !defined(W_WINDOW_NO_FULLSCREEN)
{
  Atom atoms[2] = { XInternAtom(display, "_NET_WM_STATE_FULLSCREEN",
                                False), None };
  XChangeProperty(display, window, XInternAtom(display, "_NET_WM_STATE",
                                               False),
                  XA_ATOM, 32, PropModeReplace, (unsigned char *) atoms, 1);
}
#endif
#endif
@
\fimcodigo

The above code requires the extension defined in the following header:

\iniciocodigo
@<Headers@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xatom.h>
#endif
@
\fimcodigo

But what if we are running outside the fullscreen mode and the user
has defined macros that configure the window size to a different size
than occupy the whole screen? In this case, we need to resize the
window before drawing it for the first time. The macros that control
the window size when we are not in fullscreen mode
are \monoespaco{W\_WINDOW\_RESOLUTION\_X}
and \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. If they are non-positive,
then this means that we should set their values as the greatest
possible given the screen resolution. Otherwise, their values
represent the size in pixels for the window. But this is true only
outside fullscreen mode:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if defined(W_WINDOW_NO_FULLSCREEN) && !defined(W_WINDOW_FORCE_FULLSCREEN)
{
  int size_x, size_y;
#if W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#else
  size_x = screen_resolution_x;
#endif
#if W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#else
  size_y = screen_resolution_y;
#endif
  XResizeWindow(display, window, size_x, size_y);
}
#endif
#endif
@
\fimcodigo

We also will warn the window manager to not allow window resizing. The
window should be resized only using resizing functions that we will
soon define:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
{
  XSizeHints hints;
  hints.flags = PMinSize | PMaxSize;
#if defined(W_WINDOW_NO_FULLSCREEN) && \
    !defined(W_WINDOW_FORCE_FULLSCREEN) && W_WINDOW_RESOLUTION_X > 0
  hints.min_width = hints.max_width = W_WINDOW_RESOLUTION_X;
#else
  hints.min_width = hints.max_width = screen_resolution_x;
#endif
#if defined(W_WINDOW_NO_FULLSCREEN) && \
    !defined(W_WINDOW_FORCE_FULLSCREEN) && W_WINDOW_RESOLUTION_Y > 0
  hints.min_height = hints.max_height = W_WINDOW_RESOLUTION_Y;
#else
  hints.min_height = hints.max_height = screen_resolution_y;
#endif
  XSetWMNormalHints(display, window, &hints);
}
#endif
@
\fimcodigo

The above resource needs the following header:

\iniciocodigo
@<Headers@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xutil.h>
#endif
@
\fimcodigo

Another relevant information to adjust is what kind of events is
relevant to pass to the program when something happen to the
window. For example, we do not consider relevant if the user interacts
with another window making our window lose focus. But other events,
like the information that the user pressed a key is relevant and our
program should be informed.

The list of events that we consider relevant is: the window is created
or destroyed, the user presses or releases a mouse button, presses or
releases a key in keyboard and if the user moves the mouse pointer. If
we do not ask the server to send this information, our program would
not be able to know if the user interacts with it pressing keys.

\iniciocodigo
@<X11: Criar Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XSelectInput(display, window, StructureNotifyMask | KeyPressMask |
                              KeyReleaseMask | ButtonPressMask |
                              ButtonReleaseMask | PointerMotionMask);
#endif
@
\fimcodigo

Another important thing is choose the name for our window. Usually
this name is presented by the window manager. We let the user choose
the name setting the macro \monoespaco{W\_WINDOW\_NAME}:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XStoreName(display, window, W_WINDOW_NAME);
#endif
@
\fimcodigo

If this macro is not defined, we use an empty string:

@<Macro Definition@>+=
#if !defined(W_WINDOW_NAME)
#define W_WINDOW_NAME ""
#endif
@
\fimcodigo

After adjusting all the configurations, we can draw the created
window. For this, we send a request to the server X and wait in a loop
until we are notified that the window was created (we asked to be
notified of this event when we passed
flag \monoespaco{StructureNotifyMask} to
function \monoespaco{XSelectInput} previously). The code for this is:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XMapWindow(display, window);
{
  XEvent e;
  do{
    XNextEvent(display, &e);
  } while(e.type != MapNotify);
}
#endif
@
\fimcodigo

\subsecao{2.2. Creating a ``Window'' in a Web Browser}

One of the most different environments where our API can be executed
are web browsers after the code is compiled to Web Assembly. In this
case, there are no true window, the space where we can draw in the
screen is a HTML canvas. We do not need to worry about the possibility
of the user resize the window, for example. But we still need to pay
attention to the size of the screen and should allow the resizing of
our canvas.

Here we can create and manipulare the drawing area combining two
things: the SDL library, presented as an interface to graphical
actions by Emscripten environment and Javascript code that we also can
execute.

First we include the Emscripten and SDL headers:

\iniciocodigo
@<Headers@>+=
#if defined(__EMSCRIPTEN__)
#include <SDL/SDL.h>
#include <emscripten.h>
#endif
@
\fimcodigo


Our first challenge in this environment is discover screen
resolution. We can do this using the following Javascript code:

\iniciocodigo
@<Web Assembly: Create Window@>=
#if defined(__EMSCRIPTEN__)
screen_resolution_x = EM_ASM_INT({
  return window.screen.width * window.devicePixelRatio;
});
screen_resolution_y = EM_ASM_INT({
  return window.screen.height * window.devicePixelRatio;
});
#endif
@
\fimcodigo

Next we want to initialize the window SDL subsystem. This is done
calling the function below:

\iniciocodigo
@<Web Assembly: Create Window@>+=
#if defined(__EMSCRIPTEN__)
SDL_Init(SDL_INIT_VIDEO);
#endif
@
\fimcodigo

Now we will create the window, which in practice means adjust the
canvas size where we will draw and initialize it. The HTML canvas
should be the screen size, except if the user defined
macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN} and defined positive
values for \monoespaco{W\_WINDOW\_RESOLUTION\_X}
and \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. We also ensure that the
canvas is visible using Javascript, as it could be hidden (we do it
when we execute the function to close the window).

\iniciocodigo
@<Web Assembly: Create Window@>+=
#if defined(__EMSCRIPTEN__)
{
  int size_x, size_y, fullscreen_flag = 0;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
#if defined(W_WINDOW_NO_FULLSCREEN) && \
    !defined(W_WINDOW_FORCE_FULLSCREEN)
  fullscreen_flag = SDL_WINDOW_FULLSCREEN;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUtION_X > 0
  size_x = W_WINDOW_RESOLUtION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUtION_Y > 0
  size_y = W_WINDOW_RESOLUtION_Y;
#endif
#endif
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "initial";
  );
  window = SDL_SetVideoMode(size_x, size_y, 0,
                            SDL_OPENGL | fullscreen_flag);
  if(window == NULL)
    return false;
}
#endif
@
\fimcodigo

The window in this case is considered a SDL surface:

\iniciocodigo
@<Local Variables@>+=
#if defined(__EMSCRIPTEN__)
static SDL_Surface *window;
#endif
@
\fimcodigo

\subsecao{2.3. Creating a Windows in (Microsoft) Windows}

As always, to program in Windows we need the following header:

\iniciocodigo
@<Headers@>+=
#if defined(_WIN32)
#include <Windows.h>
#endif
@
\fimcodigo

Now we obtain the resolution of the main monitor using:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
screen_resolution_x = GetSystemMetrics(SM_CXSCREEN);
screen_resolution_y = GetSystemMetrics(SM_CYSCREEN);
#endif
@
\fimcodigo

Now we need to create a class for our window. The class should have an
unique non-conflicting name. We also pass an identifier with the
instance of our program (that we get
with \monoespaco{GetModuleHandle}) and the function to deal with
signals and messages for the window (in our case, the
default \monoespaco{DefWindowProc}).

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
if(!already_created_a_class){
  const wchar_t class_name[]  = L"Weaver Window";
  WNDCLASS windows_class = {};
  windows_class.lpfnWndProc = DefWindowProc;
  windows_class.hInstance = GetModuleHandle(NULL);
  windows_class.lpszClassName = class_name;
  RegisterClass(&window_class);
}
#endif
@
\fimcodigo

The code above assumes that we have declared a boolean variable that
stores if we already created a class:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static bool already_created_a_class = false;
#endif
@
\fimcodigo

After defining the window class, we can create the window with the
code below:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
{
  int size_x, size_y;
  DWORD fullscreen_flag = WS_POPUP;
  CRect size;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
  SystemParametersInfoA(SPI_GETWORKAREA, NULL, &size, NULL);
#if !defined(W_WINDOW_FORCE_FULLSCREEN) && \
    defined(W_WINDOW_NO_FULLSCREEN)
  size_x = size.left - size.right;
  size_y = size.bottom - size.top;
  fullscreen_flag = WS_OVERLAPPED;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#endif
#endif
  window = CreateWindowEx(0, "Weaver Window",
                          W_WINDOW_NAME,
                          fullscreen_flag | WS_VISIBLE,
                          size.left, size.top, size_x, size_y,
                          NULL, NULL,
                          GetModuleHandle(NULL),
                          NULL);
}
#endif
@
\fimcodigo

We will store the handle to the created window in this variable:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static HWND window;
#endif
@
\fimcodigo


\subsecao{2.X. Window Creation Function}

Our function that creates a new window will execute the adequate code,
depending on the graphical environment where termosit is being
executed. But before this we will add code to check if a window
already was created. This information will be stored in a boolean
variable:

\iniciocodigo
@<Functions@>=
bool _Wcreate_window(void){
  if(already_have_window == true)
    return false;
  @<X11: Create Window@>
  @<Web Assembly: Create Window@>
  @<Windows: Create Window@>
  already_have_window = true;
  return true;
}
@
\fimcodigo

The variable that stores if the window already was created will be
declared here:

\iniciocodigo
@<Local Variables@>+=
static bool already_have_window = false;
@
\fimcodigo


\subsecao{2.X+1. Closing a Window in X}

Closing a window in X11 means calling the function that asks the
server to close the window and also closing the connection with the
server. This is done calling respectively \monoespaco{XDestroyWindow}
and \monoespaco{XCloseDisplay}. We also check if we really have an
existing window before trying to close and destroy it.

\iniciocodigo
@<Functions@>=
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  XDestroyWindow(display, window);
  XCloseDisplay(display);
  already_have_window = false;
  return true;
}
@
\fimcodigo

\subsecao{2.X+2. Closing a Window in Web Assembly}

Closing a window when running in a web browser means finalize the SDL
structures and hide the canvas where we were drawing. We do this with
the following function:

\iniciocodigo
@<Functions@>+=
#if defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  SDL_FreeSurface(window);
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "none";
  );
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.X+3. Closing a Window on Windows}

Closing a window in Windows means calling a simple function to destroy
the window:

\iniciocodigo
@<Functions@>+=
#if defined(_WIN32)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  DestroyWindow(window);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo


\subsecao{X. Final File Sctructure}

The file with all the necessary source code for the functions defined
in this article will have the following organization:

\iniciocodigo
@(src/window.c@>=
#include "window.h"
@<Headers@>
@<Local Variables@>
@<Functions@>
@
\fimcodigo


\fim
