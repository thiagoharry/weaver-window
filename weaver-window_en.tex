\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Windowing Interface Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of a portable
  Windowing API, which can be used to create a single window in
  Windows, Linux, BSD, or a canvas in Web Assembly running in a web
  browser. You can set a fullscreen mode, change the resolution in the
  window, resize it, use OpenGL commands and get input from mouse and
  keyboard. All this can be achieved by the portable API defined in
  this work.}

\secao{1. Introduction}

A graphical computer program needs a space where it can draw in the
screen. In some environments, lke video-games, each program always
controll the entire screen automatically, without asking for it to
some operating system. But when a computer program runs in a computer
with some modern graphical environment, usually it is necessary to ask
for the creation of some region called ``window''. There the program
have control over the content and can draw freely.

Besides creating the window, it is also important to have control if
we are in full-screen or not if we are in an environment that allows
this. And also change the size of our window in pixels. If we are in
fullscreen mode, this means changing the resolution of the
screen. Otherwise, this means changing the window size. This is
important because depending on the used visual effects, we could need
to draw less pixels in the screen for performance reasons.

\subsecao{1.1. Literary Programming and Notation}

This article uses the technique of ``Literary Programming'' to develop
our random number generator API. This technique was presented at
[Knuth, 1984] and have as objective develop software in a way that a
computer program to be compiled is exactly equal a document written
for human beings detailing and explaining the code. This document is
not independent of the source code, it is the project source
code. Automated tools are used to extract the code from this document,
sort it in the right order and produce the code that is passed to a
compiler.

For example, in this article we will define two different
files: \monoespaco{window.c} and \monoespaco{window.h}. Both of them
can be inserted statically in any project or compiled as a shared
library. The content of \monoespaco{window.h} is:

\iniciocodigo
@(src/window.h@>=
#ifndef WEAVER_WINDOW
#define WEAVER_WINDOW
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define type 'bool'
@<OpenGL Header@>
@<Macro Definition@>
@<Window Declarations@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The two first lines and the last one are macros that ensure that the
function declaration and variables from this file will always be
included at most once in a compiling unit. We also put macros to check
if we are compiling this as C or C++. If we are in C++, we assure the
compiler that all our functions will be in C-style. We never will
modify them with operator overload, for example. This makes the code
became more compact.

The red parts in the above code shows that some code will be inserted
there in the future. In ``RNG Declarations'', for example, we will put
there function declarations.

Each piece of code have a title, that in the above example is
\monoespaco{src/window.h}. The title shows where the code will be placed.
In the case above, the code will directly to a file. In future pieces
of code, we will have different titles, including titles matching
exactly the names present in the red code above. If a piece of code
have as title a name matching the red part in some code, then that
code is positioned exactly in that red part when compiling the code.

As a second example of code, we also will declare here that when we
are in debug mode (when the macro \monoespaco{W\_DEBUG\_WINDOW} is
declared) we will need the declaration of input/output functions, as
our code will be more verbose:

\iniciocodigo
@<Headers@>=
#if defined(W_DEBUG_WINDOW)
#include <stdio.h>
#endif
@
\fimcodigo

Notice that we still did not define where this code section called
``Headers'' will be positioned. We can do this later.

\subsecao{1.2. API functions that will be defined}

In this article we will define the following functions:

\iniciocodigo
@<Window Declarations@>=
bool _Wcreate_window(void);
@
\fimcodigo

This function will create a new window. By default, it will create a
fullscreen window. If the macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}
is defined, instead it will create a non-fullscreen window.

If the macro \monoespaco{W\_DEBUG\_WINDOW} is defined, this function
also will print in the screen information about the graphical
environment. Its resolution for example. But possibly other
information that can be relevant.

In case of error, the function will return false.

\iniciocodigo
@<Window Declarations@>=
bool _Wdestroy_window(void);
@
\fimcodigo

This function closes the window, freeing any resource allocated during
the window creation by the previous function. This function must be
invoked only after a window was created. In case of error, it returns
false.

\iniciocodigo
@<Window Declarations@>+=
bool _Wrender_window(void);
@
\fimcodigo

This function will render in the screen all pending ommands since last
rendering. It will return false in case of error. This function
probably will be called in the end of each iteration in a main loop.

\iniciocodigo
@<Window Declarations@>=
bool _Wget_screen_resolution(int *resolution_x, int *resolution_y);
@
\fimcodigo

This function gets the screen resolution and store in the pointers
passed as argument. If we have more than one screen, it will return
data about the main window. In case of error, it returns false and
stores zero as the resolution.

\iniciocodigo
@<Window Declarations@>=
bool _Wget_window_size(int *width, int *height);
@
\fimcodigo

This function gets the current window size in pixels and store the
information in the pointers passed as argument. If we have no window
or in case of error, it returns false and store 0 in the
pointers. Otherwise, it returns true and store the correct value in
the pointers.

\iniciocodigo
@<Window Declarations@>=
void _Wget_window_input(unsigned long current_time, struct _Wkeyboard *keyboard,
                        struct _Wmouse *mouse);
@
\fimcodigo

This is the function that shall be called periodically to update the
keyboard and mouse state. The first argument is the current time
measured in some unit of time. The next arguments are structs that
represent keyboard and mouse and that shall be updated.

\iniciocodigo
@<Window Declarations@>=
void _Wflush_window_input(void);
@
\fimcodigo

This function cleans the state for keyboard and mouse structs. It
should be called each time we interrupt our periodic invocation
of \monoespaco{\_Wget\_window\_input}. Calling these functions the
structs are reset to the initial state. And we stop to consider as
pressed or released any key or button.

\secao{2. Creating and Managing the Window}

\subsecao{2.1. Getting Screen Resolution}

Before creating our window, it is important to check what is our
window resolution. If we are running in fullscreen mode, this will be
our window size. This is accomplished differently accordig with the
operating system.

\subsubsecao{2.1.1. Getting Screen Resolution on X}

The X Window System, also known as X11, is a windowing system present
in many Operating System, as Linux, BSD and even in MacOX, where it
exists to ensure compatibility with older programs developed before
their current windowing system. We will begin our function
implementation with X11 because is the most widely present windowing
system.

X11 works in a client-server architecture. When we create a graphical
program, we create a client that communicates with X server using
sockets. All operations like window creation, resizing windows and
more are made when with the client asking for them sending requests to
the server, which executes the requests if possible.

We expect to use X11 when we are not compiling programs to Windows or
to Web Assembly, as both the Windows Operating System and web browsers
do not have a X11 server. If we will use X11, we need the following
header:

\iniciocodigo
@<Headers@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xlib.h>
#endif
@
\fimcodigo

In X11, as we need to communicate with a server, we assume that we
have a variable with some data structure with information about this
connection. This variable is called ``\monoespaco{display}''.

Using such connection, that we assume being a static variable
in \monoespaco{window.c}, we read the resolution using the function
below:

\iniciocodigo
@<API Functions@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wget_screen_resolution(int *resolution_x, int *resolution_y){
  bool keep_alive = true; // Should we keep the connection alive?
  // The first called unction should be this that prepares X11 for any
  // multi-threaded invocation
  XInitThreads();
  // If we still do not have an active connection, we create it:
  if(display == NULL){
    display = XOpenDisplay(NULL);
    keep_alive = false;
  }
  // Now we get the default screen number:
  int screen = DefaultScreen(display);
  // And ask for its resolution:
  *resolution_x = DisplayWidth(display, screen);
  *resolution_y = DisplayHeight(display, screen);
  // If we had not an active connection before invoking this function, we
  // should keep things this way:
  if(!keep_alive){
    XCloseDisplay(display);
    display = NULL;
  }
  // If everything is ok, we should return true:
  return true;
}
}
#endif
@
\fimcodigo

Of course, we assume the existence of the following static variable:

\iniciocodigo
@<Local Variables@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static Display *display = NULL; //Connection with server and info about screens
#endif
@
\fimcodigo

\subsubsecao{2.1.2. Getting Screen Resolution on Web Assembly}

If we are running Web Assembly, then we are in a web broser. Our
``window'' will be a HTML canvas. And to obtain the screen size, we
need to run javascript code. We can do this with the help of
Emscripten API:

\iniciocodigo
@<API Functions@>=
#if defined(__EMSCRIPTEN__)
bool _Wget_screen_resolution(int *resolution_x, int *resolution_y){
  *resolution_x = EM_ASM_INT({
    return window.screen.width * window.devicePixelRatio;
  });
  *resolution_y = EM_ASM_INT({
    return window.screen.height * window.devicePixelRatio;
  });
  return true;
}
#endif
@
\fimcodigo


\subsubsecao{2.1.3. Getting Screen Resolution on Windows}

Finally, on Windows, we do this calling an API function that gives us
this information:

\iniciocodigo
@<Funções da API@>+=
#if defined(_WIN32)
bool _Wget_screen_resolution(int *resolution_x, int *resolution_y){
  *resolution_x = GetSystemMetrics(SM_CXSCREEN);
  *resolution_y = GetSystemMetrics(SM_CYSCREEN);
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.2. Creating a Window}

Now we describe how to create a window in all the supported
environments: X11 graphical environment, windows and a web browser
running Web Assembly.

\subsubsecao{2.2.1. Creating a Window on X}

The steps to create a window on X11 are:

0. We ask the X libraryq to be prepared for simultaneous
communications caming from multiple threads. It is not common needing
to do this, but it is a good practice to be prepared if this
happens. This must be the first thing to do, before using other
library functions.

1. We open a connection with the server. If we succeed, we get as
response a list of relevant information about the screen.

2. We read the resolution using the function defined on section 2.1.

3. We send a new message to the server asking to create a new
window. We will do it in the default screen, The window size will be
the greatest value allowed given the screen resolution.

The above steps are implemented using the functions and macros below:

\iniciocodigo
@<X11: Create Window@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
int screen_resolution_x, screen_resolution_y; //Screen resolution
/* Step 0: */
XInitThreads();
/* Step 1: */
display = XOpenDisplay(NULL);
if(display == NULL){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to connect to X11 server.\n");
#endif
  return false; // Couldn't connect
}
/* Step 2: */
_Wget_screen_resolution(&screen_resolution_x, &screen_resolution_y);
/* Step 3: */
window = XCreateSimpleWindow(display, // X11 connection
                             DefaultRootWindow(display),// Parent window
                             0, 0, // Window position
                             screen_resolution_x, // Width
                             screen_resolution_y, // Height
                             0, 0, // Border width and color
                             0); // Default window color
#endif
@
\fimcodigo

This code assumes that we have the following declared variable to
store and remember the created window:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static Window window;    // Created window struct
#endif
@
\fimcodigo

The code defined above creates a window, but it does not mean that the
created window is drawn in the screen. Before drawing the window in
the screen we can adjust some of its properties.

The first thing that we need to adjust is that by default the window
should be created in fullscreen mode. We do this asking to the window
manager do not interefere with the window creating decorations or
limiting its size. But we do this only if the user did not disable
fullscreen setting a macro:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if !defined(W_WINDOW_NO_FULLSCREEN)
{
  XSetWindowAttributes attributes;
  attributes.override_redirect = true;
  XChangeWindowAttributes(display, window, CWOverrideRedirect,
                          &attributes);
}
#endif
#endif
@
\fimcodigo

But what if we are running outside the fullscreen mode and the user
has defined macros that configure the window size to a different size
than occupy the whole screen? In this case, we need to resize the
window before drawing it for the first time. The macros that control
the window size when we are not in fullscreen mode
are \monoespaco{W\_WINDOW\_RESOLUTION\_X}
and \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. If they are non-positive,
then this means that we should set their values as the greatest
possible given the screen resolution. Otherwise, their values
represent the size in pixels for the window. But this is true only
outside fullscreen mode:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if defined(W_WINDOW_NO_FULLSCREEN)
{
  int size_x, size_y;
#if W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#else
  size_x = screen_resolution_x;
#endif
#if W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#else
  size_y = screen_resolution_y;
#endif
  XResizeWindow(display, window, size_x, size_y);
}
#endif
#endif
@
\fimcodigo

We also will warn the window manager to not allow window resizing. The
window should be resized only using resizing functions that we will
soon define:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
{
  XSizeHints hints;
  hints.flags = PMinSize | PMaxSize;
#if defined(W_WINDOW_NO_FULLSCREEN) && W_WINDOW_RESOLUTION_X > 0
  hints.min_width = hints.max_width = W_WINDOW_RESOLUTION_X;
#else
  hints.min_width = hints.max_width = screen_resolution_x;
#endif
#if defined(W_WINDOW_NO_FULLSCREEN) && W_WINDOW_RESOLUTION_Y > 0
  hints.min_height = hints.max_height = W_WINDOW_RESOLUTION_Y;
#else
  hints.min_height = hints.max_height = screen_resolution_y;
#endif
  XSetWMNormalHints(display, window, &hints);
}
#endif
@
\fimcodigo

The above resource needs the following header:

\iniciocodigo
@<Headers@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xutil.h>
#endif
@
\fimcodigo

Another relevant information to adjust is what kind of events is
relevant to pass to the program when something happen to the
window. For example, we do not consider relevant if the user interacts
with another window making our window lose focus. But other events,
like the information that the user pressed a key is relevant and our
program should be informed.

The list of events that we consider relevant is: the window is created
or destroyed, the user presses or releases a mouse button, presses or
releases a key in keyboard and if the user moves the mouse pointer. If
we do not ask the server to send this information, our program would
not be able to know if the user interacts with it pressing keys.

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XSelectInput(display, window, StructureNotifyMask | KeyPressMask |
                              KeyReleaseMask | ButtonPressMask |
                              ButtonReleaseMask | PointerMotionMask);
#endif
@
\fimcodigo

Another important thing is choose the name for our window. Usually
this name is presented by the window manager. We let the user choose
the name setting the macro \monoespaco{W\_WINDOW\_NAME}:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XStoreName(display, window, W_WINDOW_NAME);
#endif
@
\fimcodigo

If this macro is not defined, we use an empty string:

@<Macro Definition@>+=
#if !defined(W_WINDOW_NAME)
#define W_WINDOW_NAME ""
#endif
@
\fimcodigo

Now we configure OpenGL ES. As this is sufficiently laborious, we
write the necessary steps in the next session:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
@<X11: Configure OpenGL ES@>
#endif
@
\fimcodigo

After adjusting all the configurations, we can draw the created
window. For this, we send a request to the server X and wait in a loop
until we are notified that the window was created (we asked to be
notified of this event when we passed
flag \monoespaco{StructureNotifyMask} to
function \monoespaco{XSelectInput} previously). The code for this is:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XMapWindow(display, window);
{
  XEvent e;
  do{
    XNextEvent(display, &e);
  } while(e.type != MapNotify);
}
#endif
@
\fimcodigo

\subsubsecao{2.2.2. Creating a Window on Web Assembly}

One of the most different environments where our API can be executed
are web browsers after the code is compiled to Web Assembly. In this
case, there are no true window, the space where we can draw in the
screen is a HTML canvas. We do not need to worry about the possibility
of the user resize the window, for example. But we still need to pay
attention to the size of the screen and should allow the resizing of
our canvas.

Here we can create and manipulate the drawing area combining two
things: the SDL library, presented as an interface to graphical
actions by Emscripten environment and Javascript code that we also can
execute.

Now we include the Emscripten and SDL headers:

\iniciocodigo
@<OpenGL Header@>+=
#if defined(__EMSCRIPTEN__)
#include <GLES2/gl2.h>
#include <SDL/SDL.h>
#include <emscripten.h>
#endif
@
\fimcodigo

First we get the screen resolution with the function defined in
Subsubsection 2.1.2:

\iniciocodigo
@<Web Assembly: Create Window@>=
#if defined(__EMSCRIPTEN__)
int screen_resolution_x, screen_resolution_y;
_Wget_screen_resolution(&screen_resolution_x, &screen_resolution_y);
#endif
@
\fimcodigo

The next step is initialize the video subsystem in SDL library. This
is done with the following initialization:

\iniciocodigo
@<Web Assembly: Create Window@>+=
#if defined(__EMSCRIPTEN__)
SDL_Init(SDL_INIT_VIDEO);
#endif
@
\fimcodigo

Now we will create the window, which in practice means adjust the
canvas size where we will draw and initialize it. The HTML canvas
should be the screen size, except if the user defined
macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN} and defined positive
values for \monoespaco{W\_WINDOW\_RESOLUTION\_X}
and \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. We also ensure that the
canvas is visible using Javascript, as it could be hidden (we do it
when we execute the function to close the window).

\iniciocodigo
@<Web Assembly: Create Window@>+=
#if defined(__EMSCRIPTEN__)
{
  int size_x, size_y, fullscreen_flag = SDL_WINDOW_FULLSCREEN;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
#if defined(W_WINDOW_NO_FULLSCREEN)
  fullscreen_flag = 0;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUtION_X > 0
  size_x = W_WINDOW_RESOLUtION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUtION_Y > 0
  size_y = W_WINDOW_RESOLUtION_Y;
#endif
#endif
  // Ajusta versão do OpenGL
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION,
                     W_WINDOW_OPENGL_MAJOR_VERSION);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION,
                     W_WINDOW_OPENGL_MINOR_VERSION);
  // Garante que o canvas estará visível
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "initial";
  );
  window = SDL_SetVideoMode(size_x, size_y, 0,
                            SDL_OPENGL | fullscreen_flag);
  if(fullscreen_flag){
    EM_ASM(// Activating fullscreen on Javascript
      var el = document.getElementById("canvas");
      if(el.requestFullscreen){
        el.requestFullscreen();
      }
    );

  if(window == NULL)
    return false;
}
#endif
@
\fimcodigo

The window in this case is considered a SDL surface:

\iniciocodigo
@<Local Variables@>+=
#if defined(__EMSCRIPTEN__)
static SDL_Surface *window;
#endif
@
\fimcodigo

\subsubsecao{2.2.3. Creating a Window on (Microsoft) Windows}

As in the previous code, we begin asking for the screen resolution:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
int screen_resolution_x, screen_resolution_y;
_Wget_screen_resolution(&screen_resolution_x, &screen_resolution_y);
#endif
@
\fimcodigo

Next we need to define a class for our window. First we need to give
it an arbitrary name in a string format. We will call it
``WeaverWindow'':

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static const char *class_name = "WeaverWindow";
#endif
@
\fimcodigo

Now our class need a function to handle signals and messages sent to
the window. Such messages are sent when the window is created,
destroyed, resized, exposed, for example. We always can redirect the
messages to function \monoespaco{DefWindowProc} to deal with them
using default actions, but for some messages it is best to define
ourselves the correct action to be taken. The function format is:

\iniciocodigo
@<API Functions@>+=
#if defined(_WIN32)
LRESULT CALLBACK WindowProc(HWND window, UINT msg, WPARAM param1, LPARAM param2){
  switch(msg){
    @<Windows: Deal with Window Messages@>
    default:
      return DefWindowProc(window, msg, param1, param2);
  }
}
#endif
@
\fimcodigo

But when will we deal with the received message instead of just
passing it to \monoespaco{DefWindowProc}? One of the cases is when the
window get a message warning that it is being closed:

\iniciocodigo
@<Windows: Deal with Window Messages@>=
case WM_DESTROY:
  PostQuitMessage(0);
  return 0;
  break;
@
\fimcodigo

Now we need to create a class for our window. The class should have an
unique non-conflicting name. We also pass an identifier with the
instance of our program (that we get
with \monoespaco{GetModuleHandle}) and the function to deal with
signals and messages for the window (in our case, the
default \monoespaco{DefWindowProc}).

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
if(!already_created_a_class){
  ATOM ret;
  WNDCLASS window_class;
  memset(&window_class, 0, sizeof(WNDCLASS));
  window_class.lpfnWndProc = WindowProc;
  window_class.hInstance = GetModuleHandle(NULL);
  window_class.lpszClassName = class_name;
  window_class.hbrBackground = CreateSolidBrush(RGB(0, 0, 0)); // Black window
  ret = RegisterClass(&window_class);
  if(ret == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to register Window Class. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  already_created_a_class = true;
}
#endif
@
\fimcodigo

For convenince, we used the function \monoespaco{memset} to initialize
the struct of our window class, as the majority of its elements can be
set to zero to keep the default value. Because of this, we insert the
following header:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32)
#include <string.h>
#endif
@
\fimcodigo

The code above assumes that we have declared a boolean variable that
stores if we already created a class:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static bool already_created_a_class = false;
#endif
@
\fimcodigo

After defining the window class, we can create the window with the
code below:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
{
  int size_x, size_y;
  DWORD fullscreen_flag = WS_POPUP;
  RECT size;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
  SystemParametersInfoA(SPI_GETWORKAREA, 0, &size, 0);
#if !defined(W_WINDOW_FORCE_FULLSCREEN) && \
    defined(W_WINDOW_NO_FULLSCREEN)
  size_x = size.left - size.right;
  size_y = size.bottom - size.top;
  fullscreen_flag = WS_OVERLAPPED;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#endif
#endif
  window = CreateWindowEx(0, class_name,
                          W_WINDOW_NAME,
                          fullscreen_flag | WS_VISIBLE,
                          size.left, size.top, size_x, size_y,
                          NULL, NULL,
                          GetModuleHandle(NULL),
                          NULL);
  if(window == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating window. SysCode: %d\n",
            GetLastError());
#endif
    return false;
  }
}
#endif
@
\fimcodigo

We will store the handle to the created window in this variable:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static HWND window;
#endif
@
\fimcodigo

Before showing the window on the screen we configure OpenGL on it:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
@<Windows: Configurar OpenGL@>
#endif
@
\fimcodigo

Now we ask the system to show the window to the user and then wait in
a loop until we get a message saying that the window was created:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
{
  MSG msg;
  ShowWindow(window, SW_NORMAL);
  do{
    GetMessage(&msg, NULL, 0, 0);
  } while(msg.message == WM_CREATE);
}
#endif
@
\fimcodigo

\subsubsecao{2.2.4. Defining the Function for Window Creation in All Environments}

In the previous subsubsections, we defined code for window creation in
different environments, and all code was placed inside conditional
macros that uses each code only in the right environment. Now we can
unite all these previous code blocks in a single function:

\iniciocodigo
@<API Functions@>=
bool _Wcreate_window(void){
  if(already_have_window == true)
    return false;
  @<X11: Create Window@>
  @<Web Assembly: Create Window@>
  @<Windows: Create Window@>
  _Wflush_window_input();
  already_have_window = true;
  return true;
}
@
\fimcodigo

The variable that stores if the window already was created will be
declared here:

\iniciocodigo
@<Local Variables@>+=
static bool already_have_window = false;
@
\fimcodigo

\subsecao{2.3. Configuring OpenGL}

Our API aim to support at least OpenGL S 2.0. In most environments
this is not a problem. But on Windows, for example, we have no
guarantees that we have OpenGL ES support. In this case, we should use
OpenGL 4, but we should support only the functions and macros that
exists on OpenGL ES 2.0.

\subsubsecao{2.3.1. Configuring OpenGL ES in X11}

In X11, the interface used to program in OpenGL ES is called EGL and
its functions and macros are declared in the following header:

\iniciocodigo
@<OpenGL Header@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include <EGL/eglext.h>
#endif
@
\fimcodigo

Now we need to create a structure needed by OpenGL ES to store
information about the graphical interface: a OpenGL display. Such
display can be obtained from the X display that we already created:

\iniciocodigo
@<X11: Configure OpenGL ES@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
egl_display = eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR, display,
                                    NULL);
if(egl_display == EGL_NO_DISPLAY){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL display.\n");
#endif
  return false;
}
eglInitialize(egl_display, NULL, NULL);
#endif
@
\fimcodigo

This variable is declared here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLDisplay *egl_display;
#endif
@
\fimcodigo

Now we need to obtain a configuration to the creation of a OpenGL
context. We specify some requirements and get a configuration using
the code below:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
{
  bool ret;
  int number_of_configs_returned;
  int requested_attributes[] = {
    // We should support drawing in the screen and textures
    EGL_SURFACE_TYPE,  EGL_WINDOW_BIT | EGL_PBUFFER_BIT,
    // And at least 1 bit to the red color:
    EGL_RED_SIZE, 1,
    // At least 1 bit to the green color:
    EGL_GREEN_SIZE, 1,
    // At least 1 bit to the blue color:
    EGL_BLUE_SIZE, 1,
    // At least 1 bit to the alpha channel:
    EGL_ALPHA_SIZE, 1,
    // At least 1 bit to the depth channel:
    EGL_DEPTH_SIZE, 1,
    EGL_NONE
  };
  ret = eglChooseConfig(egl_display, requested_attributes,
                        &egl_config, 1, &number_of_configs_returned);
  if(ret == EGL_FALSE){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create valid EGL config.\n");
#endif
    return false;
  }
}
@
\fimcodigo

The struct that stores which configuration we will use is declared
here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
EGLConfig egl_config;
#endif
@
\fimcodigo


Like how EGL needs its own display struct, it also needs its own
window struct to store information about the window where it will
draw. We can initialize such structure from the window struct used by
the X library:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
egl_window = eglCreateWindowSurface(egl_display, egl_config,
                                    window, NULL);
if(egl_window == EGL_NO_SURFACE){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL window.\n");
#endif
  return false;
}
@
\fimcodigo

The EGL window is decared here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLSurface egl_window;
#endif
@
\fimcodigo


Now we can create the OpenGL context. We let the user choose which
will be the major and minor OpenGL version using
macros \monoespaco{W\_WINDOW\_OPENGL\_MAJOR\_VERSION} and
\monoespaco{W\_WINDOW\_OPENGL\_MINOR\_VERSION}. With this information, we create the context:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
{
  int context_attribs[] = {
    EGL_CONTEXT_MAJOR_VERSION, W_WINDOW_OPENGL_MAJOR_VERSION,
    EGL_CONTEXT_MINOR_VERSION, W_WINDOW_OPENGL_MINOR_VERSION,
    EGL_NONE
  };
  egl_context = eglCreateContext(egl_display, egl_config,
                                 EGL_NO_CONTEXT, context_attribs);
  if(egl_context == EGL_NO_CONTEXT){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create EGL context.\n");
#endif
    return false;
  }
  eglMakeCurrent(egl_display, egl_window, egl_window, egl_context);
}
@
\fimcodigo

The variable that stores the handle to the OpenGL context is declared
here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLContext egl_context;
#endif
@
\fimcodigo

\subsubsecao{2.3.2. Configuring OpenGL on Web Assembly}

No additional configuration is necessary. We already support OpenGL
because when we created a ``window'' on Subsubsection 2.2.2, we passed
a flag that activated OpenGL.

It should be noted that the OpenGL version in this case is WebGL, but
this version is compatible with OpenGL ES.

\subsubsecao{2.3.3. Configuring OpenGL on Windows}

To use OpenGL on Windows, first we warn the compiler about the
necessary libraries, so that we do not need to pass them explicitly
during the linking, and then we include the default library and the
OpenGL library:

\iniciocodigo
@<OpenGL Header@>+=
#if defined(_WIN32)
#pragma comment(lib, "Opengl32.lib")
#pragma comment(lib, "User32.lib")
#pragma comment(lib, "Gdi32.lib")
#include <windows.h>
#include <GL/gl.h>
#endif
@
\fimcodigo

We also need an struct with information about the device where we will
draw. In our case, a window:

\iniciocodigo
@<Windows: Configure OpenGL@>=
device_context = GetDC(window);
@
\fimcodigo

This struct is declared here with the context that we will soon initialize:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static HGLRC wgl_context;
static HDC device_context;
#endif
@
\fimcodigo

Besides this, configuring OpenGL on Windows is a little messy. To
start, the default function that creates an OpenGL
context, \monoespaco{wglCreateContext}, is too primitive, without
guaranteed support for more recent OpenGL functions and without
support for necessary parameters to create a modern OpenGL
context. But we can use an alternative function to create a modern
OpenGL context: \monoespaco{wglCreateContextAttribsARB}. Using this
function we can do some basic stuff, like choosing which OpenGL
version we want and we can ask for support to modern OpenGL functions
and that support more parameters.

The problem is that the
function \monoespaco{wglCreateContextAttribsARB} is not a part of the
API, but it is an extension. We must load this function using an
auxiliary function before using it to create a context. But to use the
function that loads it, we need an existing OpenGL context active.

This can be solved first creating a basic OpenGL context using the
default API, loading the function that creates a proper context,
creating a modern context, associating it to a window and loading all
the necessary function that is not part of the default API. But it is
not possible to associate more than one OpenGL context to a single
window. So to load our function we need to create a dummy window and
dummy context before:

\iniciocodigo
@<Windows: Configure OpenGL@>=
{
@<Windows: Create Dummy Window@>
@<Windows: Create Dummy Context@>
@<Windows: Load Initial OpenGL Functions@>
@<Windows: Remove Dummy Context and Window@>
}
@
\fimcodigo

First let's create our dummy window. As this will not be our rendering
window, we do not need to create it using all the specifications from
the real window:

\iniciocodigo
@<Windows: Create Dummy Window@>=
HWND dummy_window;
{
  WNDCLASS dummy_window_class;
  memset(&dummy_window_class, 0, sizeof(WNDCLASS));
  dummy_window_class.lpfnWndProc = WindowProc;
  dummy_window_class.hInstance = GetModuleHandle(NULL);
  dummy_window_class.lpszClassName = "DummyWindow";
  // This is expected to fail if the class already is registered. It happens
  // when we create more than one window with this function. So we just ignore
  // errors returned by this function:
  RegisterClass(&dummy_window_class);
  SetLastError(0);
  dummy_window = CreateWindowEx(0, dummy_window_class.lpszClassName, "Dummy",
                                0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, 0, 0,
                                dummy_window_class.hInstance, 0);
  if(dummy_window == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating window. SysCode: %d\n",
            GetLastError());
#endif
    return false;
  }
}
@
\fimcodigo

Now to create a dummy context first we ned to choose an existing pixel
format similar to what we specify and then we set the pixel format in
our dummy window:

\iniciocodigo
@<Windows: Create Dummy Context@>=
HGLRC dummy_context;
HDC dummy_device_context = GetDC(dummy_window);
{
  PIXELFORMATDESCRIPTOR pixel_format;
  int chosen_pixel_format;
  memset(&pixel_format, 0, sizeof(WNDCLASS));
  pixel_format.nSize = sizeof(PIXELFORMATDESCRIPTOR); // Tamanho da estrutura
  pixel_format.nVersion = 1; // Número de versão
  pixel_format.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL |
                         PFD_DOUBLEBUFFER | PFD_DRAW_TO_BITMAP;
  pixel_format.iPixelType = PFD_TYPE_RGBA;
  pixel_format.cColorBits = 24; // 24 bits para profundidade de cor
  pixel_format.cDepthBits = 32; // 32 bits para buffer de profundidade
  pixel_format.iLayerType = PFD_MAIN_PLANE;
  chosen_pixel_format = ChoosePixelFormat(dummy_device_context, &pixel_format);
  if(chosen_pixel_format == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to choose a pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  if(! SetPixelFormat(dummy_device_context, chosen_pixel_format, &pixel_format)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to set a pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  // ...
@
\fimcodigo

And after configuring the pixel format, we can get the dummy OpenGL
context:

\iniciocodigo
@<Windows: Create Dummy COntext@>+=
  // ...
  dummy_context = wglCreateContext(dummy_device_context);
  if(dummy_context == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating dummy OpenGL context. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  if(! wglMakeCurrent(dummy_device_context, dummy_context)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed setting dummy OpenGL context. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
}
@
\fimcodigo

Now we need to load the functions that we need. Loading existing
functions that are not normally accessible because they are considered
extensions, can be done using the
function \monoespaco{wglGetProcAddress} as in the loading function
below that returns a pointer to the desired function:

\iniciocodigo
@<Local Functions@>+=
#if defined(_WIN32)
static void *load_function(const char *name){
  void *ret = wglGetProcAddress(name);
  if(ret == NULL || ret == (void *) -1 || ret == (void *) 0x1 ||
     ret == (void *) 0x2 || ret == (void *) 0x3){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Function '%s' not supported.\n", name);
#endif
    return NULL;
  }
  return ret;
}
#endif
@
\fimcodigo

Notice that as revealed by the code above, the
function \monoespaco{wglGetProcAddress} can return up to 5 different
values in case of error. Despite the fact that according with the
documentation, only \monoespaco{NULL} is the correct way to signal an
error.

The two needed functions is one that chooses a pixel format (like the
pixel format chosen above, but with more options and resources) and
another that creates an OpenGL context (like the dummy context above,
but also with more options and resources).

To load new functions, first we declare pointers to store the memory
position where are our new loaded functions. In the case of the two
functions that we want now, their ponters are declared
on \monoespaco{window.h} with the code below:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern BOOL (__stdcall *wglChoosePixelFormatARB)(HDC, const int *, const FLOAT *,
                                                 UINT, int *, UINT *);
extern HGLRC (*wglCreateContextAttribsARB)(HDC, HGLRC, const int *);
#endif
@
\fimcodigo


We also place the real declaration on file \monoespaco{window.c}:

\iniciocodigo
@<Global Variables@>=
#if defined(_WIN32)
BOOL (__stdcall *wglChoosePixelFormatARB)(HDC, const int *, const FLOAT *, UINT,
                                          int *, UINT *);
HGLRC (*wglCreateContextAttribsARB)(HDC, HGLRC, const int *);
#endif
@
\fimcodigo

Once we have the pointers, we can initialize them loading and storing
in them the functions in which we are interested:

\iniciocodigo
@<Windows: Load Initial OpenGL Functions@>+=
wglChoosePixelFormatARB = (BOOL (__stdcall *)(HDC, const int *, const FLOAT *,
                                              UINT, int *, UINT *))
                          load_function("wglChoosePixelFormatARB");
if(wglChoosePixelFormatARB == NULL) return false;
wglCreateContextAttribsARB = (HGLRC (*)(HDC, HGLRC, const int *))
                               load_function("wglCreateContextAttribsARB");
if(wglCreateContextAttribsARB == NULL) return false;
@
\fimcodigo

And finally, after loading these two functions, we do not need anymore
the dummy window and context:

\iniciocodigo
@<Windows: Remove Dummy Context and Window@>=
wglMakeCurrent(dummy_device_context, 0);
wglDeleteContext(dummy_context);
ReleaseDC(dummy_window, dummy_device_context);
DestroyWindow(dummy_window);
@
\fimcodigo

Now we are ready to choose our pixel format (the OpenGL configuration)
in the modern way with our new function:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
{
  PIXELFORMATDESCRIPTOR pixel_format_descriptor;
  const int pixel_format_attributes[] = {
    WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
    WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
    WGL_DOUBLE_BUFFER_ARB, GL_TRUE,
    WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,
    WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
    WGL_COLOR_BITS_ARB, 32,
    WGL_DEPTH_BITS_ARB, 24,
    WGL_STENCIL_BITS_ARB, 8,
    0 };
  int pixel_format_index = 0;
  UINT number_of_formats = 0;
  if(!wglChoosePixelFormatARB(device_context, pixel_format_attributes, NULL, 1,
                              &pixel_format_index,
                              (UINT *) (&number_of_formats))){
#if defined(W_DEBUG_WINDOW)
     fprintf(stderr, "ERROR: 'wglChoosePixelFormatARB' failed.\n");
#endif
     return false;
  }
  if(number_of_formats == 0){
#if defined(W_DEBUG_WINDOW)
     fprintf(stderr,
             "ERROR: no pixel format returned by 'wglChoosePixelFormatARB'.\n");
#endif
     return false;
  }
  DescribePixelFormat(device_context, pixel_format_index,
                      sizeof(pixel_format_descriptor), &pixel_format_descriptor);
  if(!SetPixelFormat(device_context, pixel_format_index,
                     &pixel_format_descriptor)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'SetPixelFormat' failed.\n");
#endif
    return false;
  } 
}
@
\fimcodigo


Now we will specify that we want a context with OpenGL version
specified by two macros. And then use the funtion that creates a
modern OpenGL context:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
{
  const int opengl_attributes[] = {
    WGL_CONTEXT_MAJOR_VERSION_ARB, W_WINDOW_OPENGL_MAJOR_VERSION,
    WGL_CONTEXT_MINOR_VERSION_ARB, W_WINDOW_OPENGL_MINOR_VERSION,
    WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,
    0 };
  wgl_context = wglCreateContextAttribsARB(device_context, 0, opengl_attributes);
  if(wgl_context == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'wglCreateContextAttribsARB' failed.\n");
#endif
    return false;
  }
  if(!wglMakeCurrent(device_context, wgl_context)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'wglMakeCurrent' failed.\n");
#endif
    return false;
  }
}
@
\fimcodigo

While creating a real OpenGL context, we used some macros that are not
defined. As we use them locally, we declare them in the header of file
\monoespaco{window.c}:

\iniciocodigo
@<Headers@>+=
#define WGL_TYPE_RGBA_ARB                      0x202B
#define WGL_PIXEL_TYPE_ARB                     0x2013
#define WGL_COLOR_BITS_ARB                     0x2014
#define WGL_DEPTH_BITS_ARB                     0x2022
#define WGL_STENCIL_BITS_ARB                   0x2023
#define WGL_ACCELERATION_ARB                   0x2003
#define WGL_DOUBLE_BUFFER_ARB                  0x2011
#define WGL_CONTEXT_FLAGS_ARB                  0x2094
#define WGL_DRAW_TO_WINDOW_ARB                 0x2001
#define WGL_SUPPORT_OPENGL_ARB                 0x2010
#define WGL_FULL_ACCELERATION_ARB              0x2027
#define WGL_CONTEXT_MAJOR_VERSION_ARB          0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB          0x2092
#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x0002
@
\fimcodigo

But we want to support in our API the functions compatible with OpenGL
ES 2.0. Lots of such functions also are not part of the API presented
by WGL n Windows. What we need to do is load such functions as
extensions. For example, we start declaring the pointers for functions
related with shader creation and management:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLuint (__stdcall *glCreateShader)(GLenum shaderType);
extern void (__stdcall *glShaderSource)(GLuint, GLsizei, const GLchar *const*,
                                        const GLint *);
extern void (__stdcall *glCompileShader)(GLuint);
extern void (__stdcall *glReleaseShaderCompiler)(void);
extern void (__stdcall *glDeleteShader)(GLuint);
#endif
@
\fimcodigo

Next we position he pointers as global variables in our
file \monoespaco{window.c}:

\iniciocodigo
@<Global Variables@>=
#if defined(_WIN32)
GLuint (__stdcall *glCreateShader)(GLenum shaderType);
void (__stdcall *glShaderSource)(GLuint, GLsizei, const GLchar *const*,
                                 const GLint *);
void (__stdcall *glCompileShader)(GLuint);
void (__stdcall *glReleaseShaderCompiler)(void);
void (__stdcall *glDeleteShader)(GLuint);
#endif
@
\fimcodigo

Next we load for each of these pointers the corresponding function
using the function that we defined a little above, before all the
pointer declarations:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glCreateShader = (GLuint (__stdcall *)(GLenum)) load_function("glCreateShader");
if(glCreateShader == NULL)
  return false;
glShaderSource = (void (__stdcall *)(GLuint, GLsizei, const GLchar *const*,
                                     const GLint *))
                 load_function("glShaderSource");
if(glShaderSource == NULL)
  return false;
glCompileShader = (void (__stdcall *)(GLuint)) load_function("glCompileShader");
if(glCompileShader == NULL)
  return false;
glReleaseShaderCompiler = (void (__stdcall *)(void))
                             load_function("glReleaseShaderCompiler");
if(glReleaseShaderCompiler == NULL)
  return false;
glDeleteShader = (void (*)(GLuint)) load_function("glDeleteShader");
if(glDeleteShader == NULL)
  return false;
@
\fimcodigo

When we create a shader with \monoespaco{glCreateShader}, we need to
choose what kind of shader should be created passing one of the
following macros as argument:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_VERTEX_SHADER          0x8B31
#define GL_FRAGMENT_SHADER        0x8B30
#endif
@
\fimcodigo

The type \monoespaco{GLchar} also must be defined on Windows:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
typedef char GLchar;
#endif
@
\fimcodigo


After compiling a shader, usually the user wants to check if the
compilation was successful. This is done using functions that make
queries about shaders, \monoespaco{glGetShaderiv} in particular. We
define all functions related with queries about shaders here:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLboolean (__stdcall *glIsShader)(GLuint);
extern void (__stdcall *glGetShaderiv)(GLuint, GLenum, GLint *);
extern void (__stdcall *glGetAttachedShaders)(GLuint, GLsizei, GLsizei *,
                                              GLuint *);
extern void (__stdcall *glGetShaderInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
extern void (__stdcall *glGetShaderSource)(GLuint, GLsizei, GLsizei *, GLchar *);
extern void (__stdcall *glGetShaderPrecisionFormat)(GLenum, GLenum, GLint *,
                                                    GLint *);
extern void (__stdcall *glGetVertexAttribfv)(GLuint, GLenum, GLfloat *);
extern void (__stdcall *glGetVertexAttribiv)(GLuint, GLenum, GLint *);
extern void (__stdcall *glGetVertexAttribPointerv)(GLuint, GLenum, void **);
extern void (__stdcall *glGetUniformfv)(GLuint, GLint, GLfloat *);
extern void (__stdcall *glGetUniformiv)(GLuint, GLint, GLint *);
#endif
@
\fimcodigo

The pointers are positioned here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
GLboolean (__stdcall *glIsShader)(GLuint);
void (__stdcall *glGetShaderiv)(GLuint, GLenum, GLint *);
void (__stdcall *glGetAttachedShaders)(GLuint, GLsizei, GLsizei *, GLuint *);
void (__stdcall *glGetShaderInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
void (__stdcall *glGetShaderSource)(GLuint, GLsizei, GLsizei *, GLchar *);
void (__stdcall *glGetShaderPrecisionFormat)(GLenum, GLenum, GLint *, GLint *);
void (__stdcall *glGetVertexAttribfv)(GLuint, GLenum, GLfloat *);
void (__stdcall *glGetVertexAttribiv)(GLuint, GLenum, GLint *);
void (__stdcall *glGetVertexAttribPointerv)(GLuint, GLenum, void **);
void (__stdcall *glGetUniformfv)(GLuint, GLint, GLfloat *);
void (__stdcall *glGetUniformiv)(GLuint, GLint, GLint *);
#endif
@
\fimcodigo

Each function is loaded to its respective pointer with:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glIsShader = (GLboolean (__stdcall *)(GLuint)) load_function("glIsShader");
if(glIsShader == NULL) return false;
glGetShaderiv = (void (__stdcall *)(GLuint, GLenum, GLint *))
                   load_function("glGetShaderiv");
if(glGetShaderiv == NULL) return false;
glGetAttachedShaders = (void (__stdcall *)(GLuint, GLsizei, GLsizei *, GLuint *))
                         load_function("glGetAttachedShaders");
if(glGetAttachedShaders == NULL) return false;
glGetShaderInfoLog = (void (__stdcall *)(GLuint, GLsizei, GLsizei *, GLchar *))
                         load_function("glGetShaderInfoLog");
if(glGetShaderInfoLog == NULL)  return false;
glGetShaderSource = (void (__stdcall *)(GLuint, GLsizei, GLsizei *, GLchar *))
                       load_function("glGetShaderSource");
if(glGetShaderSource == NULL) return false;
glGetShaderPrecisionFormat = (void (__stdcall *)(GLenum, GLenum, GLint *,
                                                 GLint *))
                                load_function("glGetShaderPrecisionFormat");
if(glGetShaderPrecisionFormat == NULL) return false;
glGetVertexAttribfv = (void (__stdcall *)(GLuint, GLenum, GLfloat *))
                         load_function("glGetVertexAttribfv");
if(glGetVertexAttribfv == NULL) return false;
glGetVertexAttribiv = (void (__stdcall *)(GLuint, GLenum, GLint *))
                        load_function("glGetVertexAttribiv");
if(glGetVertexAttribiv == NULL) return false;
glGetVertexAttribPointerv = (void (__stdcall *)(GLuint, GLenum, void **))
                               load_function("glGetVertexAttribPointerv");
if(glGetVertexAttribPointerv == NULL) return false;
glGetUniformfv = (void (__stdcall *)(GLuint, GLint, GLfloat *))
                     load_function("glGetUniformfv");
if(glGetUniformfv == NULL) return false;
glGetUniformiv = (void (__stdcall *)(GLuint, GLint, GLint *))
                     load_function("glGetUniformiv");
if(glGetUniformiv == NULL) return false;
@
\fimcodigo

When the function \monoespaco{glGetShaderiv} is used, we can select
which information about the shader we want to know passing one of the
following macros:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_SHADER_TYPE          0x8B4F
#define GL_DELETE_STATUS        0x8B80
#define GL_COMPILE_STATUS       0x8B81
#define GL_INFO_LOG_LENGTH      0x8B84
#define GL_SHADER_SOURCE_LENGTH 0x8B88
#endif
@
\fimcodigo

When the function \monoespaco{glGetShaderPrecisionFormat} is used to
check for the precision of a given type, the chosen type is defined
passing one of these macros:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_LOW_FLOAT    0x8DF0
#define GL_MEDIUM_FLOAT 0x8DF1
#define GL_HIGH_FLOAT   0x8DF2
#define GL_LOW_INT      0x8DF3
#define GL_MEDIUM_INT   0x8DF4
#define GL_HIGH_INT     0x8DF5
#endif
@
\fimcodigo

When the function \monoespaco{glGetVertexAttribfv}
or \monoespaco{glGetVertexAttribiv} are used to obtain information
about vertices, the wanted information is informed passing as argument
one of the following macros:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED        0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE           0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE         0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE           0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED     0x886A
#define GL_CURRENT_VERTEX_ATTRIB              0x8626
#endif
@
\fimcodigo

When using function \monoespaco{glGetVertexzAttribPointerv}, we must
pass as one of the arguments the following macro:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
#endif
@
\fimcodigo

Let's also define this macro that is useful to query about which GLSL
implementation we have:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
#endif
@
\fimcodigo

Once the user created and compiled shaders, usually she would need to
create a program and link the shaders to the program. To enable this,
we declare below the pointer for all functions about program
management:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLuint (__stdcall *glCreateProgram)(void);
extern void (__stdcall *glAttachShader)(GLuint, GLuint);
extern void (__stdcall *glDetachShader)(GLuint, GLuint);
extern void (__stdcall *glLinkProgram)(GLuint);
extern void (__stdcall *glUseProgram)(GLuint);
extern void (__stdcall *glDeleteProgram)(GLuint);
#endif
@
\fimcodigo

These declared ponters are effectively positioned here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
GLuint (__stdcall *glCreateProgram)(void);
void (__stdcall *glAttachShader)(GLuint, GLuint);
void (__stdcall *glDetachShader)(GLuint, GLuint);
void (__stdcall *glLinkProgram)(GLuint);
void (__stdcall *glUseProgram)(GLuint);
void (__stdcall *glDeleteProgram)(GLuint);
#endif
@
\fimcodigo

And we initialize them with the correct functions:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glCreateProgram = (GLuint (__stdcall *)(void)) load_function("glCreateProgram");
if(glCreateProgram == NULL) return false;
glAttachShader = (void (__stdcall *)(GLuint, GLuint))
                  load_function("glAttachShader");
if(glAttachShader == NULL) return false;
glDetachShader = (void (__stdcall *)(GLuint, GLuint))
                 load_function("glDetachShader");
if(glDetachShader == NULL) return false;
glLinkProgram = (void (__stdcall *)(GLuint)) load_function("glLinkProgram");
if(glLinkProgram == NULL) return false;
glUseProgram = (void (__stdcall *)(GLuint)) load_function("glUseProgram");
if(glUseProgram == NULL) return false;
glDeleteProgram = (void (__stdcall *)(GLuint)) load_function("glDeleteProgram");
if(glDeleteProgram == NULL) return false;
@
\fimcodigo

After finishing the program creation, usually the user wants to know
if it was successful.  For this, we need to prepare the pointers for
functions that deal with program queries:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLboolean (__stdcall *glIsProgram)(GLuint);
extern void (__stdcall *glGetProgramiv)(GLuint, GLenum, GLint *);
extern void (__stdcall *glGetProgramInfoLog)(GLuint, GLsizei, GLsizei *,
                                             GLchar *);
extern void (__stdcall *glValidadeProgram)(GLuint);
#endif
@
\fimcodigo

We place the real pointers here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
GLboolean (__stdcall *glIsProgram)(GLuint);
void (__stdcall *glGetProgramiv)(GLuint, GLenum, GLint *);
void (__stdcall *glGetProgramInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
void (__stdcall *glValidadeProgram)(GLuint);
#endif
@
\fimcodigo

And we initialize them with the real functions:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glIsProgram = (GLboolean (__stdcall *)(GLuint)) load_function("glIsProgram");
if(glIsProgram == NULL) return false;
glGetProgramiv = (void (__stdcall *)(GLuint, GLenum, GLint *))
                    load_function("glGetProgramiv");
if(glGetProgramiv == NULL) return false;
glGetProgramInfoLog = (void (__stdcall *)(GLuint, GLsizei, GLsizei *, GLchar *))
                          load_function("glGetProgramInfoLog");
if(glGetProgramInfoLog == NULL) return false;
glValidadeProgram = (void (__stdcall *)(GLuint))
                     load_function("glValidateProgram");
if(glValidadeProgram == NULL) return false;
@
\fimcodigo

When we use \monoespaco{glGetProgramiv} to obtain information about a
program, we pass one of the following macros as argument to select
which information we want to know:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_DELETE_STATUS               0x8B80
#define GL_LINK_STATUS                 0x8B82
#define GL_VALIDATE_STATUS             0x8B83
#define GL_INFO_LOG_LENGTH             0x8B84
#define GL_ATTACHED_SHADERS            0x8B85
#define GL_ACTIVE_ATTRIBUTES           0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
#define GL_ACTIVE_UNIFORMS             0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH   0x8B87
#endif
@
\fimcodigo

To obtain and set vertices attributes in a shader, we can use
functions that will be associated with the following pointers:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern void (__stdcall *glGetActiveAttrib)(GLuint, GLuint, GLsizei, GLsizei *,
                                           GLint *, GLenum *, GLchar *);
extern GLint (__stdcall *glGetAttribLocation)(GLuint, const GLchar *);
extern void (__stdcall *glBindAttribLocation)(GLuint, GLuint, const GLchar *);
#endif
@
\fimcodigo

The pointers are positioned here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
void (__stdcall *glGetActiveAttrib)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                                    GLenum *, GLchar *;)
GLint (__stdcall *glGetAttribLocation)(GLuint, const GLchar *);
void (__stdcall *glBindAttribLocation)(GLuint, GLuint, const GLchar *);
#endif
@
\fimcodigo

And they are initialized here:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glGetActiveAttrib = (void (__stdcall *)(GLuint, GLuint, GLsizei, GLsizei *,
                                        GLint *, GLenum *, GLchar *))
                    load_function("glGetActiveAttrib");
if(glGetActiveAttrib == NULL) return false;
glGetAttribLocation = (GLint (__stdcall *)(GLuint, const GLchar *))
                           load_function("glGetAttribLocation");
if(glGetAttribLocation == NULL) return false;
glBindAttribLocation = (void (__stdcall *)(GLuint, GLuint, const GLchar *))
                              load_function("glBindAttribLocation");
if(glBindAttribLocation == NULL) return false;
@
\fimcodigo

The type of each vertex attribute returned
by \monoespaco{glGetActiveAttrib} can be:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_FLOAT      0x1406
#define GL_FLOAT_VEC2 0x8B50
#define GL_FLOAT_VEC3 0x8B51
#define GL_FLOAT_VEC4 0x8B52
#define GL_FLOAT_MAT2 0x8B5A
#define GL_FLOAT_MAT3 0x8B5B
#define GL_FLOAT_MAT4 0x8B5C
#endif
@
\fimcodigo

And finally, the last functions related with shaders are the ones
responsible to deal with uniform variables:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLint (__stdcall *glGetUniformLocation)(GLuint, const GLchar *);
extern void (__stdcall *glGetActiveUniform)(GLuint, GLuint, GLsizei, GLsizei *,
                                            GLint *, GLenum *, GLchar *);
extern void (__stdcall *glUniform1f)(GLint, GLfloat);
extern void (__stdcall *glUniform2f)(GLint, GLfloat, GLfloat);
extern void (__stdcall *glUniform3f)(GLint, GLfloat, GLfloat, GLfloat);
extern void (__stdcall *glUniform4f)(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
extern void (__stdcall *glUniform1i)(GLint, GLint);
extern void (__stdcall *glUniform2i)(GLint, GLint, GLint);
extern void (__stdcall *glUniform3i)(GLint, GLint, GLint, GLint);
extern void (__stdcall *glUniform4i)(GLint, GLint, GLint, GLint, GLint);
extern void (__stdcall *glUniform1fv)(GLint, GLsizei, const GLfloat *);
extern void (__stdcall *glUniform2fv)(GLint, GLsizei, const GLfloat *);
extern void (__stdcall *glUniform3fv)(GLint, GLsizei, const GLfloat *);
extern void (__stdcall *glUniform4fv)(GLint, GLsizei, const GLfloat *);
extern void (__stdcall *glUniform1iv)(GLint, GLsizei, const GLint *);
extern void (__stdcall *glUniform2iv)(GLint, GLsizei, const GLint *);
extern void (__stdcall *glUniform3iv)(GLint, GLsizei, const GLint *);
extern void (__stdcall *glUniform4iv)(GLint, GLsizei, const GLint *);
extern void (__stdcall *glUniformMatrix2fv)(GLint, GLsizei, GLboolean,
                                            const GLfloat *);
extern void (__stdcall *glUniformMatrix3fv)(GLint, GLsizei, GLboolean,
                                            const GLfloat *);
extern void (__stdcall *glUniformMatrix4fv)(GLint, GLsizei, GLboolean,
                                            const GLfloat *);
#endif
@
\fimcodigo

These 21 pointers are positioned here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
GLint (__stdcall *glGetUniformLocation)(GLuint, const GLchar *);
void (__stdcall *glGetActiveUniform)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                                     GLenum *, GLchar *);
void (__stdcall *glUniform1f)(GLint, GLfloat);
void (__stdcall *glUniform2f)(GLint, GLfloat, GLfloat);
void (__stdcall *glUniform3f)(GLint, GLfloat, GLfloat, GLfloat);
void (__stdcall *glUniform4f)(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
void (__stdcall *glUniform1i)(GLint, GLint);
void (__stdcall *glUniform2i)(GLint, GLint, GLint);
void (__stdcall *glUniform3i)(GLint, GLint, GLint, GLint);
void (__stdcall *glUniform4i)(GLint, GLint, GLint, GLint, GLint);
void (__stdcall *glUniform1fv)(GLint, GLsizei, const GLfloat *);
void (__stdcall *glUniform2fv)(GLint, GLsizei, const GLfloat *);
void (__stdcall *glUniform3fv)(GLint, GLsizei, const GLfloat *);
void (__stdcall *glUniform4fv)(GLint, GLsizei, const GLfloat *);
void (__stdcall *glUniform1iv)(GLint, GLsizei, const GLint *);
void (__stdcall *glUniform2iv)(GLint, GLsizei, const GLint *);
void (__stdcall *glUniform3iv)(GLint, GLsizei, const GLint *);
void (__stdcall *glUniform4iv)(GLint, GLsizei, const GLint *);
void (__stdcall *glUniformMatrix2fv)(GLint, GLsizei, GLboolean, const GLfloat *);
void (__stdcall *glUniformMatrix3fv)(GLint, GLsizei, GLboolean, const GLfloat *);
void (__stdcall *glUniformMatrix4fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#endif
@
\fimcodigo

And now we need to initialize all these 21 pointers:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glGetUniformLocation = (GLint (__stdcall *)(GLuint, const GLchar *))
                            load_function("glGetUniformLocation");
if(glGetUniformLocation == NULL) return false;
glGetActiveUniform = (void (__stdcall *)(GLuint, GLuint, GLsizei, GLsizei *,
                                         GLint *, GLenum *, GLchar *))
                      load_function("glGetActiveUniform");
if(glGetActiveUniform == NULL) return false;
glUniform1f = (void (__stdcall *)(GLint, GLfloat)) load_function("glUniform1f");
if(glUniform1f == NULL) return false;
glUniform2f = (void (__stdcall *)(GLint, GLfloat, GLfloat))
               load_function("glUniform2f");
if(glUniform2f == NULL) return false;
glUniform3f = (void (__stdcall *)(GLint, GLfloat, GLfloat, GLfloat))
                        load_function("glUniform3f");
if(glUniform3f == NULL) return false;
glUniform4f = (void (__stdcall *)(GLint, GLfloat, GLfloat, GLfloat, GLfloat))
                        load_function("glUniform4f");
if(glUniform4f == NULL) return false;
glUniform1i = (void (__stdcall *)(GLint, GLint)) load_function("glUniform1i");
if(glUniform1i == NULL) return false;
glUniform2i = (void (__stdcall *)(GLint, GLint, GLint))
               load_function("glUniform2i");
if(glUniform2i == NULL) return false;
glUniform3i = (void (__stdcall *)(GLint, GLint, GLint, GLint))
               load_function("glUniform3i");
if(glUniform3i == NULL) return false;
glUniform4i = (void (__stdcall *)(GLint, GLint, GLint, GLint, GLint))
                 load_function("glUniform4i");
if(glUniform4i == NULL) return false;
glUniform1fv = (void (__stdcall *)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform1fv");
if(glUniform1fv == NULL) return false;
glUniform2fv = (void (__stdcall *)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform2fv");
if(glUniform2fv == NULL) return false;
glUniform3fv = (void (__stdcall *)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform3fv");
if(glUniform3fv == NULL) return false;
glUniform4fv = (void (__stdcall *)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform4fv");
if(glUniform4fv == NULL) return false;
glUniform1iv = (void (__stdcall *)(GLint, GLsizei, const GLint *))
                 load_function("glUniform1iv");
if(glUniform1iv == NULL) return false;
glUniform2iv = (void (__stdcall *)(GLint, GLsizei, const GLint *))
                 load_function("glUniform2iv");
if(glUniform2iv == NULL) return false;
glUniform3iv = (void (__stdcall *)(GLint, GLsizei, const GLint *))
                 load_function("glUniform3iv");
if(glUniform3iv == NULL) return false;
glUniform4iv = (void (__stdcall *)(GLint, GLsizei, const GLint *))
                 load_function("glUniform4iv");
if(glUniform4iv == NULL) return false;
glUniformMatrix2fv = (void (__stdcall *)(GLint, GLsizei, GLboolean,
                                         const GLfloat *))
                      load_function("glUniformMatrix2fv");
if(glUniformMatrix2fv == NULL) return false;
glUniformMatrix3fv = (void (__stdcall *)(GLint, GLsizei, GLboolean,
                                         const GLfloat *))
                      load_function("glUniformMatrix3fv");
if(glUniformMatrix3fv == NULL) return false;
glUniformMatrix4fv = (void (__stdcall *)(GLint, GLsizei, GLboolean,
                                         const GLfloat *))
                      load_function("glUniformMatrix4fv");
if(glUniformMatrix4fv == NULL) return false;
@
\fimcodigo

The uniform variables can have the same types than vertex attributes
and also these new types:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_INT         0x1404
#define GL_INT_VEC2    0x8B53
#define GL_INT_VEC3    0x8B54
#define GL_INT_VEC4    0x8B55
#define GL_BOOL        0x8B56
#define GL_BOOL_VEC2   0x8B57
#define GL_BOOL_VEC3   0x8B58
#define GL_BOOL_VEC4   0x8B59
#define GL_SAMPLER_2D  0x8B5E
#define GL_SAMPER_CUBE 0x8B60
#endif
@
\fimcodigo

The last thing necessary to render simple images is send vertices to
the video card. One of the ways to do this is sending a pointer
instead of the entire vertex list. This can be done using the
following functions related to vertices:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern void (__stdcall *glVertexAttrib1f)(GLuint, GLfloat);
extern void (__stdcall *glVertexAttrib2f)(GLuint, GLfloat, GLfloat);
extern void (__stdcall *glVertexAttrib3f)(GLuint, GLfloat, GLfloat, GLfloat);
extern void (__stdcall *glVertexAttrib4f)(GLuint, GLfloat, GLfloat, GLfloat,
                                          GLfloat);
extern void (__stdcall *glVertexAttrib1fv)(GLuint, GLfloat *);
extern void (__stdcall *glVertexAttrib2fv)(GLuint, GLfloat *);
extern void (__stdcall *glVertexAttrib3fv)(GLuint, GLfloat *);
extern void (__stdcall *glVertexAttrib4fv)(GLuint, GLfloat *);
extern void (__stdcall *glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean,
                                               GLsizei, const void *);
extern void (__stdcall *glEnableVertexAttribArray)(GLuint);
extern void (__stdcall *glDisableVertexAttribArray)(GLuint);
#endif

\fimcodigo

These pointers are positioned as global variables:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
void (__stdcall *glVertexAttrib1f)(GLuint, GLfloat);
void (__stdcall *glVertexAttrib2f)(GLuint, GLfloat, GLfloat);
void (__stdcall *glVertexAttrib3f)(GLuint, GLfloat, GLfloat, GLfloat);
void (__stdcall *glVertexAttrib4f)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
void (__stdcall *glVertexAttrib1fv)(GLuint, GLfloat *);
void (__stdcall *glVertexAttrib2fv)(GLuint, GLfloat *);
void (__stdcall *glVertexAttrib3fv)(GLuint, GLfloat *);
void (__stdcall *glVertexAttrib4fv)(GLuint, GLfloat *);
void (__stdcall *glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean,
                                        GLsizei, const void *);
void (__stdcall *glEnableVertexAttribArray)(GLuint);
void (__stdcall *glDisableVertexAttribArray)(GLuint);
#endif
@
\fimcodigo

And initialize them:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glVertexAttrib1f = (void (__stdcall *)(GLuint, GLfloat))
                    load_function("glVertexAttrib1f");
if(glVertexAttrib1f == NULL) return false;
glVertexAttrib2f = (void (__stdcall *)(GLuint, GLfloat, GLfloat))
                      load_function("glVertexAttrib2f");
if(glVertexAttrib2f == NULL) return false;
glVertexAttrib3f = (void (__stdcall *)(GLuint, GLfloat, GLfloat, GLfloat))
                      load_function("glVertexAttrib3f");
if(glVertexAttrib3f == NULL) return false;
glVertexAttrib4f = (void (__stdcall *)(GLuint, GLfloat, GLfloat, GLfloat,
                                       GLfloat))
                    load_function("glVertexAttrib4f");
if(glVertexAttrib4f == NULL) return false;
glVertexAttrib1fv = (void (__stdcall *)(GLuint, GLfloat *))
                       load_function("glVertexAttrib1fv");
if(glVertexAttrib1fv == NULL) return false;
glVertexAttrib2fv = (void (__stdcall *)(GLuint, GLfloat *))
                       load_function("glVertexAttrib2fv");
if(glVertexAttrib2fv == NULL) return false;
glVertexAttrib3fv = (void (__stdcall *)(GLuint, GLfloat *))
                       load_function("glVertexAttrib3fv");
if(glVertexAttrib3fv == NULL) return false;
glVertexAttrib4fv = (void (__stdcall *)(GLuint, GLfloat *))
                       load_function("glVertexAttrib4fv");
if(glVertexAttrib4fv == NULL) return false;
glVertexAttribPointer = (void (__stdcall *)(GLuint, GLint, GLenum, GLboolean,
                         GLsizei, const void *))
                              load_function("glVertexAttribPointer");
if(glVertexAttribPointer == NULL) return false;
glEnableVertexAttribArray = (void (__stdcall *)(GLuint))
                              load_function("glEnableVertexAttribArray");
if(glEnableVertexAttribArray == NULL) return false;
glDisableVertexAttribArray = (void (__stdcall *)(GLuint))
                               load_function("glDisableVertexAttribArray");
if(glDisableVertexAttribArray == NULL) return false;
@
\fimcodigo

And besides the types that are already defined, we also need to define
the following type for vertex attributes:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_FIXED          0x140C
#endif
@
\fimcodigo

Now we will define the pointers for functions related to buffer
objects. The pointers are:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern void (__stdcall *glGenBuffers)(GLsizei, GLuint *);
extern void (__stdcall *glDeleteBuffers)(GLsizei, const GLuint *);
extern void (__stdcall *glBindBuffer)(GLenum, GLuint);
extern void (__stdcall *glBufferData)(GLenum, GLsizeiptr, const void *, GLenum);
extern void (__stdcall *glBufferSubData)(GLenum, GLintptr, GLsizeiptr,
                                         const void *);
extern void (__stdcall *glIsBuffer)(GLuint);
extern void (__stdcall *glGetBufferParameteriv)(GLenum, GLenum, GLint *);
#endif
@
\fimcodigo

And the declarations:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
void (__stdcall *glGenBuffers)(GLsizei, GLuint *);
void (__stdcall *glDeleteBuffers)(GLsizei, const GLuint *);
void (__stdcall *glBindBuffer)(GLenum, GLuint);
void (__stdcall *glBufferData)(GLenum, GLsizeiptr, const void *, GLenum);
void (__stdcall *glBufferSubData)(GLenum, GLintptr, GLsizeiptr, const void *);
void (__stdcall *glIsBuffer)(GLuint);
void (__stdcall *glGetBufferParameteriv)(GLenum, GLenum, GLint *);
#endif
@
\fimcodigo

And the initialization:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glGenBuffers = (void (__stdcall *)(GLsizei, GLuint *))
                 load_function("glGenBuffers");
if(glGenBuffers == NULL) return false;
glDeleteBuffers = (void (__stdcall *)(GLsizei, const GLuint *))
                    load_function("glDeleteBuffers");
if(glDeleteBuffers == NULL) return false;
glBindBuffer = (void (__stdcall *)(GLenum, GLuint))load_function("glBindBuffer");
if(glBindBuffer == NULL) return false;
glBufferData = (void (__stdcall *)(GLenum, GLsizeiptr, const void *, GLenum))
                 load_function("glBufferData");
if(glBufferData == NULL) return false;
glBufferSubData = (void (__stdcall *)(GLenum, GLintptr, GLsizeiptr, const void *))
                    load_function("glBufferSubData");
if(glBufferSubData == NULL) return false;
glIsBuffer = (void (__stdcall *)(GLuint)) load_function("glIsBuffer");
if(glIsBuffer == NULL) return false;
glGetBufferParameteriv = (void (__stdcall *)(GLenum, GLenum, GLint *))
                           load_function("glGetBufferParameteriv");
if(glGetBufferParameteriv == NULL) return false;
@
\fimcodigo

When we bind a buffer with \monoespaco{glBindBuffer}, it can have one
of the following types:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_ARRAY_BUFFER         0x8892
#define GL_ELEMENT_ARRAY_BUFFER 0x8893
#endif
@
\fimcodigo

When we pass data to a buffer with \monoespaco{glBufferData}, we can
choose between the following usages for the data:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_STATIC_DRAW  0x88E4
#define GL_STREAM_DRAW  0x88E0
#define GL_DYNAMIC_DRAW 0x88E8
#endif
@
\fimcodigo

When we ask information about a buffer
with \monoespaco{glGetBufferParameteriv}, we can ask for the following
data:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_BUFFER_SIZE  0x8764
#define GL_BUFFER_USAGE 0x8765
#endif
@
\fimcodigo

\subsubsecao{2.3.4. Choosing OpenGL Version}

In the previously defined code, in all environments. we choosed the
OpenGL version according with the following two macros:

1) \monoespaco{W\_WINDOW\_OPENGL\_MAJOR\_VERSION}

2) \monoespaco{W\_WINDOW\_OPENGL\_MINOR\_VERSION}

We will now define what these macros values will be if the user did
not personalized them to some valuye.





\subsecao{2.6. Window Creation Function}

Our function that creates a new window will execute the adequate code,
depending on the graphical environment where termosit is being
executed. But before this we will add code to check if a window
already was created. This information will be stored in a boolean
variable:

There is one last thing to define about the window creation, more
specifically about the OpenL context associated with the created
window. We need to choose a default OpenGL version to load when the
user do not set her own value.

When we are running in X11, we can use EGL to create an OpenGL ES
context. In this case, we prefer version 3.0, as is the newer version
that also supports all OpenGL ES 2.0 resources.

If we are running in a browser using Web Assembly, we want to use
WebGL 2, as this version is equivalent to OpenGL Es 3.0.

If we are running on Windows, not all drivers and hardware support
OpenGL ES API. Because of this, we choose to use OpenGL 4.0, as this
is a more common version that support the modern OpenGL functions used
by OpenGL ES.

Our macro that sets the OpenGL version, because of this, is:

\iniciocodigo
@<Headers@>+=
#if defined(_WIN32) && !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 4
#define W_WINDOW_OPENGL_MINOR_VERSION 1
#elif defined(__EMSCRIPTEN__) && !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 2
#define W_WINDOW_OPENGL_MINOR_VERSION 0
#elif !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 3
#define W_WINDOW_OPENGL_MINOR_VERSION 0
#endif
@
\fimcodigo

\subsecao{2.4. Closing a Window}

Closing a window makes the window disappear and also finalizes any
data initialized during window creation. This includes the OpenGL
context.

\subsubsecao{2.4.1. Closing a Window on X11}

Closing a window in X11 means calling the function that asks the
server to close the window and also closing the connection with the
server. This is done calling respectively \monoespaco{XDestroyWindow}
and \monoespaco{XCloseDisplay}. We also check if we really have an
existing window before trying to close and destroy it.

\iniciocodigo
@<API Functions@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                 EGL_NO_CONTEXT );
  eglDestroySurface(egl_display, egl_window);
  eglDestroyContext(egl_display, egl_context);
  eglTerminate(egl_display);
  XDestroyWindow(display, window);
  XCloseDisplay(display);
  display = NULL;
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsubsecao{2.4.2. Closing a Window in Web Assembly}

Closing a window when running in a web browser means finalize the SDL
structures and hide the canvas where we were drawing. We do this with
the following function:

\iniciocodigo
@<API Functions@>+=
#if defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  SDL_FreeSurface(window);
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "none";
    document.exitFullscreen();
  );
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.4.3. Closing a Window on Windows}

Closing a window in Windows means calling a function to destroy the
window:

\iniciocodigo
@<API Functions@>+=
#if defined(_WIN32)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  wglMakeCurrent(NULL, NULL);
  wglDeleteContext(wgl_context);
  DestroyWindow(window);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.5. Rendering the Window}

In a graphical program, usually we have some main loop and in this
loop, we call some function that draws in our window. This means
asking to update the window after making OpenGL calls to draw. How we
do this depends on our environment and API.

\subsecao{2.5.1. Rendering window in X} 

In X, when we asked EGL to create a window, by default it creates a
double buffered window. Rendering in the screen means in this case to
swap the window buffers. The back buffer where we were drawing became
the front buffer, what is shown in the screen, and vice-versa. This is
achieved with the following code:

\iniciocodigo
@<API Functions@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wrender_window(void){
  return eglSwapBuffers(egl_display, egl_window);
}
#endif
@
\fimcodigo

\subsecao{2.5.2. Rendering window in Emscripten}

The function \monoespaco{emscripten\_sleep} is what makes the window
update in a main loop. However, using it is a bad practice. In Web
Assembly, programs should not run in an infinite loop, but a function
should be registered to be executed over and over again instead of a
more usual infinite loop. When we register a function this way, we do
not need to use any additional function to ask to update our
window. Therefore, in the following code we use only a flush command
to ensure that all OpenGL calls are sent. But we do not need to make
anything to update the screen, assuming that the program do not follow
a bad practice:

\iniciocodigo
@<API Functions@>+=
#if defined(__EMSCRIPTEN__)
bool _Wrender_window(void){
  glFlush();
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.5.3. Rendering window in (Microsoft) Windows}

In Windows, the WGL function responsible for swapping buffers in the
window making our drawings visible is
called \monoespaco{wglSwapLayerBuffers}:

\iniciocodigo
@<API Functions@>+=
#if defined(_WIN32)
bool _Wrender_window(void){
  return wglSwapLayerBuffers(device_context, WGL_SWAP_MAIN_PLANE);
}
#endif
@
\fimcodigo

\subsecao{2.6. Getting Window Size}

Next we will define the function that stores in pointers passed as
aguments the size of our current window.

\subsubsecao{2.6.1. Getting Window Size on X}

In X11, the Xlib API gives us the function \monoespaco{XGetGeometry}
that gets information about some window or pixmap (image). This
function returns a lot of information that we are not interested. But
also returns the window width and height that we need:

\iniciocodigo
@<API Functions@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wget_window_size(int *width, int *height){
  Window root_window;
  int x, y;
  unsigned int border, depth;
  if(!already_have_window || display == NULL){
    *width = 0;
    *height = 0;
    return false;
  }
  XGetGeometry(display, window, &root_window, &x, &y,
               (unsigned int *) width, (unsigned int *) height, &border, &depth);
  return true;
}
#endif
@
\fimcodigo

\subsubsecao{2.6.2. Getting Window Size on Web Assembly}

In a web browser, we do not have a window, but a canvas. By
convention, the canvas that we use as a window have the ID
``canvas''. If we want to know its size, we need to use Javascript to
get the canvas and obtain its width and height.

\iniciocodigo
@<API Functions@>+=
#if defined(__EMSCRIPTEN__)
bool _Wget_window_size(int *width, int *height){
  if(!already_have_window){
    *width = 0;
    *height = 0;
    return false;
  }
  *width = EM_ASM_INT({
    return document.getElementById("canvas").clientWidth;
  });
  *height = EM_ASM_INT({
    return document.getElementById("canvas").clientHeight;
  });
  if(*width > 0 && *height > 0)
    return true;
  else{
    *width = 0;
    *height = 0;
    return false;
  }
}
#endif
@
\fimcodigo

\subsubsecao{2.6.3. Getting Window Size on Windows}

On Windows we use a call to \monoespaco{GetWindowRect} to obtain the
window size. Which is stored in a \monoespaco{RECT} structure:

\iniciocodigo
@<API Functions@>+=
#if defined(_WIN32)
bool _Wget_window_size(int *width, int *height){
  BOOL ret;
  RECT rectangle;
  ret = GetWindowRect(window, &rectangle);
  if(ret){
    *width = rectangle.right - rectangle.left;
    *height = rectangle.bottom - rectangle.top;
    return true;
  }
  else{
    *width = 0;
    *height = 0;
    return false;
  }
}
#endif
@
\fimcodigo

\secao{3. Managing Input}

In this section we will deal with input detection. As when the user
presses a key or moves the mouse.

\subsecao{3.1. Defining the Keyboard and Mouse}

When we have a window, we can detect inputs made by the user when that
window has focus. We can detect events made by the keyboard and mouse.

For us the keyboard will be the following global struct variable:

\iniciocodigo
@<Window Declarations@>+=
struct __Wkeyboard{
  long key[W_KEYBOARD_SIZE]; // Key array: a timer for each key
} _Wkeyboard;
@
\fimcodigo

In the key aray above, we will have one position for each keyboard key
where we will store a number to act as a timer for each key. The
meaning of the number stored in each position depends on the
value. The options are:

1) If we store zero, this means that the key is not being pressed.

2) If we store 1, this means that the key started to being pressed now.

3) If the number is positive and greater than 1, this means that the
key is being pressed and still was not released. The number represents
for how long the key is being pressed in some unit of time.

4) If the number is negative, this means that the key was released
now. And the opposite of such number means for how long the key was
pressed before being released in some unit of time.

The number of keys depends on the operating system and environment. We
will define it later.

The mouse will be represented by the following global struct variable:

\iniciocodigo
@<Window Declarations@>+=
struct __Wmouse{
  long buttons[W_MOUSE_SIZE];
  int x, y, dx, dy, ddx, ddy;
} _Wmouse;
@
\fimcodigo

The buttons follow the same convention than the keys in a keyboars. We
can detect if a button is pressed, for how long it is being pressed,
if the button was released and for how long the button was pressed
before being released.

The variables \monoespaco{x} and \monoespaco{y} represent the pointer
position in pixels from our window. The variables \monoespaco{dx}
and \monoespaco{dy} represent the pointer speed in pixels per unit of
time. The variables \monoespaco{ddx} and \monoespaco{ddy} represent
the pointer acceleration in pixels per unit of time squared.

Given these structs, we need to periodically call the following
function to update them:

\iniciocodigo
@<API Functions@>+=
void _Wget_window_input(unsigned long current_time){
  if(already_have_window == false)
    return;
  @<Before Reading Window Events@>
  @<Get Window Events@>
  @<After Reading Window Events@>
}
@
\fimcodigo

This function works reading in a loop the list of events received by
the window and then updating the mouse and keyboard structs. For
example, on X11, the reading of events is done this way:

\iniciocodigo
@<Get Window Events@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XEvent event;
while(XPending(display)){
  XNextEvent(display, &event);
  @<X11: Manage Events@>
}
#endif
@
\fimcodigo

If we are in a Web Assembly environment, we use SDL API to read the
events:

\iniciocodigo
@<Get Window Events@>+=
#if defined(__EMSCRIPTEN__)
SDL_Event event;
while(SDL_PollEvent(&event)){
  @<Web Assembly: Manage Events@>
}
#endif
@
\fimcodigo

On Windows the events are called ``messages''. And we read them in the
following way:

\iniciocodigo
@<Get Window Events@>+=
#if defined(_WIN32)
MSG event;
while(PeekMessage(&event, window, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE)){
  @<Windows: Manage Keyboard Events@>
}
while(PeekMessage(&event, window, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE)){
  //@<Windows: Manage Mouse Events@>
}
#endif
@
\fimcodigo

In the Windows case we can filter the events and then we can treat
separatelly the mouse and keyboard events, ignoring all others.

\subsecao{3.2. Reading the Keyboard}

Here we define how we monitor the keyboard on different environments
to update the keyboard structure.

The events in all environments will warn when a key is pressed or
released. But they will not say nothing about for how long they were
pressed. We need to store and deduce this information. For this, we
will need an array of keys being pressed and released at the present
time. In the event loop we just update this array:

\iniciocodigo
@<Local Variables@>=
static struct{
  unsigned key; // Which key was pressed?
  long time;    // When it was pressed?
} pressed_keys[32];
unsigned released_keys[32]; // Which keys were released?
@
\fimcodigo

As a part of the keyboard initialization, and also to reset its
status, we should call the code below that sets to empty our list of
pressed and released keys. This sets the list as empty because we will
treat the first occurrence of key zero in such list as the end of the
list. Exactly as we use the null character to mark the end of a string.

\iniciocodigo
@<Flushing List of Pressed and Released Keys@>=
{
  int i;
  for(i = 0; i < 32; i ++){
    pressed_keys[i].key = 0;
    released_keys[i] = 0;
  }
}
@
\fimcodigo

\subsubsecao{3.2.1. Reading the Keyboard on X}

In X11, each key in the keyboard have a different and unique code
between8 and 255. This code represents the phisical pressed key, but
have no relation with an specific symbol associated to the key. The
symbol depends on the key mapping. To obtain the symbol associated
with the key, we need to translate the code to a symbol
(\monoespaco{keycode} to \monoespaco{keysym}). Anyway, this means that
we need to store information about a potential number of almost 256
keys. In our keyboard struct we put an additional position to store if
any key is being pressed.

\iniciocodigo
@<Define Macros@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#define W_KEYBOARD_SIZE 257
#endif
@
\fimcodigo

The moment we detect a new key pressing, we store in the list that the
key with a given keycode is being pressed. We do this only if the key
is not already being pressed:

\iniciocodigo
@<X11: Manage Events@>=
if(event.type == KeyPress){
  int i;
  for(i = 0; i < 36; i ++){
    if(pressed_keys[i].key == event.xkey.keycode) // Already being pressed
      break;
    if(pressed_keys[i].key == 0){ // The pressing is beginning now
      pressed_keys[i].key = event.xkey.keycode;
      pressed_keys[i].time = current_time;
      // Update keyboard:
      keyboad.key[event.xkey.keycode] = 1;
      break;
    }
  }
  if(i == 36) continue; // Ignoring: too many keypresses
}
@
\fimcodigo

When we detect a key release, we remove the key from the list of
pressed keys and add it to the key of released keys:

\iniciocodigo
@<X11: Manage Events@>+=
if(event.type == KeyRelease){
  int i;
  long stored_time = -1;
  for(i = 0; i < 36; i ++){ // Removing from pressed keys
    if(pressed_keys[i].key == event.xkey.key){
      int j;
      stored_time = pressed_keys[j].time;
      for(j = i; j < 35; j ++){
        pressed_keys[j].key = pressed_keys[j + 1].key;
        pressed_keys[j].time = pressed_keys[j + 1].time;
        if(pressed_keys[j].key == 0)
          break;
      }
      pressed_keys[35].key = 0;
      break;
    }
  }
  for(i = 0; i < 36; i ++){ // Adding to released keys:
    if(released_keys[i] == 0)
      released_keys[i] = event.xkey.keycode;
  }
  if(i == 36) // Too many key releases, ignore and clean keyboard
    keyboard.key[event.xkey.keycode] = 0;
  else{
    // Updating keyboard struct:
    keyboard.key[event.xkey.keycode] = - (long) (current_time - stored_time);
    if(keyboard[event.xkey.keycode] == 0)
      keyboard.key[event.xkey.keycode] = -1; // Press/release in the same frame
  }
}
@
\fimcodigo

While the above code manages correctly the keycodes, the user also
needs to know what these keycodes represent. Knowing that the key
0xff0d was pressed means very little. Knowing that the key ``Enter''
was pressed is much more meaningful. The user should be able to check
the content of \monoespaco{keyboard.key[W\_ENTER]} without needing to
know the keycde for the key. For this, during the kwyboard
initialization, we should discover all the symbols supported by our
keyboard, giving to them correct names. The code to initialize the
keyboard becames:

\iniciocodigo
@<Keyboard Initialization@>=
@<Flushing List of Pressed and Released Keys@>
// The last position in our key array always means "any key":
W_ANY = W_KEYBOARD_SIZE - 1;
// Other positions are defined by the environment. But 0 always means "no key":
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
{
  int i;
  for(i = 8; i < 256; i ++){
    unsigned long value = XkbKeycodeToKeysym(display, i, 0, 0);
    switch(value){
    case 0: break;
    case XK_Escape: W_ESC = i; break;
    case XK_BackSpace: W_BACKSPACE = i; break;
    case XK_Tab: W_TAB = i; break;
    case XK_Return: W_ENTER = i; break;
    case XK_Up:   W_UP   = i; break; case XK_Down:  W_DOWN =  i; break;
    case XK_Left: W_LEFT = i; break; case XK_RIGHT: W_RIGHT = i; break;
    case XK_0: W_0 = i; break;     case XK_1: W_1 = i; break;
    case XK_2: W_2 = i; break;     case XK_3: W_3 = i; break;
    case XK_4: W_4 = i; break;     case XK_5: W_5 = i; break;
    case XK_6: W_6 = i; break;     case XK_7: W_7 = i; break;
    case XK_8: W_8 = i; break;     case XK_9: W_9 = i; break;
    case XK_minus: W_MINUS = i; break;    case XK_plus: W_PLUS = i;
    case XK_F1: W_F1 = i; break;   case XK_F2: W_F2 = i; break;
    case XK_F3: W_F3 = i; break;   case XK_F4: W_F4 = i; break;
    case XK_F5: W_F5 = i; break;   case XK_F6: W_F6 = i; break;
    case XK_F7: W_F7 = i; break;   case XK_F8: W_F8 = i; break;
    case XK_F9: W_F9 = i; break;   case XK_F10: W_F10 = i; break;
    case XK_F11: W_F11 = i; break; case XK_F12: W_F12 = i; break;
    case XK_Shift_L: W_LEFT_SHIFT = i; break;
    case XK_Shift_R: W_RIGHT_SHIFT = i; break;
    case XK_Control_L: W_LEFT_CTRL = i; break;
    case XK_Control_R: W_RIGHT_CTRL = i; break;
    case XK_Alt_L: W_LEFT_ALT = i; break;
    case XK_Alt_R: W_RIGHT_ALT = i; break;
    case XK_Super_L: W_LEFT_SUPER = i; break;
    case XK_Super_R: W_RIGHT_SUPER = i; break;
    case XK_space: W_SPACE = i; break;
    case XK_A: W_A = i; break;   case XK_b: W_B = i; break;
    case XK_c: W_C = i; break;   case XK_d: W_D = i; break;
    case XK_e: W_E = i; break;   case XK_f: W_F = i; break;
    case XK_g: W_G = i; break;   case XK_h: W_H = i; break;
    case XK_i: W_I = i; break;   case XK_j: W_J = i; break;
    case XK_k: W_K = i; break;   case XK_l: W_L = i; break;
    case XK_m: W_M = i; break;   case XK_n: W_N = i; break;
    case XK_o: W_O = i; break;   case XK_p: W_P = i; break;
    case XK_q: W_Q = i; break;   case XK_r: W_R = i; break;
    case XK_s: W_S = i; break;   case XK_t: W_T = i; break;
    case XK_u: W_U = i; break;   case XK_v: W_V = i; break;
    case XK_w: W_W = i; break;   case XK_x: W_X = i; break;
    case XK_y: W_Y = i; break;   case XK_z: W_Z = i; break;
    case XK_Insert: W_INSERT = i; break;
    case XK_Home: W_HOME = i; break;
    case XK_Page_Up: W_PAGE_UP = i; break;
    case XK_Delete: W_DELETE = i; break;
    case XK_End: W_END = i; break;
    case XK_Pade_Down: W_PAGE_DOWN = i; break;
    default: break;
    }
  }
}
#endif
@
\fimcodigo

All these variables that represent positions in our array of keys need
to be declared:

\iniciocodigo
@<Window Declarations@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
extern int W_BACKSPACE, W_TAB, W_ENTER, W_UP, W_DOWN, W_LEFT, W_RIGHT, W_0, W_1,
           W_2, W_3, W_4, W_5, W_6, W_7, W_8, W_9, W_MINUS, W_PLUS, W_F1, W_F2,
           W_F3, W_F4, W_F5, W_F6, W_F7, W_F8, W_F9, W_F10, W_F11, W_F12,
           W_LEFT_SHIFT, W_RIGHT_SHIFT, W_LEFT_ALT, W_RIGHT_ALT, W_LEFT_CTRL,
           W_RIGHT_CTRL, W_LEFT_SUPER, W_RIGHT_SUPER, W_SPACE, W_A, W_B, W_C,
           W_D, W_E, W_F, W_G, W_H, W_I, W_J, W_K, W_L, W_M, W_N, W_O, W_P, W_Q,
           W_R, W_S, W_T, W_U, W_V, W_W, X_X, W_Y, W_Z, W_INSERT, W_HOME,
           W_PAGE_UP, W_DELETE, W_END, W_PAGE_DOWN, W_ESC;
#endif
@
\fimcodigo


And we should initialize them with zero. This value represents a
non-assigned key that never will be pressed or released. Only after
the keyboard initialization we assign them correct values:

\iniciocodigo
@<Global Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
int W_BACKSPACE, W_TAB, W_ENTER, W_UP, W_DOWN, W_LEFT, W_RIGHT, W_0, W_1,
    W_2, W_3, W_4, W_5, W_6, W_7, W_8, W_9, W_MINUS, W_PLUS, W_F1, W_F2,
    W_F3, W_F4, W_F5, W_F6, W_F7, W_F8, W_F9, W_F10, W_F11, W_F12,
    W_LEFT_SHIFT, W_RIGHT_SHIFT, W_LEFT_ALT, W_RIGHT_ALT, W_LEFT_CTRL,
    W_RIGHT_CTRL, W_LEFT_SUPER, W_RIGHT_SUPER, W_SPACE, W_A, W_B, W_C,
    W_D, W_E, W_F, W_G, W_H, W_I, W_J, W_K, W_L, W_M, W_N, W_O, W_P, W_Q,
    W_R, W_S, W_T, W_U, W_V, W_W, X_X, W_Y, W_Z, W_INSERT, W_HOME,
    W_PAGE_UP, W_DELETE, W_END, W_PAGE_DOWN, W_ESC;
#endif
@
\fimcodigo

\subsecao{3.2.2. Reading the Keyboard on Web Assembly}

Emscripten gives us access to keyboard keys using SDL API. The number
of supported keys in a keyboard is givn by
macro \monoespaco{SDL\_NUM\_SCANCODES} which, at the time of this
writting is equalo 512 different keys. Probably this value will not
change in the next future.

\iniciocodigo
@<Macro Definition@>+=
#if defined(__EMSCRIPTEN__)
#define W_KEYBOARD_SIZE (SDL_NUM_SCANCODES + 1)
#endif
@
\fimcodigo

In X11, we presented in the last subsection that there is a difference
between the phisical key and the symbol associated with it. The same
difference appear here in SDL. The phisical key in X was
called \monoespaco{Keycode} and here in SDL is
called \monoespaco{Scancode}. The symbol associated, that can change
depending on the key mapping, in X was called \monoespaco{Keysym} and
here is called \monoespaco{Scancode}. Yes, the terms are confusing
because a scancode means totally different things in both APIs. Using
the SDL naming, we detect with the following code if a key was pressed:

\iniciocodigo
@<Web Assembly: Manage Events@>=
if(event.type == SDL_KEYDOWN){
  int i;
  for(i = 0; i < 36; i ++){
    if(pressed_keys[i].key == event.key.keysym.scancode) // Already pressed
      break;
    if(pressed_keys[i].key == 0){ // Is being pressed now
      pressed_keys[i].key = event.key.keysym.scancode;
      pressed_keys[i].time = current_time;
      // Atualizando teclado:
      keyboad.key[event.key.keysym.scancode] = 1;
      break;
    }
  }
  if(i == 36) continue; // Ignoring: too many keypresses
}
@
\fimcodigo

To detect that a key is released, we use the following code:

\iniciocodigo
@<Web Assembly: Manage Events@>=+=
if(event.type == SDL_KEYUP){
  int i;
  long stored_time = -1;
  for(i = 0; i < 36; i ++){ // Removing from list of pressed keys
    if(pressed_keys[i].key == event.key.keysym.scancode){
      int j;
      stored_time = pressed_keys[j].time;
      for(j = i; j < 35; j ++){
        pressed_keys[j].key = pressed_keys[j + 1].key;
        pressed_keys[j].time = pressed_keys[j + 1].time;
        if(pressed_keys[j].key == 0)
          break;
      }
      pressed_keys[35].key = 0;
      break;
    }
  }
  for(i = 0; i < 36; i ++){ // Adding to the list of released keys
    if(released_keys[i] == 0)
      released_keys[i] = event.key.keysym.scancode;
  }
  if(i == 36) // Too many released keys, ignoring and cleaning keyboard:
    keyboard.key[event.key.keysym.scancode] = 0;
  else{
    // Updating Keyboard:
    keyboard.key[event.key.keysym.scancode] = -(long)(current_time - stored_time);
    if(keyboard[event.key.keysym.scancode] == 0)
      keyboard.key[event.key.keysym.scancode] = -1; // Simultaneous press/release
  }
}
@
\fimcodigo

The above code is identical to what was present in the X11 version. We
just had to update the names to match SDL structs. Now we need the
code that initializes correctly the name for our supported keys:

\iniciocodigo
@<Keyboard Initialization@>=
#if defined(__EMSCRIPTEN__)
{
  int i;
  for(i = 0; i < W_KEYBOARD_SIZE - 1; i ++){
    unsigned long value = SDL_GetKeyFromScancode(i);
    switch(value){
    case 0: break;
    case SDLK_ESCAPE: W_ESC = i; break;
    case SDLK_BACKSPACE: W_BACKSPACE = i; break;
    case SDLK_TAB: W_TAB = i; break;
    case SDLK_RETURN: W_ENTER = i; break;
    case SDLK_UP:   W_UP   = i; break; case SDLK_DOWN:  W_DOWN =  i; break;
    case SDLK_LEFT: W_LEFT = i; break; case SDLK_RIGHT: W_RIGHT = i; break;
    case SDLK_0: W_0 = i; break;     case SDLK_1: W_1 = i; break;
    case SDLK_2: W_2 = i; break;     case SDLK_3: W_3 = i; break;
    case SDLK_4: W_4 = i; break;     case SDLK_5: W_5 = i; break;
    case SDLK_6: W_6 = i; break;     case SDLK_7: W_7 = i; break;
    case SDLK_8: W_8 = i; break;     case SDLK_9: W_9 = i; break;
    case SDLK_MINUS: W_MINUS = i; break;    case SDLK_PLUS: W_PLUS = i;
    case SDLK_F1: W_F1 = i; break;   case SDLK_F2: W_F2 = i; break;
    case SDLK_F3: W_F3 = i; break;   case SDLK_F4: W_F4 = i; break;
    case SDLK_F5: W_F5 = i; break;   case SDLK_F6: W_F6 = i; break;
    case SDLK_F7: W_F7 = i; break;   case SDLK_F8: W_F8 = i; break;
    case SDLK_F9: W_F9 = i; break;   case SDLK_F10: W_F10 = i; break;
    case SDLK_F11: W_F11 = i; break; case SDLK_F12: W_F12 = i; break;
    case SDLK_LSHIFT: W_LEFT_SHIFT = i; break;
    case SDLK_RSHIFT: W_RIGHT_SHIFT = i; break;
    case SDLK_LCTRL: W_LEFT_CTRL = i; break;
    case SDLK_RCTRL: W_RIGHT_CTRL = i; break;
    case SDLK_LALT: W_LEFT_ALT = i; break;
    case SDLK_RALT: W_RIGHT_ALT = i; break;
    case SDLK_SPACE: W_SPACE = i; break;
    case SDLK_a: W_A = i; break;   case SDLK_b: W_B = i; break;
    case SDLK_c: W_C = i; break;   case SDLK_d: W_D = i; break;
    case SDLK_e: W_E = i; break;   case SDLK_f: W_F = i; break;
    case SDLK_g: W_G = i; break;   case SDLK_h: W_H = i; break;
    case SDLK_i: W_I = i; break;   case SDLK_j: W_J = i; break;
    case SDLK_k: W_K = i; break;   case SDLK_l: W_L = i; break;
    case SDLK_m: W_M = i; break;   case SDLK_n: W_N = i; break;
    case SDLK_o: W_O = i; break;   case SDLK_p: W_P = i; break;
    case SDLK_q: W_Q = i; break;   case SDLK_r: W_R = i; break;
    case SDLK_s: W_S = i; break;   case SDLK_t: W_T = i; break;
    case SDLK_u: W_U = i; break;   case SDLK_v: W_V = i; break;
    case SDLK_w: W_W = i; break;   case SDLK_x: W_X = i; break;
    case SDLK_y: W_Y = i; break;   case SDLK_z: W_Z = i; break;
    case SDLK_INSERT: W_INSERT = i; break;
    case SDLK_HOME: W_HOME = i; break;
    case SDLK_PAGEUP: W_PAGE_UP = i; break;
    case SDLK_DELETE: W_DELETE = i; break;
    case SDLK_END: W_END = i; break;
    case SDLK_PAGEDOWN: W_PAGE_DOWN = i; break;
    default: break;
    }
  }
}
#endif
@
\fimcodigo

\subsecao{3.2.3. Reading the Keyboard on Windows}

On windows the phisical keys are represented by
a \monoespaco{Scancode} and the symbol associated with it is called a
``virtual-key code''. The number of different scancodes is always 256,
and we need an additional position to represent ``any key'':

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
#define W_KEYBOARD_SIZE 257
#endif
@
\fimcodigo

Detecting keys being pressed is done using exactly he same code that
for X11 and SDL, just with some minor changes and also using different
names, as Windows calls differently its functions and structs:

\iniciocodigo
@<Windows: Manage Keyboard Events@>=
if(event.message == WM_KEYDOWN){
  int i, scancode = (event.lParam & 00ff0000) >> 16;
  for(i = 0; i < 36; i ++){
    if(pressed_keys[i].key == scancode) // Already pressed
      break;
    if(pressed_keys[i].key == 0){ // Is being pressed now
      pressed_keys[i].key = scancode;
      pressed_keys[i].time = current_time;
      // Atualizando teclado:
      keyboad.key[scancode] = 1;
      break;
    }
  }
  if(i == 36) continue; // Ignoring: too many keypresses
}
@
\fimcodigo

Note that on Windows, t get the scancode of a given key, we need to
use some bit manipulation. Other than this, the code is the same than
what was already presented for X11 and SDL. The code to detect a key
being released is:

\iniciocodigo
@<Windows: Manage Keyboard Events@>+=
if(event.type == WM_KEYUP){
  int i, scancode = (event.lParam & 00ff0000) >> 16;
  long stored_time = -1;
  for(i = 0; i < 36; i ++){ // Removing from list of pressed keys
    if(pressed_keys[i].key == scancode){
      int j;
      stored_time = pressed_keys[j].time;
      for(j = i; j < 35; j ++){
        pressed_keys[j].key = pressed_keys[j + 1].key;
        pressed_keys[j].time = pressed_keys[j + 1].time;
        if(pressed_keys[j].key == 0)
          break;
      }
      pressed_keys[35].key = 0;
      break;
    }
  }
  for(i = 0; i < 36; i ++){ // Adding to the list of released keys
    if(released_keys[i] == 0)
      released_keys[i] = scancode;
  }
  if(i == 36) // Too many released keys, ignoring and cleaning keyboard:
    keyboard.key[scancode] = 0;
  else{
    // Updating Keyboard:
    keyboard.key[scancode] = -(long)(current_time - stored_time);
    if(keyboard[scancode] == 0)
      keyboard.key[scancode] = -1; // Simultaneous press/release
  }
}
@
\fimcodigo

And finally, we initialize the names for each key, making them point
to the right position in our key array:

\iniciocodigo
@<Keyboard Initialization@>=
#if defined(_WIN32)
{
  int i;
  for(i = 0; i < W_KEYBOARD_SIZE - 1; i ++){
    unsigned long value = MapVirtualKey(i, MAPVK_VSK_TO_VSC_EX);
    switch(value){
    case 0: break;
    case VK_ESCAPE: W_ESC = i; break; 
    case VK_BACK: W_BACKSPACE = i; break;
    case VK_TAB: W_TAB = i; break;
    case VK_RETURN: W_ENTER = i; break;
    case VK_UP:   W_UP   = i; break; case VK_DOWN:  W_DOWN =  i; break;
    case VK_LEFT: W_LEFT = i; break; case VK_RIGHT: W_RIGHT = i; break;
    case '0': W_0 = i; break;     case '1': W_1 = i; break;
    case '2': W_2 = i; break;     case '3': W_3 = i; break;
    case '4': W_4 = i; break;     case '5': W_5 = i; break;
    case '6': W_6 = i; break;     case '7': W_7 = i; break;
    case '8': W_8 = i; break;     case '9': W_9 = i; break;
    case VK_OEM__MINUS: W_MINUS = i; break;    case VK_OEM__PLUS: W_PLUS = i;
    case VK_F1: W_F1 = i; break;   case VK_F2: W_F2 = i; break;
    case VK_F3: W_F3 = i; break;   case VK_F4: W_F4 = i; break;
    case VK_F5: W_F5 = i; break;   case VK_F6: W_F6 = i; break;
    case VK_F7: W_F7 = i; break;   case VK_F8: W_F8 = i; break;
    case VK_F9: W_F9 = i; break;   case VK_F10: W_F10 = i; break;
    case VK_F11: W_F11 = i; break; case VK_F12: W_F12 = i; break;
    case VK_LSHIFT: W_LEFT_SHIFT = i; break;
    case VK_RSHIFT: W_RIGHT_SHIFT = i; break;
    case VK_LCONTROL: W_LEFT_CTRL = i; break;
    case VK_RCONTROL: W_RIGHT_CTRL = i; break;
    case VK_MENU: W_LEFT_ALT = i; break;
    case VK_RMENU: W_RIGHT_ALT = i; break;
    case VK_SPACE: W_SPACE = i; break;
    case 'A': W_A = i; break;   case 'B': W_B = i; break;
    case 'C': W_C = i; break;   case 'D': W_D = i; break;
    case 'E': W_E = i; break;   case 'F': W_F = i; break;
    case 'G': W_G = i; break;   case 'H': W_H = i; break;
    case 'I': W_I = i; break;   case 'J': W_J = i; break;
    case 'K': W_K = i; break;   case 'L': W_L = i; break;
    case 'M': W_M = i; break;   case 'N': W_N = i; break;
    case 'O': W_O = i; break;   case 'P': W_P = i; break;
    case 'Q': W_Q = i; break;   case 'R': W_R = i; break;
    case 'S': W_S = i; break;   case 'T': W_T = i; break;
    case 'U': W_U = i; break;   case 'V': W_V = i; break;
    case 'W': W_W = i; break;   case 'X': W_X = i; break;
    case 'Y': W_Y = i; break;   case 'Z': W_Z = i; break;
    case VK_INSERT: W_INSERT = i; break;
    case VK_HOME: W_HOME = i; break;
    case VK_PRIOR: W_PAGE_UP = i; break;
    case VK_DELETE: W_DELETE = i; break;
    case VK_END: W_END = i; break;
    case VK_NEXT: W_PAGE_DOWN = i; break;
    default: break;
    }
  }
}
#endif
@
\fimcodigo

\subsecao{3.2.4. Additional Code for Keyboard Support}

With the code written above we can detect when a new key is pressed
and when it is released. Such code is Operating System dependent. But
we still did not write the code to update in each frame the number
representing how much time a key is being pressed. For this we need to
iterate over the list of pressed keys and for each of them, update the
number stored in the position for such key in our key array. We do
such thing in the function that reads input checking for new key
presses. But only after it already updated the list of pressed keys
with the new key presses from the current frame:

\iiciocodigo
@<After Reading Window Events@>=
{
  int i;
  // Update the information if any key is being pressed:
  keyboard[W_ANY] = (pressed_keys[0].key != 0);
  for(i = 0; i < 32; i ++){
    if(pressed_keys[i].key == 0)
      break;
    if(current_time > pressed_keys[i].key)
      keyboad.key[pressed_keys[i].key] = (current_time - pressed_keys[i].key);
  }
}
@
\fimcodigo

Now the timer for pressed keys will keep updating, not remaining
always with the number 1.

When the key is released, we already written code that turned to
negative its timer. But we still did not write the code that returns
the timer for the key to zero in the frame after the release. Before
reading thew input in each frame we should iterate over the list of
pressed keys and set their timers to zero, as the keys now are not
being pressed or released. Doing this we also should remove all keys
from the list of released keys:

\iniciocodigo
@<Before Reading Window Events@>=
{
  int i;
  for(i = 0; i < 32; i ++){
    if(released_keys[i] == 0)
      break;
    keyboard[released_keys[i]] = 0;
    released_keys[i] = 0;
  }
}
@
\fimcodigo

\subsecao{X. Final File Sctructure}

The file with all the necessary source code for the functions defined
in this article will have the following organization:

\iniciocodigo
@(src/window.c@>=
#include "window.h"
@<Headers@>
@<Local Functions@>
@<Global Variables@>
@<Local Variables@>
@<API Functions@>
@
\fimcodigo


\fim
