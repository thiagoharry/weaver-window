\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Windowing Interface Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of a portable
  Windowing API, which can be used to create a single window in
  Windows, Linux, BSD, or a canvas in Web Assembly running in a web
  browser. You can set a fullscreen mode, change the resolution in the
  window, resize it, use OpenGL commands and get input from mouse and
  keyboard. All this can be achieved by the portable API defined in
  this work.}

\secao{1. Introduction}

A graphical computer program needs a space where it can draw in the
screen. In some environments, lke video-games, each program always
controll the entire screen automatically, without asking for it to
some operating system. But when a computer program runs in a computer
with some modern graphical environment, usually it is necessary to ask
for the creation of some region called ``window''. There the program
have control over the content and can draw freely.

Besides creating the window, it is also important to have control if
we are in full-screen or not if we are in an environment that allows
this. And also change the size of our window in pixels. If we are in
fullscreen mode, this means changing the resolution of the
screen. Otherwise, this means changing the window size. This is
important because depending on the used visual effects, we could need
to draw less pixels in the screen for performance reasons.

\subsecao{1.1. Literary Programming and Notation}

This article uses the technique of ``Literary Programming'' to develop
our random number generator API. This technique was presented at
[Knuth, 1984] and have as objective develop software in a way that a
computer program to be compiled is exactly equal a document written
for human beings detailing and explaining the code. This document is
not independent of the source code, it is the project source
code. Automated tools are used to extract the code from this document,
sort it in the right order and produce the code that is passed to a
compiler.

For example, in this article we will define two different
files: \monoespaco{window.c} and \monoespaco{window.h}. Both of them
can be inserted statically in any project or compiled as a shared
library. The content of \monoespaco{window.h} is:

\iniciocodigo
@(src/window.h@>=
#ifndef WEAVER_WINDOW
#define WEAVER_WINDOW
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define type 'bool'
@<OpenGL Header@>
@<Macro Definition@>
@<Window Declarations@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The two first lines and the last one are macros that ensure that the
function declaration and variables from this file will always be
included at most once in a compiling unit. We also put macros to check
if we are compiling this as C or C++. If we are in C++, we assure the
compiler that all our functions will be in C-style. We never will
modify them with operator overload, for example. This makes the code
became more compact.

The red parts in the above code shows that some code will be inserted
there in the future. In ``RNG Declarations'', for example, we will put
there function declarations.

Each piece of code have a title, that in the above example is
\monoespaco{src/window.h}. The title shows where the code will be placed.
In the case above, the code will directly to a file. In future pieces
of code, we will have different titles, including titles matching
exactly the names present in the red code above. If a piece of code
have as title a name matching the red part in some code, then that
code is positioned exactly in that red part when compiling the code.

As a second example of code, we also will declare here that when we
are in debug mode (when the macro \monoespaco{W\_DEBUG\_WINDOW} is
declared) we will need the declaration of input/output functions, as
our code will be more verbose:

\iniciocodigo
@<Headers@>=
#if defined(W_DEBUG_WINDOW)
#include <stdio.h>
#endif
@
\fimcodigo

Notice that we still did not define where this code section called
``Headers'' will be positioned. We can do this later.

\subsecao{1.2. API functions that will be defined}

In this article we will define the following functions:

\iniciocodigo
@<Window Declarations@>=
bool _Wcreate_window(void);
@
\fimcodigo

This function will create a new window. By default, it will create a
fullscreen window. If the macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN}
is defined, instead it will create a non-fullscreen window.

If the macro \monoespaco{W\_DEBUG\_WINDOW} is defined, this function
also will print in the screen information about the graphical
environment. Its resolution for example. But possibly other
information that can be relevant.

In case of error, the function will return false.

\iniciocodigo
@<Window Declarations@>=
bool _Wdestroy_window(void);
@
\fimcodigo

This function closes the window, freeing any resource allocated during
the window creation by the previous function. This function must be
invoked only after a window was created. In case of error, it returns
false.

\iniciocodigo
@<Window Declarations@>+=
bool _Wrender_window(void);
@
\fimcodigo

This function will render in the screen all pending ommands since last
rendering. It will return false in case of error. This function
probably will be called in the end of each iteration in a main loop.


\secao{2. Creating and Managing the Window}

\subsecao{2.1. Creating a Window in X}

The X Window System, also known as X11, is a windowing system present
in many Operating System, as Linux, BSD and even in MacOX, where it
exists to ensure compatibility with older programs developed before
their current windowing system. We will begin our window creation with
X11 because is the most widely present windowing system.

X11 works in a client-server architecture. When we create a graphical
program, we create a client that communicates with X server using
sockets. All operations like window creation, resizing windows and
more are made when with the client asking for them sending requests to
the server, which executes the requests if possible.

We expect to use X11 when we are not compiling programs to Windows or
to Web Assembly, as both the Windows Operating System and web browsers
do not have a X11 server. If we will use X11, we need the following
header:

\iniciocodigo
@<Headers@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xlib.h>
#endif
@
\fimcodigo

In X11, as we need to communicate with a server, we create a window
following the steps below:

0. We ask the X libraryq to be prepared for simultaneous
communications caming from multiple threads. It is not common needing
to do this, but it is a good practice to be prepared if this
happens. This must be the first thing to do, before using other
library functions.

1. We open a connection with the server. If we succeed, we get as
response a list of relevant information about the screen.

2. We read from the response which is the default screen where we
should create our window (a computer could have many different
monitors and screens).

3. We also read the screen resolution.

4. We send a new message to the server asking to create a new
window. We will do it in the default screen, The window size will be
the greatest value allowed given the screen resolution.

The above steps are implemented using the functions and macros below:

\iniciocodigo
@<X11: Create Window@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
/* Step 0: */
XInitThreads();
/* Step 1: */
display = XOpenDisplay(NULL);
if(display == NULL){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Failed to connect to X11 server.\n");
#endif
  return false; // Couldn't connect
}
/* Step 2: */
screen = DefaultScreen(display);
/* Step 3: */
screen_resolution_x = DisplayWidth(display, screen);
screen_resolution_y = DisplayHeight(display, screen);
/* Step 4: */
window = XCreateSimpleWindow(display, // X11 connection
                             DefaultRootWindow(display),// Parent window
                             0, 0, // Window position
                             screen_resolution_x, // Width
                             screen_resolution_y, // Height
                             0, 0, // Border width and color
                             0); // Default window color
#endif
@
\fimcodigo

This code assumes that we have the following declared variables:

\iniciocodigo
@<Local Variables@>=
static int screen_resolution_x, screen_resolution_y; //Screen resolution
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static Display *display = NULL; //Connection with server and screen info
static int screen;       // Deafult screen id
static Window window;    // Created window struct
#endif
@
\fimcodigo

The code defined above creates a window, but it does not mean that the
created window is drawn in the screen. Before drawing the window in
the screen we can adjust some of its properties.

The first thing that we need to adjust is that by default the window
should be created in fullscreen mode. We do this asking to the window
manager do not interefere with the window creating decorations or
limiting its size. But we do this only if the user did not disable
fullscreen setting a macro:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if !defined(W_WINDOW_NO_FULLSCREEN)
{
  XSetWindowAttributes attributes;
  attributes.override_redirect = true;
  XChangeWindowAttributes(display, window, CWOverrideRedirect,
                          &attributes);
}
#endif
#endif
@
\fimcodigo

But what if we are running outside the fullscreen mode and the user
has defined macros that configure the window size to a different size
than occupy the whole screen? In this case, we need to resize the
window before drawing it for the first time. The macros that control
the window size when we are not in fullscreen mode
are \monoespaco{W\_WINDOW\_RESOLUTION\_X}
and \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. If they are non-positive,
then this means that we should set their values as the greatest
possible given the screen resolution. Otherwise, their values
represent the size in pixels for the window. But this is true only
outside fullscreen mode:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#if defined(W_WINDOW_NO_FULLSCREEN)
{
  int size_x, size_y;
#if W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#else
  size_x = screen_resolution_x;
#endif
#if W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#else
  size_y = screen_resolution_y;
#endif
  XResizeWindow(display, window, size_x, size_y);
}
#endif
#endif
@
\fimcodigo

We also will warn the window manager to not allow window resizing. The
window should be resized only using resizing functions that we will
soon define:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
{
  XSizeHints hints;
  hints.flags = PMinSize | PMaxSize;
#if defined(W_WINDOW_NO_FULLSCREEN) && W_WINDOW_RESOLUTION_X > 0
  hints.min_width = hints.max_width = W_WINDOW_RESOLUTION_X;
#else
  hints.min_width = hints.max_width = screen_resolution_x;
#endif
#if defined(W_WINDOW_NO_FULLSCREEN) && W_WINDOW_RESOLUTION_Y > 0
  hints.min_height = hints.max_height = W_WINDOW_RESOLUTION_Y;
#else
  hints.min_height = hints.max_height = screen_resolution_y;
#endif
  XSetWMNormalHints(display, window, &hints);
}
#endif
@
\fimcodigo

The above resource needs the following header:

\iniciocodigo
@<Headers@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <X11/Xutil.h>
#endif
@
\fimcodigo

Another relevant information to adjust is what kind of events is
relevant to pass to the program when something happen to the
window. For example, we do not consider relevant if the user interacts
with another window making our window lose focus. But other events,
like the information that the user pressed a key is relevant and our
program should be informed.

The list of events that we consider relevant is: the window is created
or destroyed, the user presses or releases a mouse button, presses or
releases a key in keyboard and if the user moves the mouse pointer. If
we do not ask the server to send this information, our program would
not be able to know if the user interacts with it pressing keys.

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XSelectInput(display, window, StructureNotifyMask | KeyPressMask |
                              KeyReleaseMask | ButtonPressMask |
                              ButtonReleaseMask | PointerMotionMask);
#endif
@
\fimcodigo

Another important thing is choose the name for our window. Usually
this name is presented by the window manager. We let the user choose
the name setting the macro \monoespaco{W\_WINDOW\_NAME}:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XStoreName(display, window, W_WINDOW_NAME);
#endif
@
\fimcodigo

If this macro is not defined, we use an empty string:

@<Macro Definition@>+=
#if !defined(W_WINDOW_NAME)
#define W_WINDOW_NAME ""
#endif
@
\fimcodigo

Now we configure OpenGL ES. As this is sufficiently laborious, we
write the necessary steps in the next session:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
@<X11: Configure OpenGL ES@>
#endif
@
\fimcodigo

After adjusting all the configurations, we can draw the created
window. For this, we send a request to the server X and wait in a loop
until we are notified that the window was created (we asked to be
notified of this event when we passed
flag \monoespaco{StructureNotifyMask} to
function \monoespaco{XSelectInput} previously). The code for this is:

\iniciocodigo
@<X11: Create Window@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
XMapWindow(display, window);
{
  XEvent e;
  do{
    XNextEvent(display, &e);
  } while(e.type != MapNotify);
}
#endif
@
\fimcodigo

\subsecao{2.2. Configuring OpenGL ES in X11}

In X11, the interface used to program in OpenGL ES is called EGL and
its functions and macros are declared in the following header:

\iniciocodigo
@<OpenGL Header@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include <EGL/eglext.h>
#endif
@
\fimcodigo

Now we need to create a structure needed by OpenGL ES to store
information about the graphical interface: a OpenGL display. Such
display can be obtained from the X display that we already created:

\iniciocodigo
@<X11: Configure OpenGL ES@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
egl_display = eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR, display,
                                    NULL);
if(egl_display == EGL_NO_DISPLAY){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL display.\n");
#endif
  return false;
}
eglInitialize(egl_display, NULL, NULL);
#endif
@
\fimcodigo

This variable is declared here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLDisplay *egl_display;
#endif
@
\fimcodigo

Now we need to obtain a configuration to the creation of a OpenGL
context. We specify some requirements and get a configuration using
the code below:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
{
  bool ret;
  int number_of_configs_returned;
  int requested_attributes[] = {
    // We should support drawing in the screen and textures
    EGL_SURFACE_TYPE,  EGL_WINDOW_BIT | EGL_PBUFFER_BIT,
    // And at least 1 bit to the red color:
    EGL_RED_SIZE, 1,
    // At least 1 bit to the green color:
    EGL_GREEN_SIZE, 1,
    // At least 1 bit to the blue color:
    EGL_BLUE_SIZE, 1,
    // At least 1 bit to the alpha channel:
    EGL_ALPHA_SIZE, 1,
    // At least 1 bit to the depth channel:
    EGL_DEPTH_SIZE, 1,
    EGL_NONE
  };
  ret = eglChooseConfig(egl_display, requested_attributes,
                        &egl_config, 1, &number_of_configs_returned);
  if(ret == EGL_FALSE){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create valid EGL config.\n");
#endif
    return false;
  }
}
@
\fimcodigo

The struct that stores which configuration we will use is declared
here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
EGLConfig egl_config;
#endif
@
\fimcodigo


Like how EGL needs its own display struct, it also needs its own
window struct to store information about the window where it will
draw. We can initialize such structure from the window struct used by
the X library:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
egl_window = eglCreateWindowSurface(egl_display, egl_config,
                                    window, NULL);
if(egl_window == EGL_NO_SURFACE){
#if defined(W_DEBUG_WINDOW)
  fprintf(stderr, "ERROR: Could not create EGL window.\n");
#endif
  return false;
}
@
\fimcodigo

The EGL window is decared here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLSurface egl_window;
#endif
@
\fimcodigo


Now we can create the OpenGL context. We let the user choose which
will be the major and minor OpenGL version using
macros \monoespaco{W\_WINDOW\_OPENGL\_MAJOR\_VERSION} and
\monoespaco{W\_WINDOW\_OPENGL\_MINOR\_VERSION}. With this information, we create the context:

\iniciocodigo
@<X11: Configure OpenGL ES@>+=
{
  int context_attribs[] = {
    EGL_CONTEXT_MAJOR_VERSION, W_WINDOW_OPENGL_MAJOR_VERSION,
    EGL_CONTEXT_MINOR_VERSION, W_WINDOW_OPENGL_MINOR_VERSION,
    EGL_NONE
  };
  egl_context = eglCreateContext(egl_display, egl_config,
                                 EGL_NO_CONTEXT, context_attribs);
  if(egl_context == EGL_NO_CONTEXT){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Could not create EGL context.\n");
#endif
    return false;
  }
  eglMakeCurrent(egl_display, egl_window, egl_window, egl_context);
}
@
\fimcodigo

The variable that stores the handle to the OpenGL context is declared
here:

\iniciocodigo
@<Local Variables@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
static EGLContext egl_context;
#endif
@
\fimcodigo

\subsecao{2.3. Creating a ``Window'' in a Web Browser}

One of the most different environments where our API can be executed
are web browsers after the code is compiled to Web Assembly. In this
case, there are no true window, the space where we can draw in the
screen is a HTML canvas. We do not need to worry about the possibility
of the user resize the window, for example. But we still need to pay
attention to the size of the screen and should allow the resizing of
our canvas.

Here we can create and manipulare the drawing area combining two
things: the SDL library, presented as an interface to graphical
actions by Emscripten environment and Javascript code that we also can
execute.

First we include the Emscripten and SDL headers:

\iniciocodigo
@<OpenGL Header@>+=
#if defined(__EMSCRIPTEN__)
#include <GLES2/gl2.h>
#include <SDL/SDL.h>
#include <emscripten.h>
#endif
@
\fimcodigo


Our first challenge in this environment is discover screen
resolution. We can do this using the following Javascript code:

\iniciocodigo
@<Web Assembly: Create Window@>=
#if defined(__EMSCRIPTEN__)
screen_resolution_x = EM_ASM_INT({
  return window.screen.width * window.devicePixelRatio;
});
screen_resolution_y = EM_ASM_INT({
  return window.screen.height * window.devicePixelRatio;
});
#endif
@
\fimcodigo

Next we want to initialize the window SDL subsystem. This is done
calling the function below:

\iniciocodigo
@<Web Assembly: Create Window@>+=
#if defined(__EMSCRIPTEN__)
SDL_Init(SDL_INIT_VIDEO);
#endif
@
\fimcodigo

Now we will create the window, which in practice means adjust the
canvas size where we will draw and initialize it. The HTML canvas
should be the screen size, except if the user defined
macro \monoespaco{W\_WINDOW\_NO\_FULLSCREEN} and defined positive
values for \monoespaco{W\_WINDOW\_RESOLUTION\_X}
and \monoespaco{W\_WINDOW\_RESOLUTION\_Y}. We also ensure that the
canvas is visible using Javascript, as it could be hidden (we do it
when we execute the function to close the window).

\iniciocodigo
@<Web Assembly: Create Window@>+=
#if defined(__EMSCRIPTEN__)
{
  int size_x, size_y, fullscreen_flag = SDL_WINDOW_FULLSCREEN;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
#if defined(W_WINDOW_NO_FULLSCREEN)
  fullscreen_flag = 0;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUtION_X > 0
  size_x = W_WINDOW_RESOLUtION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUtION_Y > 0
  size_y = W_WINDOW_RESOLUtION_Y;
#endif
#endif
  // Ajusta versão do OpenGL
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION,
                     W_WINDOW_OPENGL_MAJOR_VERSION);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION,
                     W_WINDOW_OPENGL_MINOR_VERSION);
  // Garante que o canvas estará visível
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "initial";
  );
  window = SDL_SetVideoMode(size_x, size_y, 0,
                            SDL_OPENGL | fullscreen_flag);
  if(window == NULL)
    return false;
}
#endif
@
\fimcodigo

The window in this case is considered a SDL surface:

\iniciocodigo
@<Local Variables@>+=
#if defined(__EMSCRIPTEN__)
static SDL_Surface *window;
#endif
@
\fimcodigo

\subsecao{2.4. Creating a Windows in (Microsoft) Windows}

As always, to program in Windows we need the following header:

\iniciocodigo
@<Headers@>+=
#if defined(_WIN32)
#include <Windows.h>
#endif
@
\fimcodigo

Now we obtain the resolution of the main monitor using:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
screen_resolution_x = GetSystemMetrics(SM_CXSCREEN);
screen_resolution_y = GetSystemMetrics(SM_CYSCREEN);
#endif
@
\fimcodigo

Next we need to define a class for our window. First we need to give
it an arbitrary name in a string format. We will call it
``WeaverWindow'':

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static const char *class_name = "WeaverWindow";
#endif
@
\fimcodigo

Now our class need a function to handle signals and messages sent to
the window. Such messages are sent when the window is created,
destroyed, resized, exposed, for example. We always can redirect the
messages to function \monoespaco{DefWindowProc} to deal with them
using default actions, but for some messages it is best to define
ourselves the correct action to be taken. The function format is:

\iniciocodigo
@<API Functions@>+=
#if defined(_WIN32)
LRESULT CALLBACK WindowProc(HWND window, UINT msg, WPARAM param1, LPARAM param2){
  switch(msg){
    @<Windows: Deal with Window Messages@>
    default:
      return DefWindowProc(window, msg, param1, param2);
  }
}
#endif
@
\fimcodigo

But when will we deal with the received message instead of just
passing it to \monoespaco{DefWindowProc}? One of the cases is when the
window get a message warning that it is being closed:

\iniciocodigo
@<Windows: Deal with Window Messages@>=
case WM_DESTROY:
  PostQuitMessage(0);
  return 0;
  break;
@
\fimcodigo

Now we need to create a class for our window. The class should have an
unique non-conflicting name. We also pass an identifier with the
instance of our program (that we get
with \monoespaco{GetModuleHandle}) and the function to deal with
signals and messages for the window (in our case, the
default \monoespaco{DefWindowProc}).

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
if(!already_created_a_class){
  ATOM ret;
  WNDCLASS window_class;
  memset(&window_class, 0, sizeof(WNDCLASS));
  window_class.lpfnWndProc = WindowProc;
  window_class.hInstance = GetModuleHandle(NULL);
  window_class.lpszClassName = class_name;
  window_class.hbrBackground = CreateSolidBrush(RGB(0, 0, 0)); // Black window
  ret = RegisterClass(&window_class);
  if(ret == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to register Window Class. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  already_created_a_class = true;
}
#endif
@
\fimcodigo

For convenince, we used the function \monoespaco{memset} to initialize
the struct of our window class, as the majority of its elements can be
set to zero to keep the default value. Because of this, we insert the
following header:

\iniciocodigo
@<Cabeçalhos@>+=
#if defined(_WIN32)
#include <string.h>
#endif
@
\fimcodigo

The code above assumes that we have declared a boolean variable that
stores if we already created a class:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static bool already_created_a_class = false;
#endif
@
\fimcodigo

After defining the window class, we can create the window with the
code below:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
{
  int size_x, size_y;
  DWORD fullscreen_flag = WS_POPUP;
  RECT size;
  size_x = screen_resolution_x;
  size_y = screen_resolution_y;
  SystemParametersInfoA(SPI_GETWORKAREA, 0, &size, 0);
#if !defined(W_WINDOW_FORCE_FULLSCREEN) && \
    defined(W_WINDOW_NO_FULLSCREEN)
  size_x = size.left - size.right;
  size_y = size.bottom - size.top;
  fullscreen_flag = WS_OVERLAPPED;
#if defined(W_WINDOW_RESOLUTION_X) && W_WINDOW_RESOLUTION_X > 0
  size_x = W_WINDOW_RESOLUTION_X;
#endif
#if defined(W_WINDOW_RESOLUTION_Y) && W_WINDOW_RESOLUTION_Y > 0
  size_y = W_WINDOW_RESOLUTION_Y;
#endif
#endif
  window = CreateWindowEx(0, class_name,
                          W_WINDOW_NAME,
                          fullscreen_flag | WS_VISIBLE,
                          size.left, size.top, size_x, size_y,
                          NULL, NULL,
                          GetModuleHandle(NULL),
                          NULL);
  if(window == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating window. SysCode: %d\n",
            GetLastError());
#endif
    return false;
  }
}
#endif
@
\fimcodigo

We will store the handle to the created window in this variable:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static HWND window;
#endif
@
\fimcodigo

Before showing the window on the screen we configure OpenGL on it:

\iniciocodigo
@<Windows: Criar Janela@>+=
#if defined(_WIN32)
@<Windows: Configurar OpenGL@>
#endif
@
\fimcodigo

Now we ask the system to show the window to the user and then wait in
a loop until we get a message saying that the window was created:

\iniciocodigo
@<Windows: Create Window@>+=
#if defined(_WIN32)
{
  MSG msg;
  ShowWindow(window, SW_NORMAL);
  do{
    GetMessage(&msg, NULL, 0, 0);
  } while(msg.message == WM_CREATE);
}
#endif
@
\fimcodigo

\subsecao{2.5. Configuring OpenGL on Windows}

To use OpenGL on Windows, first we need to include the header:

\iniciocodigo
@<OpenGL Header@>+=
#if defined(_WIN32)
#include <windows.h>
#include <GL/gl.h>
#endif
@
\fimcodigo

We also need an struct with information about the device where we will
draw. In our case, a window:

\iniciocodigo
@<Windows: Configure OpenGL@>=
device_context = GetDC(window);
@
\fimcodigo

This struct is declared here with the context that we will soon initialize:

\iniciocodigo
@<Local Variables@>+=
#if defined(_WIN32)
static HGLRC wgl_context;
static HDC device_context;
#endif
@
\fimcodigo

Besides this, configuring OpenGL on Windows is a little messy. To
start, the default function that creates an OpenGL
context, \monoespaco{wglCreateContext}, is too primitive, without
guaranteed support for more recent OpenGL functions and without
support for necessary parameters to create a modern OpenGL
context. But we can use an alternative function to create a modern
OpenGL context: \monoespaco{wglCreateContextAttribsARB}. Using this
function we can do some basic stuff, like choosing which OpenGL
version we want and we can ask for support to modern OpenGL functions
and that support more parameters.

The problem is that the
function \monoespaco{wglCreateContextAttribsARB} is not a part of the
API, but it is an extension. We must load this function using an
auxiliary function before using it to create a context. But to use the
function that loads it, we need an existing OpenGL context active.

This can be solved first creating a basic OpenGL context using the
default API, loading the function that creates a proper context,
creating a modern context, associating it to a window and loading all
the necessary function that is not part of the default API. But it is
not possible to associate more than one OpenGL context to a single
window. So to load our function we need to create a dummy window and
dummy context before:

\iniciocodigo
@<Windows: Configure OpenGL@>=
{
@<Windows: Create Dummy Window@>
@<Windows: Create Dummy Context@>
@<Windows: Load Initial OpenGL Functions@>
@<Windows: Remove Dummy Context and Window@>
}
@
\fimcodigo

First let's create our dummy window. As this will not be our rendering
window, we do not need to create it using all the specifications from
the real window:

\iniciocodigo
@<Windows: Create Dummy Window@>=
HWND dummy_window;
{
  WNDCLASS dummy_window_class;
  memset(&dummy_window_class, 0, sizeof(WNDCLASS));
  dummy_window_class.lpfnWndProc = WindowProc;
  dummy_window_class.hInstance = GetModuleHandle(NULL);
  dummy_window_class.lpszClassName = "DummyWindow";
  // This is expected to fail if the class already is registered. It happens
  // when we create more than one window with this function. So we just ignore
  // errors returned by this function:
  RegisterClass(&dummy_window_class);
  SetLastError(0);
  dummy_window = CreateWindowEx(0, dummy_window_class.lpszClassName, "Dummy",
                                0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, 0, 0,
                                dummy_window_class.hInstance, 0);
  if(dummy_window == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating window. SysCode: %d\n",
            GetLastError());
#endif
    return false;
  }
}
@
\fimcodigo

Now to create a dummy context first we ned to choose an existing pixel
format similar to what we specify and then we set the pixel format in
our dummy window:

\iniciocodigo
@<Windows: Create Dummy Context@>=
HGLRC dummy_context;
HDC dummy_device_context = GetDC(dummy_window);
{
  PIXELFORMATDESCRIPTOR pixel_format;
  int chosen_pixel_format;
  memset(&pixel_format, 0, sizeof(WNDCLASS));
  pixel_format.nSize = sizeof(PIXELFORMATDESCRIPTOR); // Tamanho da estrutura
  pixel_format.nVersion = 1; // Número de versão
  pixel_format.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL |
                         PFD_DOUBLEBUFFER | PFD_DRAW_TO_BITMAP;
  pixel_format.iPixelType = PFD_TYPE_RGBA;
  pixel_format.cColorBits = 24; // 24 bits para profundidade de cor
  pixel_format.cDepthBits = 32; // 32 bits para buffer de profundidade
  pixel_format.iLayerType = PFD_MAIN_PLANE;
  chosen_pixel_format = ChoosePixelFormat(dummy_device_context, &pixel_format);
  if(chosen_pixel_format == 0){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to choose a pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  if(! SetPixelFormat(dummy_device_context, chosen_pixel_format, &pixel_format)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed to set a pixel format. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  // ...
@
\fimcodigo

And after configuring the pixel format, we can get the dummy OpenGL
context:

\iniciocodigo
@<Windows: Create Dummy COntext@>+=
  // ...
  dummy_context = wglCreateContext(dummy_device_context);
  if(dummy_context == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed creating dummy OpenGL context. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
  if(! wglMakeCurrent(dummy_device_context, dummy_context)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Failed setting dummy OpenGL context. SysError: %d\n",
            GetLastError());
#endif
    return false;
  }
}
@
\fimcodigo

Now we need to load the functions that we need. Loading existing
functions that are not normally accessible because they are considered
extensions, can be done using the
function \monoespaco{wglGetProcAddress} as in the loading function
below that returns a pointer to the desired function:

\iniciocodigo
@<Local Functions@>+=
#if defined(_WIN32)
static void *load_function(const char *name){
  void *ret = wglGetProcAddress(name);
  if(ret == NULL || ret == (void *) -1 || ret == (void *) 0x1 ||
     ret == (void *) 0x2 || ret == (void *) 0x3){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: Function '%s' not supported.\n", name);
#endif
    return NULL;
  }
  return ret;
}
#endif
@
\fimcodigo

Notice that as revealed by the code above, the
function \monoespaco{wglGetProcAddress} can return up to 5 different
values in case of error. Despite the fact that according with the
documentation, only \monoespaco{NULL} is the correct way to signal an
error.

The two needed functions is one that chooses a pixel format (like the
pixel format chosen above, but with more options and resources) and
another that creates an OpenGL context (like the dummy context above,
but also with more options and resources).

To load new functions, first we declare pointers to store the memory
position where are our new loaded functions. In the case of the two
functions that we want now, their ponters are declared
on \monoespaco{window.h} with the code below:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern BOOL (__stdcall *wglChoosePixelFormatARB)(HDC, const int *, const FLOAT *,
                                                 UINT, int *, UINT *);
extern HGLRC (*wglCreateContextAttribsARB)(HDC, HGLRC, const int *);
#endif
@
\fimcodigo


We also place the real declaration on file \monoespaco{window.c}:

\iniciocodigo
@<Global Variables@>=
#if defined(_WIN32)
BOOL (__stdcall *wglChoosePixelFormatARB)(HDC, const int *, const FLOAT *, UINT,
                                          int *, UINT *);
HGLRC (*wglCreateContextAttribsARB)(HDC, HGLRC, const int *);
#endif
@
\fimcodigo

Once we have the pointers, we can initialize them loading and storing
in them the functions in which we are interested:

\iniciocodigo
@<Windows: Load Initial OpenGL Functions@>+=
wglChoosePixelFormatARB = (BOOL (__stdcall *)(HDC, const int *, const FLOAT *,
                                              UINT, int *, UINT *))
                          load_function("wglChoosePixelFormatARB");
if(wglChoosePixelFormatARB == NULL) return false;
wglCreateContextAttribsARB = (HGLRC (*)(HDC, HGLRC, const int *))
                               load_function("wglCreateContextAttribsARB");
if(wglCreateContextAttribsARB == NULL) return false;
@
\fimcodigo

And finally, after loading these two functions, we do not need anymore
the dummy window and context:

\iniciocodigo
@<Windows: Remove Dummy Context and Window@>=
wglMakeCurrent(dummy_device_context, 0);
wglDeleteContext(dummy_context);
ReleaseDC(dummy_window, dummy_device_context);
DestroyWindow(dummy_window);
@
\fimcodigo

Now we are ready to choose our pixel format (the OpenGL configuration)
in the modern way with our new function:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
{
  PIXELFORMATDESCRIPTOR pixel_format_descriptor;
  const int pixel_format_attributes[] = {
    WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
    WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
    WGL_DOUBLE_BUFFER_ARB, GL_TRUE,
    WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,
    WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
    WGL_COLOR_BITS_ARB, 32,
    WGL_DEPTH_BITS_ARB, 24,
    WGL_STENCIL_BITS_ARB, 8,
    0 };
  int pixel_format_index = 0;
  UINT number_of_formats = 0;
  if(!wglChoosePixelFormatARB(device_context, pixel_format_attributes, NULL, 1,
                              &pixel_format_index,
                              (UINT *) (&number_of_formats))){
#if defined(W_DEBUG_WINDOW)
     fprintf(stderr, "ERROR: 'wglChoosePixelFormatARB' failed.\n");
#endif
     return false;
  }
  if(number_of_formats == 0){
#if defined(W_DEBUG_WINDOW)
     fprintf(stderr,
             "ERROR: no pixel format returned by 'wglChoosePixelFormatARB'.\n");
#endif
     return false;
  }
  DescribePixelFormat(device_context, pixel_format_index,
                      sizeof(pixel_format_descriptor), &pixel_format_descriptor);
  if(!SetPixelFormat(device_context, pixel_format_index,
                     &pixel_format_descriptor)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'SetPixelFormat' failed.\n");
#endif
    return false;
  } 
}
@
\fimcodigo


Now we will specify that we want a context with OpenGL version
specified by two macros. And then use the funtion that creates a
modern OpenGL context:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
{
  const int opengl_attributes[] = {
    WGL_CONTEXT_MAJOR_VERSION_ARB, W_WINDOW_OPENGL_MAJOR_VERSION,
    WGL_CONTEXT_MINOR_VERSION_ARB, W_WINDOW_OPENGL_MINOR_VERSION,
    WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,
    0 };
  wgl_context = wglCreateContextAttribsARB(device_context, 0, opengl_attributes);
  if(wgl_context == NULL){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'wglCreateContextAttribsARB' failed.\n");
#endif
    return false;
  }
  if(!wglMakeCurrent(device_context, wgl_context)){
#if defined(W_DEBUG_WINDOW)
    fprintf(stderr, "ERROR: 'wglMakeCurrent' failed.\n");
#endif
    return false;
  }
}
@
\fimcodigo

While creating a real OpenGL context, we used some macros that are not
defined. As we use them locally, we declare them in the header of file
\monoespaco{window.c}:

\iniciocodigo
@<Headers@>+=
#define WGL_TYPE_RGBA_ARB                      0x202B
#define WGL_PIXEL_TYPE_ARB                     0x2013
#define WGL_COLOR_BITS_ARB                     0x2014
#define WGL_DEPTH_BITS_ARB                     0x2022
#define WGL_STENCIL_BITS_ARB                   0x2023
#define WGL_ACCELERATION_ARB                   0x2003
#define WGL_DOUBLE_BUFFER_ARB                  0x2011
#define WGL_CONTEXT_FLAGS_ARB                  0x2094
#define WGL_DRAW_TO_WINDOW_ARB                 0x2001
#define WGL_SUPPORT_OPENGL_ARB                 0x2010
#define WGL_FULL_ACCELERATION_ARB              0x2027
#define WGL_CONTEXT_MAJOR_VERSION_ARB          0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB          0x2092
#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x0002
@
\fimcodigo

But we want to support in our API the functions compatible with OpenGL
ES 2.0. Lots of such functions also are not part of the API presented
by WGL n Windows. What we need to do is load such functions as
extensions. For example, we start declaring the pointers for functions
related with shader creation and management:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLuint (*glCreateShader)(GLenum shaderType);
extern void (*glShaderSource)(GLuint, GLsizei, const GLchar **, const GLint *);
extern void (*glCompileShader)(GLuint);
extern void (*glReleaseShaderCompiler)(void);
extern void (*glDeleteShader)(GLuint);
#endif
@
\fimcodigo

Next we position he pointers as global variables in our
file \monoespaco{window.c}:

\iniciocodigo
@<Global Variables@>=
#if defined(_WIN32)
GLuint (*glCreateShader)(GLenum shaderType);
void (*glShaderSource)(GLuint, GLsizei, const GLchar **, const GLint *);
void (*glCompileShader)(GLuint);
void (*glReleaseShaderCompiler)(void);
void (*glDeleteShader)(GLuint);
#endif
@
\fimcodigo

Next we load for each of these pointers the corresponding function
using the function that we defined a little above, before all the
pointer declarations:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glCreateShader = (GLuint (*)(GLenum)) load_function("glCreateShader");
if(glCreateShader == NULL)
  return false;
glShaderSource = (void (*)(GLuint, GLsizei, const GLchar **, const GLint *))
                    load_function("glShaderSource");
if(glShaderSource == NULL)
  return false;
glCompileShader = (void (*)(GLuint)) load_function("glCompileShader");
if(glCompileShader == NULL)
  return false;
glReleaseShaderCompiler = (void (*)(void))
                             load_function("glReleaseShaderCompiler");
if(glReleaseShaderCompiler == NULL)
  return false;
glDeleteShader = (void (*)(GLuint)) load_function("glDeleteShader");
if(glDeleteShader == NULL)
  return false;
@
\fimcodigo

When we create a shader with \monoespaco{glCreateShader}, we need to
choose what kind of shader should be created passing one of the
following macros as argument:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_VERTEX_SHADER          0x8B31
#define GL_FRAGMENT_SHADER        0x8B30
#endif
@
\fimcodigo

The type \monoespaco{GLchar} also must be defined on Windows:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
typedef char GLchar;
#endif
@
\fimcodigo


After compiling a shader, usually the user wants to check if the
compilation was successful. This is done using functions that make
queries about shaders, \monoespaco{glGetShaderiv} in particular. We
define all functions related with queries about shaders here:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern boolean (*glIsShader)(GLuint);
extern void (*glGetShaderiv)(GLuint, GLenum, GLint *);
extern void (*glGetAttachedShaders)(GLuint, GLsizei, GLsizei *, GLuint *);
extern void (*glGetShaderInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
extern void (*glGetShaderSource)(GLuint, GLsizei, GLsizei *, GLchar *);
extern void (*glGetShaderPrecisionFormat)(GLenum, GLenum, GLint *, GLint *);
extern void (*glGetVertexAttribfv)(GLuint, GLenum, GLfloat *);
extern void (*glGetVertexAttribiv)(GLuint, GLenum, GLint *);
extern void (*glGetVertexAttribPointerv)(GLuint, GLenum, void **);
extern void (*glGetUniformfv)(GLuint, GLint, GLfloat *);
extern void (*glGetUniformiv)(GLuint, GLint, GLint *);
#endif
@
\fimcodigo

The pointers are positioned here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
boolean (*glIsShader)(GLuint);
void (*glGetShaderiv)(GLuint, GLenum, GLint *);
void (*glGetAttachedShaders)(GLuint, GLsizei, GLsizei *, GLuint *);
void (*glGetShaderInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
void (*glGetShaderSource)(GLuint, GLsizei, GLsizei *, GLchar *);
void (*glGetShaderPrecisionFormat)(GLenum, GLenum, GLint *, GLint *);
void (*glGetVertexAttribfv)(GLuint, GLenum, GLfloat *);
void (*glGetVertexAttribiv)(GLuint, GLenum, GLint *);
void (*glGetVertexAttribPointerv)(GLuint, GLenum, void **);
void (*glGetUniformfv)(GLuint, GLint, GLfloat *);
void (*glGetUniformiv)(GLuint, GLint, GLint *);
#endif
@
\fimcodigo

Each function is loaded to its respective pointer with:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glIsShader = (boolean (*)(GLuint)) load_function("glIsShader");
if(glIsShader == NULL) return false;
glGetShaderiv = (void (*)(GLuint, GLenum, GLint *))
                   load_function("glGetShaderiv");
if(glGetShaderiv == NULL) return false;
glGetAttachedShaders = (void (*)(GLuint, GLsizei, GLsizei *, GLuint *))
                         load_function("glGetAttachedShaders");
if(glGetAttachedShaders == NULL) return false;
glGetShaderInfoLog = (void (*)(GLuint, GLsizei, GLsizei *, GLchar *))
                         load_function("glGetShaderInfoLog");
if(glGetShaderInfoLog == NULL)  return false;
glGetShaderSource = (void (*)(GLuint, GLsizei, GLsizei *, GLchar *))
                       load_function("glGetShaderSource");
if(glGetShaderSource == NULL) return false;
glGetShaderPrecisionFormat = (void (*)(GLenum, GLenum, GLint *, GLint *))
                                load_function("glGetShaderPrecisionFormat");
if(glGetShaderPrecisionFormat == NULL) return false;
glGetVertexAttribfv = (void (*)(GLuint, GLenum, GLfloat *))
                         load_function("glGetVertexAttribfv");
if(glGetVertexAttribfv == NULL) return false;
glGetVertexAttribiv = (void (*)(GLuint, GLenum, GLint *))
                        load_function("glGetVertexAttribiv");
if(glGetVertexAttribiv == NULL) return false;
glGetVertexAttribPointerv = (void (*)(GLuint, GLenum, void **))
                               load_function("glGetVertexAttribPointerv");
if(glGetVertexAttribPointerv == NULL) return false;
glGetUniformfv = (void (*)(GLuint, GLint, GLfloat *))
                     load_function("glGetUniformfv");
if(glGetUniformfv == NULL) return false;
glGetUniformiv = (void (*)(GLuint, GLint, GLint *))
                     load_function("glGetUniformiv");
if(glGetUniformiv == NULL) return false;
@
\fimcodigo

When the function \monoespaco{glGetShaderiv} is used, we can select
which information about the shader we want to know passing one of the
following macros:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_SHADER_TYPE          0x8B4F
#define GL_DELETE_STATUS        0x8B80
#define GL_COMPILE_STATUS       0x8B81
#define GL_INFO_LOG_LENGTH      0x8B84
#define GL_SHADER_SOURCE_LENGTH 0x8B88
#endif
@
\fimcodigo

When the function \monoespaco{glGetShaderPrecisionFormat} is used to
check for the precision of a given type, the chosen type is defined
passing one of these macros:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_LOW_FLOAT    0x8DF0
#define GL_MEDIUM_FLOAT 0x8DF1
#define GL_HIGH_FLOAT   0x8DF2
#define GL_LOW_INT      0x8DF3
#define GL_MEDIUM_INT   0x8DF4
#define GL_HIGH_INT     0x8DF5
#endif
@
\fimcodigo

When the function \monoespaco{glGetVertexAttribfv}
or \monoespaco{glGetVertexAttribiv} are used to obtain information
about vertices, the wanted information is informed passing as argument
one of the following macros:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED        0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE           0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE         0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE           0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED     0x886A
#define GL_CURRENT_VERTEX_ATTRIB              0x8626
#endif
@
\fimcodigo

When using function \monoespaco{glGetVertexzAttribPointerv}, we must
pass as one of the arguments the following macro:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
#endif
@
\fimcodigo

Let's also define this macro that is useful to query about which GLSL
implementation we have:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
#endif
@
\fimcodigo

Once the user created and compiled shaders, usually she would need to
create a program and link the shaders to the program. To enable this,
we declare below the pointer for all functions about program
management:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLuint (*glCreateProgram)(void);
extern void (*glAttachShader)(GLuint, GLuint);
extern void (*glDetachShader)(GLuint, GLuint);
extern void (*glLinkProgram)(GLuint);
extern void (*glUseProgram)(GLuint);
extern void (*glDeleteProgram)(GLuint);
#endif
@
\fimcodigo

These declared ponters are effectively positioned here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
GLuint (*glCreateProgram)(void);
void (*glAttachShader)(GLuint, GLuint);
void (*glDetachShader)(GLuint, GLuint);
void (*glLinkProgram)(GLuint);
void (*glUseProgram)(GLuint);
void (*glDeleteProgram)(GLuint);
#endif
@
\fimcodigo

And we initialize them with the correct functions:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glCreateProgram = (GLuint (*)(void)) load_function("glCreateProgram");
if(glCreateProgram == NULL) return false;
glAttachShader = (void (*)(GLuint, GLuint)) load_function("glAttachShader");
if(glAttachShader == NULL) return false;
glDetachShader = (void (*)(GLuint, GLuint)) load_function("glDetachShader");
if(glDetachShader == NULL) return false;
glLinkProgram = (void (*)(GLuint)) load_function("glLinkProgram");
if(glLinkProgram == NULL) return false;
glUseProgram = (void (*)(GLuint)) load_function("glUseProgram");
if(glUseProgram == NULL) return false;
glDeleteProgram = (void (*)(GLuint)) load_function("glDeleteProgram");
if(glDeleteProgram == NULL) return false;
@
\fimcodigo

After finishing the program creation, usually the user wants to know
if it was successful.  For this, we need to prepare the pointers for
functions that deal with program queries:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLboolean (*glIsProgram)(GLuint);
extern void (*glGetProgramiv)(GLuint, GLenum, GLint *);
extern void (*glGetProgramInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
extern void (*glValidadeProgram)(GLuint);
#endif
@
\fimcodigo

We place the real pointers here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
GLboolean (*glIsProgram)(GLuint);
void (*glGetProgramiv)(GLuint, GLenum, GLint *);
void (*glGetProgramInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
void (*glValidadeProgram)(GLuint);
#endif
@
\fimcodigo

And we initialize them with the real functions:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glIsProgram = (GLboolean (*)(GLuint)) load_function("glIsProgram");
if(glIsProgram == NULL) return false;
glGetProgramiv = (void (*)(GLuint, GLenum, GLint *))
                    load_function("glGetProgramiv");
if(glGetProgramiv == NULL) return false;
glGetProgramInfoLog = (void (*)(GLuint, GLsizei, GLsizei *, GLchar *))
                          load_function("glGetProgramInfoLog");
if(glGetProgramInfoLog == NULL) return false;
glValidadeProgram = (void (*)(GLuint)) load_function("glValidateProgram");
if(glValidadeProgram == NULL) return false;
@
\fimcodigo

When we use \monoespaco{glGetProgramiv} to obtain information about a
program, we pass one of the following macros as argument to select
which information we want to know:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_DELETE_STATUS               0x8B80
#define GL_LINK_STATUS                 0x8B82
#define GL_VALIDATE_STATUS             0x8B83
#define GL_INFO_LOG_LENGTH             0x8B84
#define GL_ATTACHED_SHADERS            0x8B85
#define GL_ACTIVE_ATTRIBUTES           0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
#define GL_ACTIVE_UNIFORMS             0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH   0x8B87
#endif
@
\fimcodigo

To obtain and set vertices attributes in a shader, we can use
functions that will be associated with the following pointers:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern void (*glGetActiveAttrib)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                                 GLenum *, GLchar *);
extern GLint (*glGetAttribLocation)(GLuint, const GLchar *);
extern void (*glBindAttribLocation)(GLuint, GLuint, const GLchar *);
#endif
@
\fimcodigo

The pointers are positioned here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
void (*glGetActiveAttrib)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                                 GLenum *, GLchar *;)
GLint (*glGetAttribLocation)(GLuint, const GLchar *);
void (*glBindAttribLocation)(GLuint, GLuint, const GLchar *);
#endif
@
\fimcodigo

And they are initialized here:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glGetActiveAttrib = (void (*)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                     GLenum *, GLchar *)) load_function("glGetActiveAttrib");
if(glGetActiveAttrib == NULL) return false;
glGetAttribLocation = (GLint (*)(GLuint, const GLchar *))
                           load_function("glGetAttribLocation");
if(glGetAttribLocation == NULL) return false;
glBindAttribLocation = (void (*)(GLuint, GLuint, const GLchar *))
                              load_function("glBindAttribLocation");
if(glBindAttribLocation == NULL) return false;
@
\fimcodigo

The type of each vertex attribute returned
by \monoespaco{glGetActiveAttrib} can be:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_FLOAT      0x1406
#define GL_FLOAT_VEC2 0x8B50
#define GL_FLOAT_VEC3 0x8B51
#define GL_FLOAT_VEC4 0x8B52
#define GL_FLOAT_MAT2 0x8B5A
#define GL_FLOAT_MAT3 0x8B5B
#define GL_FLOAT_MAT4 0x8B5C
#endif
@
\fimcodigo

And finally, the last functions related with shaders are the ones
responsible to deal with uniform variables:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern GLint (*glGetUniformLocation)(GLuint, const GLchar *);
extern void (*glGetActiveUniform)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                                  GLenum *, GLchar *);
extern void (*glUniform1f)(GLint, GLfloat);
extern void (*glUniform2f)(GLint, GLfloat, GLfloat);
extern void (*glUniform3f)(GLint, GLfloat, GLfloat, GLfloat);
extern void (*glUniform4f)(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
extern void (*glUniform1i)(GLint, GLint);
extern void (*glUniform2i)(GLint, GLint, GLint);
extern void (*glUniform3i)(GLint, GLint, GLint, GLint);
extern void (*glUniform4i)(GLint, GLint, GLint, GLint, GLint);
extern void (*glUniform1fv)(GLint, GLsizei, const GLfloat *);
extern void (*glUniform2fv)(GLint, GLsizei, const GLfloat *);
extern void (*glUniform3fv)(GLint, GLsizei, const GLfloat *);
extern void (*glUniform4fv)(GLint, GLsizei, const GLfloat *);
extern void (*glUniform1iv)(GLint, GLsizei, const GLint *);
extern void (*glUniform2iv)(GLint, GLsizei, const GLint *);
extern void (*glUniform3iv)(GLint, GLsizei, const GLint *);
extern void (*glUniform4iv)(GLint, GLsizei, const GLint *);
extern void (*glUniformMatrix2fv)(GLint, GLsizei, GLboolean, const GLfloat *);
extern void (*glUniformMatrix3fv)(GLint, GLsizei, GLboolean, const GLfloat *);
extern void (*glUniformMatrix4fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#endif
@
\fimcodigo

These 21 pointers are positioned here:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
GLint (*glGetUniformLocation)(GLuint, const GLchar *);
void (*glGetActiveUniform)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                           GLenum *, GLchar *);
void (*glUniform1f)(GLint, GLfloat);
void (*glUniform2f)(GLint, GLfloat, GLfloat);
void (*glUniform3f)(GLint, GLfloat, GLfloat, GLfloat);
void (*glUniform4f)(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
void (*glUniform1i)(GLint, GLint);
void (*glUniform2i)(GLint, GLint, GLint);
void (*glUniform3i)(GLint, GLint, GLint, GLint);
void (*glUniform4i)(GLint, GLint, GLint, GLint, GLint);
void (*glUniform1fv)(GLint, GLsizei, const GLfloat *);
void (*glUniform2fv)(GLint, GLsizei, const GLfloat *);
void (*glUniform3fv)(GLint, GLsizei, const GLfloat *);
void (*glUniform4fv)(GLint, GLsizei, const GLfloat *);
void (*glUniform1iv)(GLint, GLsizei, const GLint *);
void (*glUniform2iv)(GLint, GLsizei, const GLint *);
void (*glUniform3iv)(GLint, GLsizei, const GLint *);
void (*glUniform4iv)(GLint, GLsizei, const GLint *);
void (*glUniformMatrix2fv)(GLint, GLsizei, GLboolean, const GLfloat *);
void (*glUniformMatrix3fv)(GLint, GLsizei, GLboolean, const GLfloat *);
void (*glUniformMatrix4fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#endif
@
\fimcodigo

And now we need to initialize all these 21 pointers:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glGetUniformLocation = (GLint (*)(GLuint, const GLchar *))
                            load_function("glGetUniformLocation");
if(glGetUniformLocation == NULL) return false;
glGetActiveUniform = (void (*)(GLuint, GLuint, GLsizei, GLsizei *, GLint *,
                      GLenum *, GLchar *)) load_function("glGetActiveUniform");
if(glGetActiveUniform == NULL) return false;
glUniform1f = (void (*)(GLint, GLfloat)) load_function("glUniform1f");
if(glUniform1f == NULL) return false;
glUniform2f = (void (*)(GLint, GLfloat, GLfloat)) load_function("glUniform2f");
if(glUniform2f == NULL) return false;
glUniform3f = (void (*)(GLint, GLfloat, GLfloat, GLfloat))
                        load_function("glUniform3f");
if(glUniform3f == NULL) return false;
glUniform4f = (void (*)(GLint, GLfloat, GLfloat, GLfloat, GLfloat))
                        load_function("glUniform4f");
if(glUniform4f == NULL) return false;
glUniform1i = (void (*)(GLint, GLint)) load_function("glUniform1i");
if(glUniform1i == NULL) return false;
glUniform2i = (void (*)(GLint, GLint, GLint)) load_function("glUniform2i");
if(glUniform2i == NULL) return false;
glUniform3i = (void (*)(GLint, GLint, GLint, GLint)) load_function("glUniform3i");
if(glUniform3i == NULL) return false;
glUniform4i = (void (*)(GLint, GLint, GLint, GLint, GLint))
                 load_function("glUniform4i");
if(glUniform4i == NULL) return false;
glUniform1fv = (void (*)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform1fv");
if(glUniform1fv == NULL) return false;
glUniform2fv = (void (*)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform2fv");
if(glUniform2fv == NULL) return false;
glUniform3fv = (void (*)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform3fv");
if(glUniform3fv == NULL) return false;
glUniform4fv = (void (*)(GLint, GLsizei, const GLfloat *))
                 load_function("glUniform4fv");
if(glUniform4fv == NULL) return false;
glUniform1iv = (void (*)(GLint, GLsizei, const GLint *))
                 load_function("glUniform1iv");
if(glUniform1iv == NULL) return false;
glUniform2iv = (void (*)(GLint, GLsizei, const GLint *))
                 load_function("glUniform2iv");
if(glUniform2iv == NULL) return false;
glUniform3iv = (void (*)(GLint, GLsizei, const GLint *))
                 load_function("glUniform3iv");
if(glUniform3iv == NULL) return false;
glUniform4iv = (void (*)(GLint, GLsizei, const GLint *))
                 load_function("glUniform4iv");
if(glUniform4iv == NULL) return false;
glUniformMatrix2fv = (void (*)(GLint, GLsizei, GLboolean, const GLfloat *))
                      load_function("glUniformMatrix2fv");
if(glUniformMatrix2fv == NULL) return false;
glUniformMatrix3fv = (void (*)(GLint, GLsizei, GLboolean, const GLfloat *))
                      load_function("glUniformMatrix3fv");
if(glUniformMatrix3fv == NULL) return false;
glUniformMatrix4fv = (void (*)(GLint, GLsizei, GLboolean, const GLfloat *))
                      load_function("glUniformMatrix4fv");
if(glUniformMatrix4fv == NULL) return false;
@
\fimcodigo

The uniform variables can have the same types than vertex attributes
and also these new types:

\iniciocodigo
@<Macro Definition@>+=
#if defined(_WIN32)
#define GL_INT         0x1404
#define GL_INT_VEC2    0x8B53
#define GL_INT_VEC3    0x8B54
#define GL_INT_VEC4    0x8B55
#define GL_BOOL        0x8B56
#define GL_BOOL_VEC2   0x8B57
#define GL_BOOL_VEC3   0x8B58
#define GL_BOOL_VEC4   0x8B59
#define GL_SAMPLER_2D  0x8B5E
#define GL_SAMPER_CUBE 0x8B60
#endif
@
\fimcodigo

The last thing necessary to render simple images is send vertices to
the video card. One of the ways to do this is sending a pointer
instead of the entire vertex list. This can be done using the
following functions related to vertices:

\iniciocodigo
@<Window Declarations@>+=
#if defined(_WIN32)
extern void (*glVertexAttrib1f)(GLuint, GLfloat);
extern void (*glVertexAttrib2f)(GLuint, GLfloat, GLfloat);
extern void (*glVertexAttrib3f)(GLuint, GLfloat, GLfloat, GLfloat);
extern void (*glVertexAttrib4f)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
extern void (*glVertexAttrib1fv)(GLuint, GLfloat *);
extern void (*glVertexAttrib2fv)(GLuint, GLfloat *);
extern void (*glVertexAttrib3fv)(GLuint, GLfloat *);
extern void (*glVertexAttrib4fv)(GLuint, GLfloat *);
extern void (*glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean,
                                     GLsizei, const void *);
extern void (*glEnableVertexAttribArray)(GLuint);
extern void (*glDisableVertexAttribArray)(GLuint);
#endif
@
\fimcodigo

These pointers are positioned as global variables:

\iniciocodigo
@<Global Variables@>+=
#if defined(_WIN32)
void (*glVertexAttrib1f)(GLuint, GLfloat);
void (*glVertexAttrib2f)(GLuint, GLfloat, GLfloat);
void (*glVertexAttrib3f)(GLuint, GLfloat, GLfloat, GLfloat);
void (*glVertexAttrib4f)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
void (*glVertexAttrib1fv)(GLuint, GLfloat *);
void (*glVertexAttrib2fv)(GLuint, GLfloat *);
void (*glVertexAttrib3fv)(GLuint, GLfloat *);
void (*glVertexAttrib4fv)(GLuint, GLfloat *);
void (*glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean,
                              GLsizei, const void *);
void (*glEnableVertexAttribArray)(GLuint);
void (*glDisableVertexAttribArray)(GLuint);
#endif
@
\fimcodigo

And initialize them:

\iniciocodigo
@<Windows: Configure OpenGL@>+=
glVertexAttrib1f = (void (*)(GLuint, GLfloat)) load_function("glVertexAttrib1f");
if(glVertexAttrib1f == NULL) return false;
glVertexAttrib2f = (void (*)(GLuint, GLfloat, GLfloat))
                      load_function("glVertexAttrib2f");
if(glVertexAttrib2f == NULL) return false;
glVertexAttrib3f = (void (*)(GLuint, GLfloat, GLfloat, GLfloat))
                      load_function("glVertexAttrib3f");
if(glVertexAttrib3f == NULL) return false;
glVertexAttrib4f = (void (*)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat))
                      load_function("glVertexAttrib4f");
if(glVertexAttrib4f == NULL) return false;
glVertexAttrib1fv = (void (*)(GLuint, GLfloat *))
                       load_function("glVertexAttrib1fv");
if(glVertexAttrib1fv == NULL) return false;
glVertexAttrib2fv = (void (*)(GLuint, GLfloat *))
                       load_function("glVertexAttrib2fv");
if(glVertexAttrib2fv == NULL) return false;
glVertexAttrib3fv = (void (*)(GLuint, GLfloat *))
                       load_function("glVertexAttrib3fv");
if(glVertexAttrib3fv == NULL) return false;
glVertexAttrib4fv = (void (*)(GLuint, GLfloat *))
                       load_function("glVertexAttrib4fv");
if(glVertexAttrib4fv == NULL) return false;
glVertexAttribPointer = (void (*)(GLuint, GLint, GLenum, GLboolean,
                         GLsizei, const void *))
                              load_function("glVertexAttribPointer");
if(glVertexAttribPointer == NULL) return false;
glEnableVertexAttribArray = (void (*)(GLuint))
                              load_function("glEnableVertexAttribArray");
if(glEnableVertexAttribArray == NULL) return false;
glDisableVertexAttribArray = (void (*)(GLuint))
                               load_function("glDisableVertexAttribArray");
if(glDisableVertexAttribArray == NULL) return false;
@
\fimcodigo

And besides the types that are already defined, we also need to define
the following type for vertex attributes:

\iniciocodigo
@<Define Macros@>+=
#if defined(_WIN32)
/*#define GL_BYTE           0x1400
#define GL_UNSIGNED_BYTE  0x1401
#define GL_SHORT          0x1402
#define GL_UNSIGNED_SHORT 0x1403*/
#define GL_FIXED          0x140C
#endif
@
\fimcodigo


\subsecao{2.6. Window Creation Function}

Our function that creates a new window will execute the adequate code,
depending on the graphical environment where termosit is being
executed. But before this we will add code to check if a window
already was created. This information will be stored in a boolean
variable:

\iniciocodigo
@<API Functions@>=
bool _Wcreate_window(void){
  if(already_have_window == true)
    return false;
  @<X11: Create Window@>
  @<Web Assembly: Create Window@>
  @<Windows: Create Window@>
  already_have_window = true;
  return true;
}
@
\fimcodigo

The variable that stores if the window already was created will be
declared here:

\iniciocodigo
@<Local Variables@>+=
static bool already_have_window = false;
@
\fimcodigo

There is one last thing to define about the window creation, more
specifically about the OpenL context associated with the created
window. We need to choose a default OpenGL version to load when the
used do not set the macros used to choose this.

When we are running in X11, we can use EGL to create an OpenGL ES
context. In this case, we prefer version 3.0, as is the newer version
that also supports all OpenGL ES 2.0 resources.

If we are running in a browser using Web Assembly, we want to use
WebGL 2, as this version is equivalent to OpenGL Es 3.0.

If we are running on Windows, not all drivers and hardware support
OpenGL ES API. Because of this, we choose to use OpenGL 4.0, as this
is a more common version that support the modern OpenGL functions used
by OpenGL ES.

Our macro that sets the OpenGL version, because of this, is:

\iniciocodigo
@<Headers@>+=
#if defined(_WIN32) && !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 4
#define W_WINDOW_OPENGL_MINOR_VERSION 1
#elif defined(__EMSCRIPTEN__) && !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 2
#define W_WINDOW_OPENGL_MINOR_VERSION 0
#elif !defined(W_WINDOW_OPENGL_MAJOR_VERSION)
#define W_WINDOW_OPENGL_MAJOR_VERSION 3
#define W_WINDOW_OPENGL_MINOR_VERSION 0
#endif
@
\fimcodigo

\subsecao{2.7. Closing a Window in X}

Closing a window in X11 means calling the function that asks the
server to close the window and also closing the connection with the
server. This is done calling respectively \monoespaco{XDestroyWindow}
and \monoespaco{XCloseDisplay}. We also check if we really have an
existing window before trying to close and destroy it.

\iniciocodigo
@<API Functions@>=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                 EGL_NO_CONTEXT );
  eglDestroySurface(egl_display, egl_window);
  eglDestroyContext(egl_display, egl_context);
  eglTerminate(egl_display);
  XDestroyWindow(display, window);
  XCloseDisplay(display);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.8. Closing a Window in Web Assembly}

Closing a window when running in a web browser means finalize the SDL
structures and hide the canvas where we were drawing. We do this with
the following function:

\iniciocodigo
@<API Functions@>+=
#if defined(__EMSCRIPTEN__)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  SDL_FreeSurface(window);
  EM_ASM(
    var el = document.getElementById("canvas");
    el.style.display = "none";
  );
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.9. Closing a Window on Windows}

Closing a window in Windows means calling a simple function to destroy
the window:

\iniciocodigo
@<API Functions@>+=
#if defined(_WIN32)
bool _Wdestroy_window(void){
  if(already_have_window == false)
    return false;
  wglMakeCurrent(NULL, NULL);
  wglDeleteContext(wgl_context);
  DestroyWindow(window);
  already_have_window = false;
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.10. Rendering window in X} 

In X, when we asked EGL to create a window, by default it creates a
double buffered window. Rendering in the screen means in this case to
swap the window buffers. The back buffer where we were drawing became
the front buffer, what is shown in the screen, and vice-versa. This is
achieved with the following code:

\iniciocodigo
@<API Functions@>+=
#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)
bool _Wrender_window(void){
  return eglSwapBuffers(egl_display, egl_window);
}
#endif
@
\fimcodigo

\subsecao{2.10. Rendering window in Emscripten}

It is not necessary to perform any additional operation to render the
previous Open GL commands if we are using Web Assembly compiled by
Emscripten. So we only use \monoespaco{glFlush} to wait for any
pending command to execute before resuming our code.

\iniciocodigo
@<API Functions@>+=
#if defined(__EMSCRIPTEN__)
bool _Wrender_window(void){
  glFlush();
  return true;
}
#endif
@
\fimcodigo

\subsecao{2.10. Rendering window in (Microsoft) Windows}

In Windows, the WGL function responsible for swapping buffers in the
window making our drawings visible is
called \monoespaco{wglSwapLayerBuffers}:

\iniciocodigo
@<API Functions@>+=
#if defined(_WIN32)
bool _Wrender_window(void){
  return wglSwapLayerBuffers(device_context, WGL_SWAP_MAIN_PLANE);
}
#endif
@
\fimcodigo



\subsecao{X. Final File Sctructure}

The file with all the necessary source code for the functions defined
in this article will have the following organization:

\iniciocodigo
@(src/window.c@>=
#include "window.h"
@<Headers@>
@<Local Functions@>
@<Global Variables@>
@<Local Variables@>
@<API Functions@>
@
\fimcodigo


\fim
